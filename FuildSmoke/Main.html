<!DOCTYPE html>
<html>
<head>
    <title>WebGL Fluid Smoke Simulator</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: white;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            padding: 1rem 1.5rem;
            background-color: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 320px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        h1 {
            font-size: 1.25rem;
            margin: 0 0 0.5rem 0;
            font-weight: 600;
        }
        p {
            font-size: 0.9rem;
            margin: 0;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.8);
        }
        a {
            color: #4dabf7;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="glcanvas"></canvas>
    <div id="info-panel">
        <h1>WebGL Fluid Smoke</h1>
        <p>Click and drag your mouse to add forces and color to the fluid simulation.</p>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            v_texCoord = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>
    
    <!-- This base shader is used for simple texture rendering -->
    <script id="base-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_texture;
        void main() {
            gl_FragColor = texture2D(u_texture, v_texCoord);
        }
    </script>

    <!-- Advection: Moves quantities through the velocity field -->
    <script id="advect-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_velocity;
        uniform sampler2D u_source;
        uniform vec2 u_texelSize;
        uniform float u_dt;
        uniform float u_dissipation;

        void main() {
            vec2 pos = v_texCoord - u_dt * texture2D(u_velocity, v_texCoord).xy * u_texelSize;
            gl_FragColor = u_dissipation * texture2D(u_source, pos);
        }
    </script>

    <!-- Splat: Adds density/force at a point -->
    <script id="splat-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_target;
        uniform float u_aspectRatio;
        uniform vec3 u_color;
        uniform vec2 u_point;
        uniform float u_radius;

        void main() {
            vec2 p = v_texCoord - u_point.xy;
            p.x *= u_aspectRatio;
            vec3 splat = exp(-dot(p, p) / u_radius) * u_color;
            vec3 base = texture2D(u_target, v_texCoord).xyz;
            gl_FragColor = vec4(base + splat, 1.0);
        }
    </script>

    <!-- Divergence: Calculates the divergence of the velocity field -->
    <script id="divergence-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_velocity;
        uniform vec2 u_texelSize;

        void main () {
            float L = texture2D(u_velocity, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
            float R = texture2D(u_velocity, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
            float B = texture2D(u_velocity, v_texCoord - vec2(0.0, u_texelSize.y)).y;
            float T = texture2D(u_velocity, v_texCoord + vec2(0.0, u_texelSize.y)).y;

            vec2 C = texture2D(u_velocity, v_texCoord).xy;
            if (v_texCoord.x < u_texelSize.x) { L = -C.x; }
            if (v_texCoord.x > 1.0 - u_texelSize.x) { R = -C.x; }
            if (v_texCoord.y < u_texelSize.y) { B = -C.y; }
            if (v_texCoord.y > 1.0 - u_texelSize.y) { T = -C.y; }

            float div = 0.5 * (R - L + T - B);
            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
        }
    </script>

    <!-- Pressure Solver (Jacobi Iteration) -->
    <script id="pressure-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_pressure;
        uniform sampler2D u_divergence;
        uniform vec2 u_texelSize;

        void main () {
            float L = texture2D(u_pressure, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
            float R = texture2D(u_pressure, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
            float B = texture2D(u_pressure, v_texCoord - vec2(0.0, u_texelSize.y)).x;
            float T = texture2D(u_pressure, v_texCoord + vec2(0.0, u_texelSize.y)).x;
            float C = texture2D(u_pressure, v_texCoord).x;
            
            float divergence = texture2D(u_divergence, v_texCoord).x;
            float pressure = (L + R + B + T - divergence) * 0.25;
            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
        }
    </script>
    
    <!-- Gradient Subtraction: Makes the velocity field divergence-free -->
    <script id="gradient-subtract-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_pressure;
        uniform sampler2D u_velocity;
        uniform vec2 u_texelSize;

        void main () {
            float L = texture2D(u_pressure, v_texCoord - vec2(u_texelSize.x, 0.0)).x;
            float R = texture2D(u_pressure, v_texCoord + vec2(u_texelSize.x, 0.0)).x;
            float B = texture2D(u_pressure, v_texCoord - vec2(0.0, u_texelSize.y)).x;
            float T = texture2D(u_pressure, v_texCoord + vec2(0.0, u_texelSize.y)).x;
            
            vec2 velocity = texture2D(u_velocity, v_texCoord).xy;
            velocity.xy -= 0.5 * vec2(R - L, T - B);
            gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
    </script>

    <!-- Display Shader: Renders the final density to the screen -->
    <script id="display-fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        varying vec2 v_texCoord;
        uniform sampler2D u_texture;
        
        void main () {
            vec3 C = texture2D(u_texture, v_texCoord).rgb;
            float a = max(C.r, max(C.g, C.b));
            gl_FragColor = vec4(C, a);
        }
    </script>


    <script>
        'use strict';
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported!');
        }
        
        // --- Configuration ---
        const SIM_RESOLUTION = 128;
        const DYE_RESOLUTION = 512;
        const PRESSURE_ITERATIONS = 20;
        const DENSITY_DISSIPATION = 0.98;
        const VELOCITY_DISSIPATION = 0.99;
        const SPLAT_RADIUS = 0.005;

        // --- Global Variables ---
        let simWidth, simHeight, dyeWidth, dyeHeight;
        let lastTime = Date.now();
        const pointers = [];
        let splatStack = [];
        
        // --- WebGL Programs and Buffers ---
        const programs = {};
        const quadBuffer = gl.createBuffer();
        
        // --- Framebuffer Objects (FBOs) ---
        let density, velocity, divergence, pressure;

        // --- Main Execution ---
        init();
        
        function init() {
            setupWebGL();
            compileShaders();
            createFBOs();
            initPointers();
            
            // Generate initial random splats for a nice start
            for (let i = 0; i < 10; i++) {
                const color = [Math.random() * 0.5 + 0.2, Math.random() * 0.5 + 0.2, Math.random() * 0.5 + 0.2];
                const x = Math.random();
                const y = Math.random();
                const dx = (Math.random() - 0.5) * 10;
                const dy = (Math.random() - 0.5) * 10;
                splat(x, y, dx, dy, color);
            }
            
            update();
        }

        function setupWebGL() {
            gl.getExtension('OES_texture_float');
            gl.getExtension('OES_texture_float_linear');
            
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function compileShaders() {
            const vs = compileShader(gl.VERTEX_SHADER, document.getElementById('vertex-shader').textContent);
            programs.base = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('base-fragment-shader').textContent));
            programs.advect = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('advect-fragment-shader').textContent));
            programs.splat = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('splat-fragment-shader').textContent));
            programs.divergence = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('divergence-fragment-shader').textContent));
            programs.pressure = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('pressure-fragment-shader').textContent));
            programs.gradientSubtract = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('gradient-subtract-fragment-shader').textContent));
            programs.display = createProgram(vs, compileShader(gl.FRAGMENT_SHADER, document.getElementById('display-fragment-shader').textContent));
        }

        function createFBOs() {
            simWidth = Math.floor(canvas.width / 4);
            simHeight = Math.floor(canvas.height / 4);
            dyeWidth = canvas.width;
            dyeHeight = canvas.height;

            const texType = gl.FLOAT;
            density = createDoubleFBO(dyeWidth, dyeHeight, gl.RGBA, texType, gl.LINEAR);
            velocity = createDoubleFBO(simWidth, simHeight, gl.RGBA, texType, gl.LINEAR);
            divergence = createFBO(simWidth, simHeight, gl.RGBA, texType, gl.NEAREST);
            pressure = createDoubleFBO(simWidth, simHeight, gl.RGBA, texType, gl.NEAREST);
        }
        
        function initPointers() {
            pointers.push({ id: -1, x: -1, y: -1, dx: 0, dy: 0, down: false, moved: false, color: [0, 0, 0] });

            canvas.addEventListener('mousedown', e => {
                pointers[0].down = true;
                pointers[0].color = [Math.random() + 0.2, Math.random() + 0.2, Math.random() + 0.2];
                updatePointerPosition(e);
            });
            canvas.addEventListener('mousemove', e => {
                if (pointers[0].down) {
                    updatePointerPosition(e);
                }
            });
            window.addEventListener('mouseup', () => {
                pointers[0].down = false;
            });

            canvas.addEventListener('touchstart', e => {
                e.preventDefault();
                const touches = e.targetTouches;
                pointers[0].down = true;
                pointers[0].color = [Math.random() + 0.2, Math.random() + 0.2, Math.random() + 0.2];
                updatePointerPosition(touches[0]);
            });
            canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if(pointers[0].down){
                    const touches = e.targetTouches;
                    updatePointerPosition(touches[0]);
                }
            }, { passive: false });
            window.addEventListener('touchend', () => {
                pointers[0].down = false;
            });
        }
        
        function updatePointerPosition(e) {
            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left) / rect.width;
            let y = 1.0 - (e.clientY - rect.top) / rect.height;
            
            let lastX = pointers[0].x;
            let lastY = pointers[0].y;
            
            pointers[0].dx = (x - lastX) * 10.0;
            pointers[0].dy = (y - lastY) * 10.0;
            pointers[0].x = x;
            pointers[0].y = y;
            pointers[0].moved = Math.abs(pointers[0].dx) > 0 || Math.abs(pointers[0].dy) > 0;
            
             if (pointers[0].moved) {
                splat(x, y, pointers[0].dx, pointers[0].dy, pointers[0].color);
            }
        }

        function update() {
            const now = Date.now();
            let dt = (now - lastTime) / 1000.0;
            dt = Math.min(dt, 0.0166); // clamp to 60fps
            lastTime = now;
            
            gl.viewport(0, 0, simWidth, simHeight);

            // Advect velocity
            gl.useProgram(programs.advect);
            gl.uniform2f(gl.getUniformLocation(programs.advect, 'u_texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_velocity'), velocity.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_source'), velocity.read.attach(1));
            gl.uniform1f(gl.getUniformLocation(programs.advect, 'u_dt'), dt);
            gl.uniform1f(gl.getUniformLocation(programs.advect, 'u_dissipation'), VELOCITY_DISSIPATION);
            blit(velocity.write.fbo);
            velocity.swap();
            
            // Advect density
            gl.viewport(0, 0, dyeWidth, dyeHeight);
            gl.uniform2f(gl.getUniformLocation(programs.advect, 'u_texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_velocity'), velocity.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(programs.advect, 'u_source'), density.read.attach(1));
            gl.uniform1f(gl.getUniformLocation(programs.advect, 'u_dissipation'), DENSITY_DISSIPATION);
            blit(density.write.fbo);
            density.swap();

            // Handle splats
            splatStack.forEach(s => applySplat(s));
            splatStack = [];
            
            // Compute divergence
            gl.viewport(0, 0, simWidth, simHeight);
            gl.useProgram(programs.divergence);
            gl.uniform2f(gl.getUniformLocation(programs.divergence, 'u_texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1i(gl.getUniformLocation(programs.divergence, 'u_velocity'), velocity.read.attach(0));
            blit(divergence.fbo);

            // Solve pressure
            gl.useProgram(programs.pressure);
            gl.uniform2f(gl.getUniformLocation(programs.pressure, 'u_texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1i(gl.getUniformLocation(programs.pressure, 'u_divergence'), divergence.attach(0));
            
            let p = gl.getUniformLocation(programs.pressure, 'u_pressure');
            for(let i = 0; i < PRESSURE_ITERATIONS; i++) {
                gl.uniform1i(p, pressure.read.attach(1));
                blit(pressure.write.fbo);
                pressure.swap();
            }

            // Subtract gradient
            gl.useProgram(programs.gradientSubtract);
            gl.uniform2f(gl.getUniformLocation(programs.gradientSubtract, 'u_texelSize'), 1.0 / simWidth, 1.0 / simHeight);
            gl.uniform1i(gl.getUniformLocation(programs.gradientSubtract, 'u_pressure'), pressure.read.attach(0));
            gl.uniform1i(gl.getUniformLocation(programs.gradientSubtract, 'u_velocity'), velocity.read.attach(1));
            blit(velocity.write.fbo);
            velocity.swap();

            // Render to screen
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(programs.display);
            gl.uniform1i(gl.getUniformLocation(programs.display, 'u_texture'), density.read.attach(0));
            blit(null);

            requestAnimationFrame(update);
        }
        
        function splat(x, y, dx, dy, color) {
            splatStack.push({x, y, dx, dy, color});
        }
        
        function applySplat(s) {
            // Splat velocity
            gl.viewport(0, 0, simWidth, simHeight);
            gl.useProgram(programs.splat);
            gl.uniform1i(gl.getUniformLocation(programs.splat, 'u_target'), velocity.read.attach(0));
            gl.uniform1f(gl.getUniformLocation(programs.splat, 'u_aspectRatio'), canvas.width / canvas.height);
            gl.uniform2f(gl.getUniformLocation(programs.splat, 'u_point'), s.x, s.y);
            gl.uniform3f(gl.getUniformLocation(programs.splat, 'u_color'), s.dx, s.dy, 0.0);
            gl.uniform1f(gl.getUniformLocation(programs.splat, 'u_radius'), SPLAT_RADIUS);
            blit(velocity.write.fbo);
            velocity.swap();
            
            // Splat density
            gl.viewport(0, 0, dyeWidth, dyeHeight);
            gl.uniform1i(gl.getUniformLocation(programs.splat, 'u_target'), density.read.attach(0));
            gl.uniform3f(gl.getUniformLocation(programs.splat, 'u_color'), s.color[0], s.color[1], s.color[2]);
            blit(density.write.fbo);
            density.swap();
        }

        function blit(destination) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // --- WebGL Helper Functions ---
        function createProgram(vertexShader, fragmentShader) {
            let program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(program));
            }
            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            return program;
        }

        function compileShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createFBO(w, h, internalFormat, format, type, param) {
            gl.activeTexture(gl.TEXTURE0);
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);

            let fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT);

            return {
                texture,
                fbo,
                width: w,
                height: h,
                attach(id) {
                    gl.activeTexture(gl.TEXTURE0 + id);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    return id;
                }
            };
        }

        function createDoubleFBO(w, h, internalFormat, format, type, param) {
            let fbo1 = createFBO(w, h, internalFormat, format, type, param);
            let fbo2 = createFBO(w, h, internalFormat, format, type, param);
            return {
                get read() { return fbo1; },
                get write() { return fbo2; },
                swap() {
                    let temp = fbo1;
                    fbo1 = fbo2;
                    fbo2 = temp;
                }
            };
        }
    </script>
</body>
</html>

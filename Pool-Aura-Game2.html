<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 2D Platformer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 16px;
            text-align: center;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls-overlay">
        Use Arrow Keys to Move & Spacebar to Jump
    </div>

    <script>
        // Main entry point
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('WebGL is not supported by your browser.');
                return;
            }

            // --- Game Configuration ---
            const world = {
                width: 1600,
                height: 900,
                gravity: 0.8
            };

            const player = {
                x: 100,
                y: 500,
                width: 40,
                height: 60,
                velocityX: 0,
                velocityY: 0,
                speed: 6,
                jumpForce: 18,
                onGround: false,
                color: [0.9, 0.3, 0.3] // Reddish color
            };

            const platforms = [
                // Ground
                { x: 0, y: 0, width: world.width, height: 40, color: [0.4, 0.5, 0.4] },
                // Floating platforms
                { x: 250, y: 150, width: 200, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 550, y: 300, width: 200, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 800, y: 450, width: 250, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 500, y: 600, width: 150, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 1200, y: 200, width: 300, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 1300, y: 550, width: 100, height: 30, color: [0.4, 0.5, 0.4] },
            ];

            const keys = {};

            // --- GLSL Shaders ---
            const vsSource = `
                attribute vec2 aVertexPosition;
                uniform mat4 uProjectionMatrix;
                uniform mat4 uModelViewMatrix;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 0.0, 1.0);
                }
            `;

            const fsSource = `
                precision mediump float;
                uniform vec3 uColor;
                void main() {
                    gl_FragColor = vec4(uColor, 1.0);
                }
            `;

            // --- WebGL Setup ---
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    color: gl.getUniformLocation(shaderProgram, 'uColor'),
                },
            };

            const rectBuffer = initBuffers(gl);

            // --- Event Listeners ---
            window.addEventListener('keydown', (e) => { keys[e.code] = true; });
            window.addEventListener('keyup', (e) => { keys[e.code] = false; });

            // --- Game Loop ---
            let lastTime = 0;
            function gameLoop(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000; // time in seconds
                lastTime = currentTime;

                update(deltaTime);
                drawScene(gl, programInfo, rectBuffer);

                requestAnimationFrame(gameLoop);
            }

            // --- Update Logic ---
            function update(deltaTime) {
                // Horizontal movement
                player.velocityX = 0;
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    player.velocityX = -player.speed;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    player.velocityX = player.speed;
                }

                // Jumping
                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.onGround) {
                    player.velocityY = player.jumpForce;
                    player.onGround = false;
                }

                // Apply physics
                player.x += player.velocityX;
                player.y += player.velocityY;

                // Apply gravity
                player.velocityY -= world.gravity;
                player.onGround = false;

                // Collision detection with platforms
                for (const platform of platforms) {
                    // Check for AABB collision
                    if (player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x &&
                        player.y < platform.y + platform.height &&
                        player.y + player.height > platform.y) {
                        
                        // Collision occurred, determine direction
                        const playerBottom = player.y;
                        const playerPrevBottom = player.y - player.velocityY;
                        const platformTop = platform.y + platform.height;

                        // Check if player was above the platform in the previous frame
                        if (playerPrevBottom >= platformTop) {
                            player.y = platformTop;
                            player.velocityY = 0;
                            player.onGround = true;
                        }
                    }
                }
                
                // World boundaries
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > world.width) player.x = world.width - player.width;

                // Respawn if falls off
                if (player.y < -100) {
                    player.x = 100;
                    player.y = 500;
                    player.velocityY = 0;
                }
            }

            // --- Drawing Logic ---
            function drawScene(gl, programInfo, buffer) {
                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.clearColor(0.1, 0.15, 0.2, 1.0); // Dark blue background
                gl.clear(gl.COLOR_BUFFER_BIT);

                const projectionMatrix = createOrthographic(0, world.width, 0, world.height, -1, 1);

                gl.useProgram(programInfo.program);
                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

                // Draw platforms
                for (const platform of platforms) {
                    drawRect(gl, programInfo, buffer, platform.x, platform.y, platform.width, platform.height, platform.color);
                }

                // Draw player
                drawRect(gl, programInfo, buffer, player.x, player.y, player.width, player.height, player.color);
            }

            function drawRect(gl, programInfo, buffer, x, y, width, height, color) {
                let modelViewMatrix = identity();
                modelViewMatrix = translate(modelViewMatrix, x, y, 0);
                modelViewMatrix = scale(modelViewMatrix, width, height, 1);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer.position);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
                gl.uniform3fv(programInfo.uniformLocations.color, color);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            // Start the game
            requestAnimationFrame(gameLoop);
        };


        // --- WebGL Helper Functions ---

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            // A simple unit square (1x1)
            const positions = [
                1.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                0.0, 0.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return { position: positionBuffer };
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // --- Matrix Math Functions ---

        function createOrthographic(left, right, bottom, top, near, far) {
            const out = new Float32Array(16);
            const lr = 1 / (left - right);
            const bt = 1 / (bottom - top);
            const nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
        }

        function identity() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function translate(matrix, x, y, z) {
            const out = new Float32Array(matrix);
            out[12] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
            out[13] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
            out[14] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
            return out;
        }

        function scale(matrix, x, y, z) {
            const out = new Float32Array(matrix);
            out[0] *= x;
            out[1] *= x;
            out[2] *= x;
            out[4] *= y;
            out[5] *= y;
            out[6] *= y;
            out[8] *= z;
            out[9] *= z;
            out[10] *= z;
            return out;
        }
    </script>
</body>
</html>

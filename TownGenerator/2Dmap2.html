<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Shape Generator</title>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; color: white; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .ui { position: absolute; top: 10px; left: 10px; pointer-events: none; text-shadow: 1px 1px 2px black; }
    </style>
</head>
<body>
    <div class="ui">
        <h1>Procedural Shape Map</h1>
        <p>Press <b>Space</b> to Regenerate</p>
        <small>Rectangles, Hexagons, Circles, and Wedges</small>
    </div>
    <canvas id="glCanvas"></canvas>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

if (!gl) alert('WebGL not supported');

// --- Shaders ---
const vsSource = `
    attribute vec2 a_position;
    attribute vec3 a_color;
    varying vec3 v_color;
    uniform vec2 u_resolution;
    void main() {
        vec2 zeroToOne = a_position / u_resolution;
        vec2 clipSpace = (zeroToOne * 2.0) - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_color = a_color;
    }
`;

const fsSource = `
    precision mediump float;
    varying vec3 v_color;
    void main() { gl_FragColor = vec4(v_color, 1.0); }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);

// --- Geometry Helpers ---
let geometryData = [];

function pushTri(x1, y1, x2, y2, x3, y3, color) {
    const [r, g, b] = color;
    geometryData.push(x1, y1, r, g, b, x2, y2, r, g, b, x3, y3, r, g, b);
}

function addRect(x, y, w, h, color) {
    pushTri(x, y, x + w, y, x, y + h, color);
    pushTri(x, y + h, x + w, y, x + w, y + h, color);
}

function addCircle(cx, cy, radius, segments, color) {
    for (let i = 0; i < segments; i++) {
        let theta1 = (i / segments) * Math.PI * 2;
        let theta2 = ((i + 1) / segments) * Math.PI * 2;
        pushTri(
            cx, cy, 
            cx + Math.cos(theta1) * radius, cy + Math.sin(theta1) * radius,
            cx + Math.cos(theta2) * radius, cy + Math.sin(theta2) * radius, 
            color
        );
    }
}

function addHexagon(cx, cy, size, color) {
    // A hexagon is just a 6-segment circle
    addCircle(cx, cy, size, 6, color);
}

function addWedge(cx, cy, radius, startAngle, endAngle, color) {
    const segments = 10;
    for (let i = 0; i < segments; i++) {
        let theta1 = startAngle + (i / segments) * (endAngle - startAngle);
        let theta2 = startAngle + ((i + 1) / segments) * (endAngle - startAngle);
        pushTri(cx, cy, cx + Math.cos(theta1) * radius, cy + Math.sin(theta1) * radius, cx + Math.cos(theta2) * radius, cy + Math.sin(theta2) * radius, color);
    }
}

// --- Map Generator ---
function generateMap() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    geometryData = [];

    // 1. Generate Ground (Rectangles)
    const floorY = canvas.height - 40;
    addRect(0, floorY, canvas.width, 40, [0.3, 0.2, 0.1]);

    // 2. Generate Random Shapes
    for (let i = 0; i < 40; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * (canvas.height - 100);
        const type = Math.floor(Math.random() * 4);
        const color = [Math.random(), Math.random(), Math.random()];

        switch(type) {
            case 0: // Rect
                addRect(x, y, 40, 10, color);
                break;
            case 1: // Hexagon (Platforms/Decor)
                addHexagon(x, y, 25, color);
                break;
            case 2: // Circle (Bouncy pads?)
                addCircle(x, y, 20, 24, color);
                break;
            case 3: // Wedge (Ramps)
                addWedge(x, y, 50, Math.PI, Math.PI * 1.5, color);
                break;
        }
    }
}

// --- Render ---
const positionBuffer = gl.createBuffer();

function render() {
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.12, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);
    gl.uniform2f(gl.getUniformLocation(program, "u_resolution"), canvas.width, canvas.height);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometryData), gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 5 * 4, 0);

    const colorLoc = gl.getAttribLocation(program, "a_color");
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 5 * 4, 2 * 4);

    gl.drawArrays(gl.TRIANGLES, 0, geometryData.length / 5);
}

window.addEventListener('resize', () => { generateMap(); render(); });
window.addEventListener('keydown', (e) => { if(e.code === 'Space') { generateMap(); render(); } });

generateMap();
render();
</script>
</body>
</html>

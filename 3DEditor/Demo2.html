<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 3D Modeler - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1e1e1e; color: #fff; }
        
        /* Sidebar UI */
        #sidebar {
            position: absolute; top: 0; left: 0; width: 280px; height: 100vh;
            background: #252526; border-right: 1px solid #3e3e42; padding: 20px; box-sizing: border-box;
            overflow-y: auto; z-index: 10;
        }
        
        h2 { margin-top: 0; font-size: 1.2rem; border-bottom: 1px solid #555; padding-bottom: 10px; }
        h3 { font-size: 0.9rem; color: #ccc; margin-top: 20px; text-transform: uppercase; letter-spacing: 1px;}
        
        .control-group { display: flex; align-items: center; margin-bottom: 10px; }
        .control-group label { width: 30px; font-weight: bold; color: #aaa; }
        .control-group input { 
            flex: 1; background: #3c3c3c; border: 1px solid #555; 
            color: white; padding: 5px; border-radius: 3px; 
        }
        
        button {
            width: 100%; padding: 10px; background: #007acc; color: white;
            border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-bottom: 10px;
            transition: background 0.2s;
        }
        button:hover { background: #0062a3; }
        button.active { background: #d7ba7d; color: #1e1e1e; }
        
        #canvas-container { margin-left: 280px; width: calc(100vw - 280px); height: 100vh; touch-action: none; }
        
        .hint { font-size: 0.8rem; color: #888; margin-top: 20px; line-height: 1.4; }

        /* --- New Mobile/Touch Controls --- */
        #mobile-tools {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 20;
            pointer-events: none; /* Let clicks pass through gaps */
        }

        .tool-btn {
            pointer-events: auto;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(30, 30, 30, 0.8);
            border: 2px solid #555;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        
        .tool-btn:active { background: #007acc; }
        .tool-btn.selected { background: #007acc; border-color: #fff; }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Mobile Layout Adjustment */
        @media (max-width: 768px) {
            #sidebar {
                top: auto; bottom: 0; left: 0;
                width: 100%; height: 35vh;
                border-right: none; border-top: 1px solid #3e3e42;
            }
            #canvas-container {
                margin-left: 0; width: 100%; height: 65vh;
            }
            #mobile-tools {
                bottom: 20px; /* Position inside the canvas area */
            }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="sidebar">
        <h2>3D Modeler</h2>
        
        <button id="btn-add-cube">Add Cube</button>
        <button id="btn-mode-toggle">Mode: Object</button>

        <h3>Position</h3>
        <div class="control-group"><label>X</label><input type="number" step="0.1" id="pos-x"></div>
        <div class="control-group"><label>Y</label><input type="number" step="0.1" id="pos-y"></div>
        <div class="control-group"><label>Z</label><input type="number" step="0.1" id="pos-z"></div>

        <h3>Rotation (Euler)</h3>
        <div class="control-group"><label>X</label><input type="number" step="1" id="rot-x"></div>
        <div class="control-group"><label>Y</label><input type="number" step="1" id="rot-y"></div>
        <div class="control-group"><label>Z</label><input type="number" step="1" id="rot-z"></div>

        <div class="hint">
            <strong>Controls:</strong><br>
            • 1 Finger: Rotate View<br>
            • 2 Fingers: Pan/Zoom<br>
            • Tap Object: Select
        </div>
    </div>

    <div id="canvas-container">
        <div id="mobile-tools">
            <button class="tool-btn selected" id="btn-tool-move" title="Move">✥</button>
            <button class="tool-btn" id="btn-tool-rotate" title="Rotate">↻</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, orbit, transformControl;
        let activeObject = null;
        let vertexHelpers = [];
        let isVertexMode = false;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // UI Elements
        const uiPos = { x: document.getElementById('pos-x'), y: document.getElementById('pos-y'), z: document.getElementById('pos-z') };
        const uiRot = { x: document.getElementById('rot-x'), y: document.getElementById('rot-y'), z: document.getElementById('rot-z') };
        const btnMode = document.getElementById('btn-mode-toggle');
        
        // Touch Tools
        const btnToolMove = document.getElementById('btn-tool-move');
        const btnToolRotate = document.getElementById('btn-tool-rotate');

        // --- Initialization ---
        function init() {
            const container = document.getElementById('canvas-container');

            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x555555, 0x444444);
            scene.add(gridHelper);

            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // Orbit Controls (Camera Movement)
            orbit = new OrbitControls(camera, renderer.domElement);
            orbit.enableDamping = true;

            // Transform Controls (Gizmo)
            transformControl = new TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', function (event) {
                orbit.enabled = !event.value; 
            });
            transformControl.addEventListener('change', () => {
                if (isVertexMode) updateGeometryFromVertex();
                updateUI();
            });
            scene.add(transformControl);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // Use pointerdown for both mouse and touch support
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('keydown', onKeyDown);
            
            setupUIListeners();
            
            // Start Loop
            animate();
        }

        // --- Application Logic ---

        function createCube() {
            if (activeObject) {
                scene.remove(activeObject);
                cleanupVertexHelpers();
            }

            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshStandardMaterial({ color: 0x007acc, roughness: 0.2, metalness: 0.1 });
            const cube = new THREE.Mesh(geometry, material);
            
            cube.position.y = 1;
            scene.add(cube);
            
            selectObject(cube);
        }

        function selectObject(object) {
            activeObject = object;
            
            if (!isVertexMode) {
                transformControl.attach(object);
                setTransformMode('translate');
            }
            updateUI();
        }

        function setTransformMode(mode) {
            if (!activeObject && !transformControl.object) return;
            
            // Logic to prevent rotating vertices
            if (isVertexMode && mode === 'rotate') return;

            transformControl.setMode(mode);
            
            // Visual feedback on buttons
            if (mode === 'translate') {
                btnToolMove.classList.add('selected');
                btnToolRotate.classList.remove('selected');
            } else {
                btnToolMove.classList.remove('selected');
                btnToolRotate.classList.add('selected');
            }
        }

        // --- Vertex Editing Logic ---

        function toggleMode() {
            isVertexMode = !isVertexMode;
            btnMode.innerText = isVertexMode ? "Mode: Vertex" : "Mode: Object";
            
            if (isVertexMode) {
                btnMode.classList.add('active');
                // Disable rotate button visually
                btnToolRotate.disabled = true;
                
                transformControl.detach();
                createVertexHelpers();
                setTransformMode('translate');
            } else {
                btnMode.classList.remove('active');
                btnToolRotate.disabled = false;
                
                cleanupVertexHelpers();
                if (activeObject) {
                    transformControl.attach(activeObject);
                    setTransformMode('translate');
                }
            }
        }

        function createVertexHelpers() {
            if (!activeObject) return;
            
            const positionAttribute = activeObject.geometry.attributes.position;
            const vertexCount = positionAttribute.count;
            
            const uniquePositions = {};
            const tolerance = 0.001;

            for (let i = 0; i < vertexCount; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = positionAttribute.getZ(i);
                
                const key = `${x.toFixed(3)}_${y.toFixed(3)}_${z.toFixed(3)}`;
                
                if (!uniquePositions[key]) {
                    uniquePositions[key] = {
                        indices: [],
                        x: x, y: y, z: z
                    };
                }
                uniquePositions[key].indices.push(i);
            }

            Object.values(uniquePositions).forEach(data => {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const helper = new THREE.Mesh(geometry, material);
                
                helper.position.set(data.x, data.y, data.z);
                helper.userData = { vertexIndices: data.indices };
                
                activeObject.add(helper);
                vertexHelpers.push(helper);
            });
        }

        function cleanupVertexHelpers() {
            transformControl.detach();
            vertexHelpers.forEach(helper => {
                activeObject.remove(helper);
                helper.geometry.dispose();
                helper.material.dispose();
            });
            vertexHelpers = [];
        }

        function updateGeometryFromVertex() {
            if (!isVertexMode || !transformControl.object) return;

            const helper = transformControl.object;
            const positionAttribute = activeObject.geometry.attributes.position;
            
            helper.userData.vertexIndices.forEach(index => {
                positionAttribute.setXYZ(index, helper.position.x, helper.position.y, helper.position.z);
            });

            positionAttribute.needsUpdate = true;
            activeObject.geometry.computeVertexNormals();
        }

        // --- Input & Selection ---

        function onPointerDown(event) {
            // Only select if not clicking on gizmo (Three.js TransformControl handles its own raycasting usually, 
            // but we want to select objects when clicking empty space or new objects)
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            if (isVertexMode) {
                const intersects = raycaster.intersectObjects(vertexHelpers);
                if (intersects.length > 0) {
                    transformControl.attach(intersects[0].object);
                    setTransformMode('translate');
                } else {
                    // Don't detach immediately on click miss to allow orbit, 
                    // but could detach if explicitly clicked empty space.
                }
            } else {
                if (activeObject) {
                    // Selection logic for multiple objects would go here
                }
            }
        }

        // --- UI Updates ---

        function updateUI() {
            if (!activeObject) return;

            if (document.activeElement.tagName !== 'INPUT') {
                uiPos.x.value = activeObject.position.x.toFixed(2);
                uiPos.y.value = activeObject.position.y.toFixed(2);
                uiPos.z.value = activeObject.position.z.toFixed(2);

                uiRot.x.value = THREE.MathUtils.radToDeg(activeObject.rotation.x).toFixed(0);
                uiRot.y.value = THREE.MathUtils.radToDeg(activeObject.rotation.y).toFixed(0);
                uiRot.z.value = THREE.MathUtils.radToDeg(activeObject.rotation.z).toFixed(0);
            }
        }

        function setupUIListeners() {
            document.getElementById('btn-add-cube').addEventListener('click', createCube);
            btnMode.addEventListener('click', toggleMode);

            // Mobile Tool Buttons
            btnToolMove.addEventListener('click', () => setTransformMode('translate'));
            btnToolRotate.addEventListener('click', () => setTransformMode('rotate'));

            const updateObj = () => {
                if (!activeObject) return;
                
                activeObject.position.set(
                    parseFloat(uiPos.x.value),
                    parseFloat(uiPos.y.value),
                    parseFloat(uiPos.z.value)
                );
                
                activeObject.rotation.set(
                    THREE.MathUtils.degToRad(parseFloat(uiRot.x.value)),
                    THREE.MathUtils.degToRad(parseFloat(uiRot.y.value)),
                    THREE.MathUtils.degToRad(parseFloat(uiRot.z.value))
                );
            };

            [...Object.values(uiPos), ...Object.values(uiRot)].forEach(input => {
                input.addEventListener('input', updateObj);
            });
        }

        function onKeyDown(event) {
            switch (event.key.toLowerCase()) {
                case 't': setTransformMode('translate'); break;
                case 'r': if(!isVertexMode) setTransformMode('rotate'); break;
            }
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>

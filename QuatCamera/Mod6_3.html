<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Z-Up Quaternion Camera</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111;
            font-family: sans-serif;
        }
        #webgl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            padding: 0 20px;
            box-sizing: border-box;
            max-width: 400px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
            user-select: none;
        }
        .btn {
            padding: 15px 10px;
            font-size: 1.5em;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            touch-action: none; /* Prevents double tap zoom */
        }
        .btn:active {
            background-color: rgba(255, 255, 255, 0.5);
        }
        #up-btn    { grid-column: 2; grid-row: 1; }
        #left-btn  { grid-column: 1; grid-row: 2; }
        #down-btn  { grid-column: 2; grid-row: 2; }
        #right-btn { grid-column: 3; grid-row: 2; }
        #forward-btn    { grid-column: 1; grid-row: 1; }
        #backward-btn  { grid-column: 3; grid-row: 1; }
      
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>
    <div id="controls">
        <div id="up-btn" class="btn">A</div>
        <div id="left-btn" class="btn">◄</div>
        <div id="down-btn" class="btn">Z</div>
        <div id="right-btn" class="btn">►</div>
                <div id="forward-btn" class="btn">▲</div>
        <div id="backward-btn" class="btn">▼</div>
    </div>

    <script>
    // --- MAIN SCRIPT ---

    // Shaders
    const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec4 aVertexColor;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying lowp vec4 vColor;
        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
            vColor = aVertexColor;
        }
    `;

    const fsSource = `
        varying lowp vec4 vColor;
        void main(void) {
            gl_FragColor = vColor;
        }
    `;

    // --- MATH LIBRARY (No external libs) ---
    // Note: GL matrices are column-major. These functions create arrays
    // that are compatible with WebGL's `uniformMatrix4fv` function.

    const vec3 = {
        create: (x = 0, y = 0, z = 0) => new Float32Array([x, y, z]),
        add: (out, a, b) => { out[0] = a[0] + b[0]; out[1] = a[1] + b[1]; out[2] = a[2] + b[2]; return out; },
        scale: (out, a, b) => { out[0] = a[0] * b; out[1] = a[1] * b; out[2] = a[2] * b; return out; },
        cross: (out, a, b) => {
            const ax = a[0], ay = a[1], az = a[2];
            const bx = b[0], by = b[1], bz = b[2];
            out[0] = ay * bz - az * by;
            out[1] = az * bx - ax * bz;
            out[2] = ax * by - ay * bx;
            return out;
        },
        normalize: (out, a) => {
            let len = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
            if (len > 0) {
                len = 1 / Math.sqrt(len);
            }
            out[0] = a[0] * len; out[1] = a[1] * len; out[2] = a[2] * len;
            return out;
        },
        transformQuat: (out, a, q) => {
            let qx = q[0], qy = q[1], qz = q[2], qw = q[3];
            let x = a[0], y = a[1], z = a[2];
            let uvx = qy * z - qz * y;
            let uvy = qz * x - qx * z;
            let uvz = qx * y - qy * x;
            let uuvx = qy * uvz - qz * uvy;
            let uuvy = qz * uvx - qx * uvz;
            let uuvz = qx * uvy - qy * uvx;
            uvx *= 2 * qw; uvy *= 2 * qw; uvz *= 2 * qw;
            uuvx *= 2; uuvy *= 2; uuvz *= 2;
            out[0] = x + uvx + uuvx;
            out[1] = y + uvy + uuvy;
            out[2] = z + uvz + uuvz;
            return out;
        }
    };

    const quat = {
        create: () => new Float32Array([0, 0, 0, 1]),
        setAxisAngle: (out, axis, rad) => {
            rad = rad * 0.5;
            let s = Math.sin(rad);
            out[0] = s * axis[0]; out[1] = s * axis[1]; out[2] = s * axis[2];
            out[3] = Math.cos(rad);
            return out;
        },
        multiply: (out, a, b) => {
            let ax = a[0], ay = a[1], az = a[2], aw = a[3];
            let bx = b[0], by = b[1], bz = b[2], bw = b[3];
            out[0] = ax * bw + aw * bx + ay * bz - az * by;
            out[1] = ay * bw + aw * by + az * bx - ax * bz;
            out[2] = az * bw + aw * bz + ax * by - ay * bx;
            out[3] = aw * bw - ax * bx - ay * by - az * bz;
            return out;
        },
        normalize: (out, a) => {
            let len = a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3];
            if (len > 0) {
                len = 1 / Math.sqrt(len);
            }
            out[0] = a[0] * len; out[1] = a[1] * len; out[2] = a[2] * len; out[3] = a[3] * len;
            return out;
        }
    };

    const mat4 = {
        create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
        perspective: (out, fovy, aspect, near, far) => {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[11] = -1; out[15] = 0;
            if (far != null && far !== Infinity) {
                const nf = 1 / (near - far);
                out[10] = (far + near) * nf;
                out[14] = 2 * far * near * nf;
            } else {
                out[10] = -1;
                out[14] = -2 * near;
            }
            return out;
        },
        fromQuat: (out, q) => {
            let x = q[0], y = q[1], z = q[2], w = q[3];
            let x2 = x + x, y2 = y + y, z2 = z + z;
            let xx = x * x2, xy = x * y2, xz = x * z2;
            let yy = y * y2, yz = y * z2, zz = z * z2;
            let wx = w * x2, wy = w * y2, wz = w * z2;
            out[0] = 1 - (yy + zz); out[1] = xy + wz; out[2] = xz - wy; out[3] = 0;
            out[4] = xy - wz; out[5] = 1 - (xx + zz); out[6] = yz + wx; out[7] = 0;
            out[8] = xz + wy; out[9] = yz - wx; out[10] = 1 - (xx + yy); out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            return out;
        },
        translate: (out, a, v) => {
            let x = v[0], y = v[1], z = v[2];
            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                // Copy `a` to `out` and then apply translation
                out.set(a);
                out[12] = a[12] + a[0] * x + a[4] * y + a[8] * z;
                out[13] = a[13] + a[1] * x + a[5] * y + a[9] * z;
                out[14] = a[14] + a[2] * x + a[6] * y + a[10] * z;
                out[15] = a[15] + a[3] * x + a[7] * y + a[11] * z;
            }
            return out;
        },
        multiply: (out, a, b) => {
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        }
    };


    // --- APPLICATION CODE ---

    const canvas = document.querySelector('#webgl-canvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
        alert('Unable to initialize WebGL. Your browser may not support it.');
    }

    // Camera state
    const camera = {
        position: vec3.create(-5, -5, 4),
        orientation: quat.create(),
     //   pitch: -0.5, // vertical angle
         pitch: 0.0, // vertical angle
        yaw: 0.0,   // horizontal angle
        moveSpeed: 5.0,
        rotateSpeed: 0.005
    };

    // Input state
    const inputState = {
        mouse: {
            isDown: false,
            lastX: 0,
            lastY: 0,
        },
        touch: {
            identifier: null,
            lastX: 0,
            lastY: 0,
        },
        keys: {}
    };

    // World constants
    const WORLD_UP = vec3.create(0, 0, 1); // Z is up!
    const WORLD_FORWARD = vec3.create(0, 1, 0);
    const WORLD_RIGHT = vec3.create(1, 0, 0);

    let shaderProgram, programInfo, buffers;
    let lastTime = 0;

    function main() {
        shaderProgram = initShaderProgram(gl, vsSource, fsSource);
        programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            },
        };

        buffers = initBuffers(gl);
        setupInputListeners();
        updateCameraOrientation(); // Initial orientation

        requestAnimationFrame(gameLoop);
    }

    function gameLoop(currentTime) {
        currentTime *= 0.001; // convert to seconds
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        update(deltaTime);
        drawScene(gl, programInfo, buffers);

        requestAnimationFrame(gameLoop);
    }

    function update(deltaTime) {
        const moveAmount = camera.moveSpeed * deltaTime;

        // Calculate camera direction vectors from orientation
        const forwardDir = vec3.create();
        vec3.transformQuat(forwardDir, WORLD_FORWARD, camera.orientation);

        const rightDir = vec3.create();
        vec3.transformQuat(rightDir, WORLD_RIGHT, camera.orientation);
 const upDir = vec3.create();
      vec3.transformQuat( upDir, WORLD_UP, camera.orientation);
        // --- Handle Movement ---
        if (inputState.keys['forward']) { // Move Forward
            const move = vec3.scale(vec3.create(), forwardDir, moveAmount);
            vec3.add(camera.position, camera.position, move);
        }
        if (inputState.keys['backward']) { // Move Backward
            const move = vec3.scale(vec3.create(), forwardDir, -moveAmount);
            vec3.add(camera.position, camera.position, move);
        }
        if (inputState.keys['left']) { // Strafe Left
            const move = vec3.scale(vec3.create(), rightDir, -moveAmount);
            vec3.add(camera.position, camera.position, move);
        }
        if (inputState.keys['right']) { // Strafe Right
            const move = vec3.scale(vec3.create(), rightDir, moveAmount);
            vec3.add(camera.position, camera.position, move);
        }

      if (inputState.keys['up']) { // Move Forward
            const move = vec3.scale(vec3.create(), upDir, moveAmount);
            vec3.add(camera.position, camera.position, move);
        }
        if (inputState.keys['down']) { // Move Backward
            const move = vec3.scale(vec3.create(), upDir, -moveAmount);
            vec3.add(camera.position, camera.position, move);
        }
    }

    function updateCameraOrientation() {
        // Clamp pitch to prevent flipping
      //  const maxPitch = Math.PI / 2 - 0.01 ; 
      // Z axis orientation but what if we remove clamp completely?
        const maxPitch = Math.PI / 2 - 0.01 + Math.PI;
        camera.pitch = Math.max(-maxPitch, Math.min(maxPitch, camera.pitch));

        const yawQuat = quat.create();
        quat.setAxisAngle(yawQuat, WORLD_UP, camera.yaw); // Yaw around world Z

        const pitchQuat = quat.create();
        quat.setAxisAngle(pitchQuat, WORLD_RIGHT, camera.pitch); // Pitch around world X

        // Combine rotations: yaw first, then pitch in the new coordinate system
        quat.multiply(camera.orientation, yawQuat, pitchQuat);
        quat.normalize(camera.orientation, camera.orientation);
    }

    function setupInputListeners() {
        // --- Rotation (Mouse/Touch) ---
        const handleMove = (x, y) => {
            const dx = x - inputState.mouse.lastX;
            const dy = y - inputState.mouse.lastY;

            camera.yaw -= dx * camera.rotateSpeed;
            camera.pitch -= dy * camera.rotateSpeed;

            updateCameraOrientation();

            inputState.mouse.lastX = x;
            inputState.mouse.lastY = y;
        };

        // Mouse
        canvas.addEventListener('mousedown', (e) => {
            inputState.mouse.isDown = true;
            inputState.mouse.lastX = e.clientX;
            inputState.mouse.lastY = e.clientY;
        });
        canvas.addEventListener('mouseup', () => { inputState.mouse.isDown = false; });
        canvas.addEventListener('mouseleave', () => { inputState.mouse.isDown = false; });
        canvas.addEventListener('mousemove', (e) => {
            if (inputState.mouse.isDown) handleMove(e.clientX, e.clientY);
        });

        // Touch
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (inputState.touch.identifier === null) {
                const touch = e.changedTouches[0];
                 // Only handle touches in the top 60% of the screen
                if (touch.clientY < canvas.height * 0.6) {
                    inputState.touch.identifier = touch.identifier;
                    inputState.mouse.lastX = touch.clientX;
                    inputState.mouse.lastY = touch.clientY;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === inputState.touch.identifier) {
                    inputState.touch.identifier = null;
                    return;
                }
            }
        });
        canvas.addEventListener('touchcancel', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === inputState.touch.identifier) {
                    inputState.touch.identifier = null;
                    return;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (touch.identifier === inputState.touch.identifier) {
                    handleMove(touch.clientX, touch.clientY);
                    return;
                }
            }
        }, { passive: false });


        // --- Movement Buttons ---
        // *** MODIFICATION START ***
        // Renamed keys for clarity: 'up' is now 'forward', 'down' is 'backward'
        const buttons = [
            { id: 'up-btn', key: 'forward' },
            { id: 'down-btn', key: 'backward' },
            { id: 'left-btn', key: 'left' },
            { id: 'right-btn', key: 'right' },
            { id: 'forward-btn', key: 'up' },
            { id: 'backward-btn', key: 'down' }
        ];
        // *** MODIFICATION END ***

        buttons.forEach(b => {
            const element = document.getElementById(b.id);
            const startHandler = (e) => { e.preventDefault(); inputState.keys[b.key] = true; };
            const endHandler = (e) => { e.preventDefault(); inputState.keys[b.key] = false; };

            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mouseup', endHandler);
            element.addEventListener('mouseleave', endHandler);
            element.addEventListener('touchstart', startHandler, { passive: false });
            element.addEventListener('touchend', endHandler, { passive: false });
        });
    }

    function drawScene(gl, programInfo, buffers) {
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clearColor(0.1, 0.12, 0.18, 1.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Resize canvas to display size
        const displayWidth = gl.canvas.clientWidth;
        const displayHeight = gl.canvas.clientHeight;
        if (gl.canvas.width !== displayWidth || gl.canvas.height !== displayHeight) {
            gl.canvas.width = displayWidth;
            gl.canvas.height = displayHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }

        // --- Set up camera matrices ---
        const fieldOfView = 45 * Math.PI / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        // Create view matrix from camera position and orientation
        const viewMatrix = mat4.create();
        const rotationMatrix = mat4.fromQuat(mat4.create(), camera.orientation);
        const invCameraPos = vec3.scale(vec3.create(), camera.position, -1);
        const translationMatrix = mat4.translate(mat4.create(), mat4.create(), invCameraPos);
        
        // View = Inverse(Translate * Rotate) = Inverse(Rotate) * Inverse(Translate)
        // Inverse of rotation matrix is its transpose. fromQuat already gives an orthonormal matrix.
        // But it's easier to think of it as moving the world, not the camera.
        // So: first rotate the world by the inverse camera rotation, then translate it.
        const invOrientation = quat.create();
        invOrientation[0] = -camera.orientation[0];
        invOrientation[1] = -camera.orientation[1];
        invOrientation[2] = -camera.orientation[2];
        invOrientation[3] = camera.orientation[3];

        const invRotationMatrix = mat4.fromQuat(mat4.create(), invOrientation);
        mat4.multiply(viewMatrix, invRotationMatrix, translationMatrix);

        // --- Draw Grid Floor ---
        const modelViewMatrix = mat4.create(); // Identity matrix for grid, already at origin.
        mat4.multiply(modelViewMatrix, viewMatrix, modelViewMatrix); // Apply camera
        
        gl.useProgram(programInfo.program);
        gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
        
        // Bind grid buffers and draw
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.gridPosition);
        gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.gridColor);
        gl.vertexAttribPointer(programInfo.attribLocations.vertexColor, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);

        gl.drawArrays(gl.LINES, 0, buffers.gridVertexCount);
    }

    // --- WebGL Helper Functions ---

    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function initBuffers(gl) {
        // Create a grid for the floor
        const size = 50;
        const divisions = 50;
        const gridPositions = [];
        const gridColors = [];
        const gridColor = [0.3, 0.3, 0.3, 1.0];

        for (let i = -divisions; i <= divisions; i++) {
            const pos = (i / divisions) * size;
            // Lines along X axis
            gridPositions.push(-size, pos, 0);
            gridPositions.push(size, pos, 0);
            // Lines along Y axis
            gridPositions.push(pos, -size, 0);
            gridPositions.push(pos, size, 0);
            gridColors.push(...gridColor, ...gridColor, ...gridColor, ...gridColor);
        }

        // Add coordinate axes
        // X-axis (Red)
        gridPositions.push(0,0,0, 10,0,0);
        gridColors.push(1,0,0,1, 1,0,0,1);
        // Y-axis (Green)
        gridPositions.push(0,0,0, 0,10,0);
        gridColors.push(0,1,0,1, 0,1,0,1);
        // Z-axis (Blue - UP)
        gridPositions.push(0,0,0.01, 0,0,10);
        gridColors.push(0,0,1,1, 0,0,1,1);
        

        const gridPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gridPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridPositions), gl.STATIC_DRAW);

        const gridColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gridColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridColors), gl.STATIC_DRAW);

        return {
            gridPosition: gridPositionBuffer,
            gridColor: gridColorBuffer,
            gridVertexCount: gridPositions.length / 3,
        };
    }

    // --- Start the application ---
    main();

    </script>
</body>
</html>

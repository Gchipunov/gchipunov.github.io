<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Water Explosion - https://gemini.google.com/app/d352c299ee3a19f2</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .ui {
            position: absolute; top: 20px; left: 20px;
            color: white; font-family: sans-serif; pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="ui">Click anywhere to explode</div>
    <canvas id="canvas"></canvas>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    alert('WebGL not supported');
}

// --- SHADERS ---
const vsSource = `
    attribute vec3 aVelocity;
    attribute float aStartTime;
    
    uniform float uTime;
    uniform vec3 uOrigin;
    uniform float uGravity;

    void main() {
        float t = uTime - aStartTime;
        
        // Physics: Position = p0 + v0*t + 0.5*a*t^2
        if (t > 0.0) {
            vec3 pos = uOrigin + (aVelocity * t);
            pos.y -= 0.5 * uGravity * t * t; 
            
            gl_Position = vec4(pos, 1.0);
            // Shrink over time
            gl_PointSize = max(0.0, 15.0 - (t * 5.0));
        } else {
            gl_Position = vec4(2.0, 2.0, 2.0, 1.0); // Hide off-screen
            gl_PointSize = 0.0;
        }
    }
`;

const fsSource = `
    precision mediump float;
    void main() {
        // Create a circular droplet shape
        float dist = distance(gl_PointCoord, vec2(0.5));
        if (dist > 0.5) discard;
        
        // Water blue with slight transparency
        gl_FragColor = vec4(0.2, 0.5, 1.0, 0.8 * (1.0 - dist * 2.0));
    }
`;

// --- UTILS ---
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

// --- PARTICLE DATA ---
const PARTICLE_COUNT = 1000;
const velocities = new Float32Array(PARTICLE_COUNT * 3);
const startTimes = new Float32Array(PARTICLE_COUNT);

// Buffers
const vBuffer = gl.createBuffer();
const tBuffer = gl.createBuffer();

const uTimeLoc = gl.getUniformLocation(program, 'uTime');
const uOriginLoc = gl.getUniformLocation(program, 'uOrigin');
const uGravityLoc = gl.getUniformLocation(program, 'uGravity');

function triggerExplosion(x, y) {
    // Convert screen space to clip space (-1 to 1)
    const nx = (x / window.innerWidth) * 2 - 1;
    const ny = -((y / window.innerHeight) * 2 - 1);
    
    gl.uniform3f(uOriginLoc, nx, ny, 0);
    
    const currentTime = performance.now() / 1000;
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        // Random directional explosion
        const angle = Math.random() * Math.PI * 2;
        const force = Math.random() * 1.5;
        velocities[i * 3] = Math.cos(angle) * force * 0.5; // vx
        velocities[i * 3 + 1] = Math.sin(angle) * force;    // vy
        velocities[i * 3 + 2] = 0;                          // vz
        
        startTimes[i] = currentTime + (Math.random() * 0.1); // Staggered start
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.DYNAMIC_DRAW);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, tBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, startTimes, gl.DYNAMIC_DRAW);
}

// Set up Attributes
const vLoc = gl.getAttribLocation(program, 'aVelocity');
gl.enableVertexAttribArray(vLoc);
gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
gl.vertexAttribPointer(vLoc, 3, gl.FLOAT, false, 0, 0);

const tLoc = gl.getAttribLocation(program, 'aStartTime');
gl.enableVertexAttribArray(tLoc);
gl.bindBuffer(gl.ARRAY_BUFFER, tBuffer);
gl.vertexAttribPointer(tLoc, 1, gl.FLOAT, false, 0, 0);

gl.uniform1f(uGravityLoc, 2.5);

// --- RENDER LOOP ---
function render(now) {
    now *= 0.001; // convert to seconds
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

    gl.uniform1f(uTimeLoc, now);
    gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);
    
    requestAnimationFrame(render);
}

window.addEventListener('mousedown', e => triggerExplosion(e.clientX, e.clientY));
requestAnimationFrame(render);

// Initial explosion
triggerExplosion(window.innerWidth / 2, window.innerHeight / 2);
</script>
</body>
</html>

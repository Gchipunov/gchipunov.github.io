<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Skater: Coyote Time Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }
        #debug {
            position: absolute;
            top: 20px; right: 20px;
            width: 280px;
            background: rgba(0, 20, 0, 0.85);
            color: #0f0;
            border: 1px solid #0f0;
            padding: 10px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 10px rgba(0,255,0,0.2);
            pointer-events: none;
        }
        .d-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
        .d-val { font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <h1>WebGL Skater: Coyote Time</h1>
    <p>Controls: Arrow Keys | Space</p>
    <p style="color: #aaa; font-size: 0.8em;">Try walking off a ledge and jumping late!</p>
</div>

<div id="debug">
    <h3>Physics Stats</h3>
    <div class="d-row"><span>Vel:</span> <span id="d-vel" class="d-val">0.0</span></div>
    <div class="d-row"><span>Trauma:</span> <span id="d-trauma" class="d-val">0.0</span></div>
    <div class="d-row"><span>Status:</span> <span id="d-state" class="d-val">Ground</span></div>
    <div class="d-row"><span style="color:yellow">Coyote:</span> <span id="d-coyote" class="d-val">Inactive</span></div>
</div>

<canvas id="gameCanvas"></canvas>

<script id="vertex-shader-2d" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    uniform float u_rotation;
    void main() {
        vec2 rotatedPosition = vec2(
             a_position.x * cos(u_rotation) - a_position.y * sin(u_rotation),
             a_position.x * sin(u_rotation) + a_position.y * cos(u_rotation)
        );
        vec2 scaledPosition = rotatedPosition * u_scale;
        vec2 position = scaledPosition + u_translation;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace, 0, 1);
    }
</script>

<script id="fragment-shader-2d" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
/** WEBGL SETUP */
const canvas = document.getElementById("gameCanvas");
const gl = canvas.getContext("webgl");
if (!gl) { alert("WebGL not supported"); }

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById("vertex-shader-2d").text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fragment-shader-2d").text));
gl.linkProgram(program);

const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");
const translationLocation = gl.getUniformLocation(program, "u_translation");
const scaleLocation = gl.getUniformLocation(program, "u_scale");
const rotationLocation = gl.getUniformLocation(program, "u_rotation");

const rectBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.5,-0.5, 0.5,-0.5, -0.5,0.5, -0.5,0.5, 0.5,-0.5, 0.5,0.5]), gl.STATIC_DRAW);

const triangleBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.5,-0.5, 0.5,-0.5, 0.5,0.5]), gl.STATIC_DRAW);

/** CONSTANTS */
const GRAVITY = 0.6;
const FRICTION = 0.96;
const INPUT_ACCEL = 0.8; 
const JUMP_FORCE = 14;
const MAX_SPEED = 25;
const LEVEL_LENGTH = 20000;
const groundY = 50;
const COYOTE_MS = 150; // 150ms Grace Period

let cameraX = 0;
const keys = { left: false, right: false, space: false };

/** PLAYER STATE */
const player = {
    matrixPos: { x: 100, y: 300 },
    matrixVel: { x: 0, y: 0 },
    matrixAcc: { x: 0, y: 0 },
    width: 40, height: 10,
    rotation: 0, onGround: false,
    
    // Coyote State
    lastGroundTime: 0, 

    // Animation State
    trauma: 0, 
    lean: 0,   
    crouch: 0  
};

/** LEVEL GENERATION */
const obstacles = [];
function createLevel() {
    const colWedge = [0.3, 0.3, 0.8, 1];
    const colPlat = [0.8, 0.3, 0.3, 1];
    for (let i = 0; i < 15; i++) {
        let px = 600 + (i * 1200) + Math.random() * 500;
        let pw = 200 + Math.random() * 300; 
        let ph = 140 + Math.random() * 150; 
        obstacles.push({ type: 'platform', x: px, w: pw, h: ph, color: colPlat });
    }
    for (let i = 0; i < 5; i++) {
        let wx = 800 + (i * 3500) + Math.random() * 500;
        let ww = 300 + Math.random() * 200;
        let wh = 150 + Math.random() * 200; 
        obstacles.push({ type: 'wedge', x: wx, w: ww, h: wh, color: colWedge });
    }
    obstacles.sort((a, b) => a.x - b.x);
}
createLevel();

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'Space') {
        // --- COYOTE JUMP LOGIC ---
        // Jump if on ground OR if we left the ground very recently
        let canCoyoteJump = (Date.now() - player.lastGroundTime) < COYOTE_MS;

        if (!keys.space && (player.onGround || canCoyoteJump)) {
            player.matrixVel.y = JUMP_FORCE;
            player.onGround = false;
            player.lastGroundTime = 0; // Reset so we can't double jump
        }
        keys.space = true;
    }
});
window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'Space') keys.space = false;
});

function getTerrainInfo(px, py) {
    let height = groundY;
    let angle = 0;
    for (let obs of obstacles) {
        if (obs.x > px + 1000) break; 
        let endX = obs.x + obs.w;
        if (px > obs.x && px <= endX) {
            if (obs.type === 'wedge') {
                let ratio = (px - obs.x) / obs.w;
                height = Math.max(height, groundY + (ratio * obs.h));
                angle = Math.atan2(obs.h, obs.w);
            } 
            else if (obs.type === 'platform') {
                let platTop = groundY + obs.h;
                let feetY = py - (player.height / 2);
                let tolerance = 15; 
                if (feetY >= platTop - tolerance) {
                    height = Math.max(height, platTop);
                    angle = 0;
                }
            }
        }
    }
    return { height, angle };
}

function update() {
    player.matrixAcc.x = 0;
    player.matrixAcc.y = -GRAVITY;

    if (keys.left) player.matrixAcc.x -= INPUT_ACCEL;
    if (keys.right) player.matrixAcc.x += INPUT_ACCEL;

    let targetLean = 0;
    if (keys.left) targetLean = 1; 
    if (keys.right) targetLean = -1; 
    player.lean += (targetLean - player.lean) * 0.1;

    let prevVelX = player.matrixVel.x;
    let prevVelY = player.matrixVel.y;

    player.matrixVel.x += player.matrixAcc.x;
    player.matrixVel.y += player.matrixAcc.y;
    player.matrixVel.x *= FRICTION;

    if(player.matrixVel.x > MAX_SPEED) player.matrixVel.x = MAX_SPEED;
    if(player.matrixVel.x < -MAX_SPEED) player.matrixVel.x = -MAX_SPEED;

    let prevX = player.matrixPos.x;
    let prevY = player.matrixPos.y;
    
    player.matrixPos.x += player.matrixVel.x;
    player.matrixPos.y += player.matrixVel.y;

    let terrain = getTerrainInfo(player.matrixPos.x, player.matrixPos.y);
    let targetFloorY = terrain.height;
    let targetAngle = terrain.angle;

    // Wall Detection
    const STEP_HEIGHT = 20; 
    let prevFeetY = prevY - (player.height / 2);
    if (targetFloorY > prevFeetY + STEP_HEIGHT) {
        let impact = Math.abs(prevVelX);
        if (impact > 5) player.trauma += impact * 2;
        player.matrixPos.x = prevX;
        player.matrixVel.x = 0;
        let corrected = getTerrainInfo(player.matrixPos.x, player.matrixPos.y);
        targetFloorY = corrected.height;
        targetAngle = corrected.angle;
    }

    // Floor Detection & Coyote Update
    let feetY = player.matrixPos.y - (player.height / 2);
    
    if (feetY < targetFloorY) {
        // We landed
        let verticalImpact = Math.abs(prevVelY);
        if (verticalImpact > 10) {
            player.trauma += verticalImpact; 
            player.crouch = Math.min(1.0, verticalImpact / 20); 
        }

        player.matrixPos.y = targetFloorY + (player.height / 2);
        player.matrixVel.y = 0;
        player.onGround = true;
        player.rotation = targetAngle;
        
        // --- COYOTE UPDATE ---
        // While on ground, constantly refresh the timer
        player.lastGroundTime = Date.now();

    } else {
        // In Air
        player.onGround = false;
        player.rotation *= 0.95; 
        player.crouch *= 0.8; 
    }

    player.trauma *= 0.95; 
    if(player.trauma < 0.1) player.trauma = 0;
    player.crouch *= 0.9;

    if (player.matrixPos.x < 0) { player.matrixPos.x = 0; player.matrixVel.x = 0; }
    if (player.matrixPos.x > LEVEL_LENGTH) { player.matrixPos.x = LEVEL_LENGTH; player.matrixVel.x = 0; }

    let targetCamX = player.matrixPos.x - canvas.width / 3;
    if (targetCamX < 0) targetCamX = 0;
    if (targetCamX > LEVEL_LENGTH - canvas.width) targetCamX = LEVEL_LENGTH - canvas.width;
    cameraX += (targetCamX - cameraX) * 0.1;

    // Debug
    document.getElementById('d-vel').innerText = player.matrixVel.x.toFixed(1);
    document.getElementById('d-trauma').innerText = player.trauma.toFixed(1);
    document.getElementById('d-state').innerText = player.onGround ? "GROUND" : "AIR";
    
    // Debug Coyote
    let coyoteDiff = Date.now() - player.lastGroundTime;
    let coyoteActive = !player.onGround && coyoteDiff < COYOTE_MS;
    document.getElementById('d-coyote').innerText = coyoteActive ? "ACTIVE (" + coyoteDiff + "ms)" : "Inactive";
    document.getElementById('d-coyote').style.color = coyoteActive ? "#0f0" : "#555";
}

/** RENDER HELPERS */
function drawRect(x, y, w, h, rotation, color) {
    let screenX = x - cameraX;
    if (screenX + w < 0 || screenX - w > canvas.width) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
    gl.uniform4fv(colorLocation, color);
    gl.uniform2f(translationLocation, screenX, y);
    gl.uniform2f(scaleLocation, w, h);
    gl.uniform1f(rotationLocation, rotation);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function drawTriangle(x, y, w, h, rotation, color) {
    let screenX = x - cameraX;
    if (screenX + w < 0 || screenX - w > canvas.width) return;
    gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
    gl.uniform4fv(colorLocation, color);
    gl.uniform2f(translationLocation, screenX, y);
    gl.uniform2f(scaleLocation, w, h);
    gl.uniform1f(rotationLocation, rotation);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}

function drawRagdoll() {
    let px = player.matrixPos.x;
    let py = player.matrixPos.y;
    let rot = player.rotation;
    
    drawRect(px, py, 40, 8, rot, [0.4, 0.4, 0.4, 1]); 
    
    let c = Math.cos(rot);
    let s = Math.sin(rot);
    let wx = 15; let wy = -8;
    drawRect(px - (wx*c - wy*s), py - (wx*s + wy*c), 8, 8, rot, [1,1,1,1]);
    drawRect(px + (wx*c + wy*s), py + (wx*s - wy*c), 8, 8, rot, [1,1,1,1]);

    let time = Date.now() / 50;
    let shake = (val) => (Math.sin(time + val) * player.trauma * 0.05); 
    let skin = [0.9, 0.7, 0.6, 1];
    let shirt = [1, 0.3, 0.3, 1];
    let pants = [0.2, 0.2, 0.6, 1];

    function getRelPos(ox, oy) {
        return {
            x: px + (ox * c - oy * s),
            y: py + (ox * s + oy * c)
        };
    }

    let legH = 18 * (1 - player.crouch * 0.5); 
    let legY = 4 + (legH / 2); 
    let lLeg = getRelPos(-5, legY);
    let rLeg = getRelPos(5, legY);
    drawRect(lLeg.x, lLeg.y, 6, legH, rot + shake(0), pants);
    drawRect(rLeg.x, rLeg.y, 6, legH, rot + shake(1), pants);

    let torsoH = 24;
    let torsoY = legY + (legH/2) + (torsoH/2);
    let leanOffset = player.lean * 5; 
    let torsoPos = getRelPos(leanOffset, torsoY);
    let torsoRot = rot + (player.lean * 0.2) + shake(2);
    drawRect(torsoPos.x, torsoPos.y, 14, torsoH, torsoRot, shirt);

    let headY = torsoY + (torsoH/2) + 8; 
    let headPos = getRelPos(leanOffset + shake(3)*5, headY);
    drawRect(headPos.x, headPos.y, 12, 12, torsoRot + shake(4), skin);

    let armY = torsoY + 5;
    let armH = 18;
    let armRotL = torsoRot + 0.5 + shake(5)*5; 
    let armRotR = torsoRot - 0.5 + shake(6)*5;
    let lArm = getRelPos(leanOffset - 8, armY);
    let rArm = getRelPos(leanOffset + 8, armY);

    drawRect(lArm.x, lArm.y, 5, armH, armRotL, skin);
    drawRect(rArm.x, rArm.y, 5, armH, armRotR, skin);
}

function draw() {
    update();

    gl.clearColor(0.2, 0.2, 0.2, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionAttributeLocation);

    drawRect(cameraX + canvas.width/2, groundY/2, canvas.width, groundY, 0, [0.3, 0.3, 0.3, 1]);

    for (let obs of obstacles) {
        if (obs.type === 'wedge') {
            let wX = obs.x + (obs.w / 2);
            let wY = groundY + (obs.h / 2);
            drawTriangle(wX, wY, obs.w, obs.h, 0, obs.color);
        } else {
            let pX = obs.x + (obs.w / 2);
            let topY = groundY + obs.h - 5; 
            drawRect(pX, topY, obs.w, 10, 0, obs.color);
            drawRect(pX, topY - 10, obs.w, 10, 0, [0.2, 0.1, 0.1, 1]); 
        }
    }

    drawRagdoll();
    requestAnimationFrame(draw);
}

draw();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Skateboard Platformer - Loop de Loop</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

<div id="ui">
    <h1>WebGL Skater: Loop de Loop</h1>
    <p>Controls: Arrow Keys to Move | Space to Ollie</p>
    <p style="color: yellow; font-size: 0.9em">Tip: You need speed to clear the loop!</p>
</div>
<canvas id="gameCanvas"></canvas>

<script id="vertex-shader-2d" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    uniform float u_rotation;

    void main() {
        vec2 rotatedPosition = vec2(
             a_position.x * cos(u_rotation) - a_position.y * sin(u_rotation),
             a_position.x * sin(u_rotation) + a_position.y * cos(u_rotation)
        );
        vec2 scaledPosition = rotatedPosition * u_scale;
        vec2 position = scaledPosition + u_translation;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace, 0, 1);
    }
</script>

<script id="fragment-shader-2d" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
/** * WEBGL SETUP */
const canvas = document.getElementById("gameCanvas");
const gl = canvas.getContext("webgl");

if (!gl) { alert("WebGL not supported"); }

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShaderSource = document.getElementById("vertex-shader-2d").text;
const fragmentShaderSource = document.getElementById("fragment-shader-2d").text;
const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vertexShaderSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource));
gl.linkProgram(program);

const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");
const translationLocation = gl.getUniformLocation(program, "u_translation");
const scaleLocation = gl.getUniformLocation(program, "u_scale");
const rotationLocation = gl.getUniformLocation(program, "u_rotation");

// Buffers
const rectBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
  -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
]), gl.STATIC_DRAW);

const triangleBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -0.5, -0.5, 0.5, -0.5, 0.5,  0.5
]), gl.STATIC_DRAW);


/**
 * GAME DATA
 */
const GRAVITY = 0.6;
const FRICTION = 0.98; 
const ACCEL = 1.0;
const JUMP_FORCE = 13;
const MAX_SPEED = 30; // Increased max speed for the loop

let cameraX = 0;
const keys = { left: false, right: false, space: false };

const player = {
    x: 100,
    y: 300,
    width: 40,
    height: 10,
    vx: 0,
    vy: 0,
    rotation: 0,
    onGround: false,
    color: [1, 0.5, 0, 1],
    // LOOP STATE
    inLoop: false,
    loopId: -1,
    loopAngle: 0
};

const groundY = 50;
const LEVEL_LENGTH = 15000;

const obstacles = [
    { type: 'wedge',    x: 400,  w: 200, h: 100, color: [0.3, 0.3, 0.8, 1] },
    { type: 'platform', x: 600,  w: 300, h: 100, color: [0.3, 0.3, 0.8, 1] },
    { type: 'wave',     x: 1100, w: 950, h: 60, freq: 0.02, color: [0.2, 0.8, 0.5, 1] },
    
    // THE LOOP DE LOOP
    // r = radius, t = thickness
    { type: 'loop',     x: 5600, r: 180, t: 20, color: [0.9, 0.8, 0.2, 1] },

    { type: 'wedge',    x: 10500, w: 300, h: 200, color: [0.8, 0.3, 0.3, 1] },
    { type: 'platform', x: 10800, w: 400, h: 200, color: [0.8, 0.3, 0.3, 1] }
];

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'Space') {
        if (!keys.space && player.onGround && !player.inLoop) {
            player.vy = JUMP_FORCE;
            player.onGround = false;
        }
        keys.space = true;
    }
});
window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'Space') keys.space = false;
});

function getTerrainInfo(px) {
    let height = groundY;
    let angle = 0;

    for (let obs of obstacles) {
        if (obs.type === 'loop') continue; // Loops are handled separately

        let endX = obs.x + obs.w;
        if (px > obs.x && px <= endX) {
            if (obs.type === 'wedge') {
                let ratio = (px - obs.x) / obs.w;
                height = Math.max(height, groundY + (ratio * obs.h));
                angle = Math.atan2(obs.h, obs.w);
            } 
            else if (obs.type === 'platform') {
                height = Math.max(height, groundY + obs.h);
                angle = 0;
            }
            else if (obs.type === 'wave') {
                let dx = px - obs.x;
                let waveH = obs.h * (1 - Math.cos(dx * obs.freq));
                height = Math.max(height, groundY + waveH);
                let slope = obs.h * obs.freq * Math.sin(dx * obs.freq);
                angle = Math.atan(slope);
            }
        }
    }
    return { height, angle };
}

function update() {
    
    // --- 1. LOOP PHYSICS (SPECIAL STATE) ---
    if (player.inLoop) {
        let loop = obstacles[player.loopId];
        
        // Physics in loop: Velocity drives Angle
        // Circumference distance = angle * r
        // Angular velocity = v / r
        
        // Gravity effect: Gravity pulls down. 
        // At angle 0 (bottom), G opposes nothing. 
        // At angle 90 (right side), G opposes motion fully.
        // Simple approximation: subtract gravity from tangential velocity based on sin(angle)
        player.vx -= (GRAVITY * Math.sin(player.loopAngle));
        
        // Friction in loop
        player.vx *= 0.99;

        // Update Angle
        let angularVel = player.vx / loop.r;
        player.loopAngle += angularVel;

        // Calculate Position relative to loop center
        // Center of loop is (x + r, groundY + r)
        let cx = loop.x; // Loop entry point is roughly bottom
        let cy = groundY + loop.r;

        // We map Angle 0 to Bottom (3PI/2 in standard trig, or just use rotated math)
        // Let's use: x = r*sin(a), y = -r*cos(a)
        // a=0 -> x=0, y=-r (Bottom relative to center)
        player.x = cx + (loop.r * Math.sin(player.loopAngle));
        player.y = cy - (loop.r * Math.cos(player.loopAngle));

        // Rotation matches the tangent
        player.rotation = player.loopAngle;

        // Exit Condition 1: Completed loop
        if (player.loopAngle >= Math.PI * 2) {
            player.inLoop = false;
            player.loopAngle = 0;
            player.rotation = 0;
            // Eject with current velocity
        }
        // Exit Condition 2: Failed loop (fell / too slow)
        // If speed drops below 2 and we are upside down
        else if (Math.abs(player.vx) < 5 && player.y > groundY + loop.r) {
            player.inLoop = false;
            player.rotation = 0;
            // Let normal gravity take over next frame
        }
        // Exit Condition 3: Going backwards out of loop
        else if (player.loopAngle < -0.1) {
            player.inLoop = false;
            player.loopAngle = 0;
            player.rotation = 0;
        }

        // Camera follow
        let targetCamX = player.x - canvas.width / 2;
        cameraX += (targetCamX - cameraX) * 0.1;
        return; // Skip normal physics
    }

    // --- 2. NORMAL PHYSICS ---

    let prevX = player.x;
    let prevY = player.y;

    if (keys.left) player.vx -= ACCEL;
    if (keys.right) player.vx += ACCEL;
    
    if(player.vx > MAX_SPEED) player.vx = MAX_SPEED;
    if(player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;
    player.vx *= FRICTION;

    player.x += player.vx;
    player.y += player.vy;
    player.vy -= GRAVITY;

    // Check for Loop Entry
    // We only enter if we are on ground, close to loop start, and have speed
    for(let i=0; i<obstacles.length; i++) {
        let obs = obstacles[i];
        if (obs.type === 'loop') {
            // Check proximity to start of loop (obs.x)
            let distToStart = Math.abs(player.x - obs.x);
            
            // Requirements: Close X, Low Y (on ground), High Speed
            if (distToStart < 30 && player.y < groundY + 20 && player.vx > 10) {
                player.inLoop = true;
                player.loopId = i;
                player.loopAngle = 0;
                // Boost slightly to help complete it
                player.vx += 2; 
                return;
            }
        }
    }

    // Standard Terrain
    let terrain = getTerrainInfo(player.x);
    let targetFloorY = terrain.height;
    let targetAngle = terrain.angle;

    // Wall Collision
    const STEP_HEIGHT = 20; 
    let prevFeetY = prevY - (player.height / 2);

    if (targetFloorY > prevFeetY + STEP_HEIGHT) {
        player.x = prevX;
        player.vx = 0;
        let correctedTerrain = getTerrainInfo(player.x);
        targetFloorY = correctedTerrain.height;
        targetAngle = correctedTerrain.angle;
    }

    // Vertical Snap
    let feetY = player.y - (player.height / 2);
    if (feetY < targetFloorY) {
        player.y = targetFloorY + (player.height / 2);
        player.vy = 0;
        player.onGround = true;
        player.rotation = targetAngle;
    } else {
        player.onGround = false;
        player.rotation *= 0.95; 
    }

    if (player.x < 0) { player.x = 0; player.vx = 0; }
    if (player.x > LEVEL_LENGTH) { player.x = LEVEL_LENGTH; player.vx = 0; }

    let targetCamX = player.x - canvas.width / 2;
    if (targetCamX < 0) targetCamX = 0;
    if (targetCamX > LEVEL_LENGTH - canvas.width) targetCamX = LEVEL_LENGTH - canvas.width;
    cameraX += (targetCamX - cameraX) * 0.1;
}

/** RENDER */
function drawRect(x, y, w, h, rotation, color) {
    let screenX = x - cameraX;
    if (screenX + w < 0 || screenX - w > canvas.width) return;

    gl.bindBuffer(gl.ARRAY_BUFFER, rectBuffer);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
    gl.uniform4fv(colorLocation, color);
    gl.uniform2f(translationLocation, screenX, y);
    gl.uniform2f(scaleLocation, w, h);
    gl.uniform1f(rotationLocation, rotation);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function drawTriangle(x, y, w, h, rotation, color) {
    let screenX = x - cameraX;
    if (screenX + w < 0 || screenX - w > canvas.width) return;

    gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
    gl.uniform4fv(colorLocation, color);
    gl.uniform2f(translationLocation, screenX, y);
    gl.uniform2f(scaleLocation, w, h);
    gl.uniform1f(rotationLocation, rotation);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}

function drawLoop(obs) {
    // Draw loop as a series of connected rectangles (ring)
    // Center of loop
    let cx = obs.x;
    let cy = groundY + obs.r;
    let thickness = obs.t || 10;
    let segCount = 60;
    let segAngle = (Math.PI * 2) / segCount;
    
    // Use perimeter to calculate segment width so no gaps
    let segWidth = (2 * Math.PI * obs.r) / segCount + 2; 

    for(let i=0; i<segCount; i++) {
        let angle = i * segAngle;
        
        // Position on circle
        // We use the same math: x = r*sin(a), y = -r*cos(a) to match physics
        let px = cx + (obs.r * Math.sin(angle));
        let py = cy - (obs.r * Math.cos(angle));

        // Only draw if on screen
        if (px - cameraX > -100 && px - cameraX < canvas.width + 100) {
            drawRect(px, py, segWidth, thickness, angle, obs.color);
        }
    }
}

function draw() {
    update();

    gl.clearColor(0.2, 0.2, 0.2, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionAttributeLocation);

    drawRect(LEVEL_LENGTH/2, groundY/2, LEVEL_LENGTH, groundY, 0, [0.3, 0.3, 0.3, 1]);

    for (let obs of obstacles) {
        if (obs.type === 'wedge') {
            let wX = obs.x + (obs.w / 2);
            let wY = groundY + (obs.h / 2);
            drawTriangle(wX, wY, obs.w, obs.h, 0, obs.color);
        } 
        else if (obs.type === 'platform') {
            let pX = obs.x + (obs.w / 2);
            let pY = groundY + obs.h - 5; 
            drawRect(pX, pY, obs.w, 10, 0, obs.color);
            let supportH = obs.h - 10;
            drawRect(pX, groundY + supportH/2, obs.w, supportH, 0, [0.2, 0.2, 0.2, 1]); 
        }
        else if (obs.type === 'wave') {
            const step = 10;
            for(let i = 0; i < obs.w; i += step) {
                let dx = i;
                let sliceX = obs.x + dx + (step/2);
                let sliceH = obs.h * (1 - Math.cos(dx * obs.freq));
                let rectH = sliceH + groundY; 
                let rectY = rectH / 2;
                if (sliceX - cameraX > -50 && sliceX - cameraX < canvas.width + 50) {
                     drawRect(sliceX, rectY, step + 1, rectH, 0, obs.color);
                }
            }
        }
        else if (obs.type === 'loop') {
            drawLoop(obs);
        }
    }

    drawRect(player.x, player.y, player.width, player.height, player.rotation, player.color);
    
    // Wheels (positioned relative to player rotation)
    let wx = player.width/2 - 5;
    let wy = -player.height/2 - 3;
    // Rotate relative offset
    let c = Math.cos(player.rotation);
    let s = Math.sin(player.rotation);
    
    let w1x = player.x - (wx * c - wy * s); // back wheel
    let w1y = player.y - (wx * s + wy * c);
    let w2x = player.x + (wx * c + wy * s); // front wheel (approx)
    let w2y = player.y + (wx * s - wy * c);

    drawRect(w1x, w1y, 6, 6, player.rotation, [1,1,1,1]);
    drawRect(w2x, w2y, 6, 6, player.rotation, [1,1,1,1]);

    requestAnimationFrame(draw);
}

draw();

</script>
</body>
</html>

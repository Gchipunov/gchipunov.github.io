<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Skateboard Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 20px; left: 20px;
            color: white;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="ui">
    <h1>WebGL Skater</h1>
    <p>Controls: Arrow Keys to Move | Space to Ollie (Jump)</p>
</div>
<canvas id="gameCanvas"></canvas>

<script id="vertex-shader-2d" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    uniform float u_rotation; // in radians

    void main() {
        // Rotate the position
        vec2 rotatedPosition = vec2(
             a_position.x * cos(u_rotation) - a_position.y * sin(u_rotation),
             a_position.x * sin(u_rotation) + a_position.y * cos(u_rotation)
        );

        // Scale
        vec2 scaledPosition = rotatedPosition * u_scale;

        // Translate (in pixels)
        vec2 position = scaledPosition + u_translation;

        // Convert from pixels to 0.0->1.0
        vec2 zeroToOne = position / u_resolution;

        // Convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;

        // Convert from 0->2 to -1->+1 (clip space)
        vec2 clipSpace = zeroToTwo - 1.0;

        // Flip Y axis so 0 is at bottom (optional, but standard for 2D games usually top-left. 
        // Here we keep 0,0 at bottom left for easier physics)
        gl_Position = vec4(clipSpace, 0, 1);
    }
</script>

<script id="fragment-shader-2d" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
/** * WEBGL BOILERPLATE SETUP 
 */
const canvas = document.getElementById("gameCanvas");
const gl = canvas.getContext("webgl");

if (!gl) { alert("WebGL not supported"); }

// Compile Shader Function
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

// Create Program
const vertexShaderSource = document.getElementById("vertex-shader-2d").text;
const fragmentShaderSource = document.getElementById("fragment-shader-2d").text;
const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

// Look up locations
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");
const translationLocation = gl.getUniformLocation(program, "u_translation");
const scaleLocation = gl.getUniformLocation(program, "u_scale");
const rotationLocation = gl.getUniformLocation(program, "u_rotation");

// Create a buffer for a unit square
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
// Geometry: A square centered at 0,0 (-0.5 to 0.5)
const positions = [
  -0.5, -0.5,
   0.5, -0.5,
  -0.5,  0.5,
  -0.5,  0.5,
   0.5, -0.5,
   0.5,  0.5,
];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

/**
 * GAME ENGINE & PHYSICS
 */

// Game Constants
const GRAVITY = 0.6;
const FRICTION = 0.96;
const ACCEL = 1.2;
const JUMP_FORCE = 12;

// Input State
const keys = { left: false, right: false, space: false };

// Game Objects
const player = {
    x: 100,
    y: 300,
    width: 40,
    height: 10,
    vx: 0,
    vy: 0,
    rotation: 0,
    onGround: false,
    color: [1, 0.5, 0, 1] // Orange
};

// Ground and Wedge definitions
const groundY = 50; // The flat floor height
const wedge = {
    xStart: 400,
    width: 200,
    height: 100, // How high the ramp goes
    color: [0.3, 0.3, 0.8, 1]
};

// Resize handling
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// Input handling
window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'Space') {
        if (!keys.space && player.onGround) {
            player.vy = JUMP_FORCE;
            player.onGround = false;
        }
        keys.space = true;
    }
});
window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'Space') keys.space = false;
});

/**
 * PHYSICS UPDATE LOOP
 */
function update() {
    // 1. Horizontal Movement
    if (keys.left) player.vx -= ACCEL;
    if (keys.right) player.vx += ACCEL;

    // Friction
    player.vx *= FRICTION;
    
    // Apply Velocity
    player.x += player.vx;
    player.y += player.vy;

    // 2. Gravity
    player.vy -= GRAVITY;

    // 3. Collision Detection (Ground & Wedge)
    
    // Default floor height
    let currentFloor = groundY;
    let slopeAngle = 0;

    // Check if within Wedge X bounds
    const wedgeEnd = wedge.xStart + wedge.width;
    
    if (player.x > wedge.xStart && player.x < wedgeEnd) {
        // Calculate height on slope (Linear interpolation)
        // Ratio (0.0 to 1.0) of how far we are along the wedge
        let ratio = (player.x - wedge.xStart) / wedge.width;
        
        // Height of wedge at this X
        let wedgeH = ratio * wedge.height;
        
        // The floor is now the ground + wedge height
        currentFloor = groundY + wedgeH;
        
        // Calculate angle for visual rotation (arctan of slope)
        slopeAngle = Math.atan2(wedge.height, wedge.width);
    } 
    // Platform top (if we passed the wedge)
    else if (player.x >= wedgeEnd) {
        // Logic to drop off or stay high? 
        // Let's make it a platform that stays high for a bit then drops off 
        // For this demo, let's just make the ground flat again after the wedge to test "jumping off"
        if(player.x < wedgeEnd + 200) {
            currentFloor = groundY + wedge.height;
            slopeAngle = 0;
        }
    }

    // Floor Collision
    // We add half height to y because y is the center of the square in WebGL rendering
    // But for physics, let's treat x,y as center
    if (player.y - (player.height/2) < currentFloor) {
        player.y = currentFloor + (player.height/2);
        player.vy = 0;
        player.onGround = true;
        
        // Snap rotation to slope
        player.rotation = slopeAngle;
    } else {
        player.onGround = false;
        // Slowly rotate back to 0 if in air
        player.rotation = player.rotation * 0.9;
    }

    // Walls
    if (player.x < 0) { player.x = 0; player.vx *= -0.5; }
    if (player.x > canvas.width) { player.x = canvas.width; player.vx *= -0.5; }
}

/**
 * RENDER HELPER
 */
function drawRect(x, y, w, h, rotation, color) {
    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
    gl.uniform4fv(colorLocation, color);
    gl.uniform2f(u_translation, x, y);
    gl.uniform2f(u_scale, w, h);
    gl.uniform1f(u_rotation, rotation);

    // Draw the 6 vertices of the square buffer
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/**
 * MAIN DRAW LOOP
 */
function draw() {
    update();

    // Clear Screen
    gl.clearColor(0.2, 0.2, 0.2, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    // 1. Draw Floor
    // Using a large rectangle
    drawRect(canvas.width/2, groundY/2, canvas.width, groundY, 0, [0.3, 0.3, 0.3, 1]);

    // 2. Draw Wedge
    // WebGL makes triangles hard without custom buffers, so we will cheat visually:
    // We will draw a Rectangle rotated to look like a ramp, masked by the floor.
    // Actually, let's draw it using math:
    // Center of wedge visual
    let wX = wedge.xStart + (wedge.width / 2);
    let wY = groundY + (wedge.height / 2);
    let angle = Math.atan2(wedge.height, wedge.width);
    let hypotenuse = Math.sqrt(wedge.width*wedge.width + wedge.height*wedge.height);
    
    // Drawing a rotated rectangle that represents the surface
    drawRect(wX, wY, hypotenuse, 10, angle, wedge.color);
    
    // Fill the space under the ramp (approximated with a block for style)
    drawRect(wX, (groundY + wedge.height/2) / 2 + 10, wedge.width, wedge.height/2, 0, [0.25, 0.25, 0.7, 1]);

    // 3. Draw Platform after wedge
    drawRect(wedge.xStart + wedge.width + 100, groundY + wedge.height - 5, 200, 10, 0, wedge.color);

    // 4. Draw Player (Skateboard)
    drawRect(player.x, player.y, player.width, player.height, player.rotation, player.color);
    
    // Draw Wheels (visual detail)
    let wheelOffX = (player.width/2) - 5;
    let wheelOffY = -(player.height/2) - 2;
    // Rotate wheels around player center
    // (This is a simplified visual hack, real matrix math would be better but this works for simple demo)
    drawRect(player.x - Math.cos(player.rotation)*15, player.y - Math.sin(player.rotation)*15, 6, 6, player.rotation, [1,1,1,1]);
    drawRect(player.x + Math.cos(player.rotation)*15, player.y + Math.sin(player.rotation)*15, 6, 6, player.rotation, [1,1,1,1]);

    requestAnimationFrame(draw);
}

// Start
draw();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGL 2D Fighter - Mobile Ready</title>
    <style>
        body { 
            margin: 0; background: #1a1a1a; color: white; font-family: sans-serif; 
            overflow: hidden; display: flex; flex-direction: column; align-items: center;
            touch-action: none; /* Prevents scrolling/zooming while playing */
        }
        canvas { 
            background: #333; width: 100%; max-width: 800px; height: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); border-bottom: 5px solid #555; 
        }
        .ui { position: absolute; top: 10px; left: 10px; pointer-events: none; text-shadow: 2px 2px 2px black; }
        
        /* Mobile Controls Layout */
        .touch-container {
            display: flex; justify-content: space-between; width: 100%; max-width: 900px;
            padding: 20px; box-sizing: border-box; user-select: none;
        }
        .dpad, .action-pad { display: grid; gap: 10px; }
        .dpad { grid-template-areas: ". up ." "left . right"; }
        .action-pad { grid-template-columns: repeat(4, 1fr); }

        .btn {
            width: 60px; height: 60px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3); border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 12px; touch-action: none;
        }
        .btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); }
        .up { grid-area: up; background: rgba(0, 255, 100, 0.2); }
        .atk { background: rgba(255, 50, 50, 0.2); }
    </style>
</head>
<body>

    <div class="ui">
        <h2>WEBGL FIGHTER</h2>
        <div id="moveDisplay">State: IDLE</div>
    </div>

    <canvas id="glCanvas"></canvas>

    <div class="touch-container">
        <div class="dpad">
            <div class="btn up" id="btn-Space">JUMP</div>
            <div class="btn" id="btn-ArrowLeft">LEFT</div>
            <div class="btn" id="btn-ArrowRight">RIGHT</div>
        </div>

        <div class="action-pad">
            <div class="btn atk" id="btn-KeyA">PCH</div>
            <div class="btn atk" id="btn-KeyS">UPR</div>
            <div class="btn atk" id="btn-KeyD">SWG</div>
            <div class="btn atk" id="btn-KeyZ">KCK</div>
            <div class="btn atk" id="btn-KeyX">LOW</div>
            <div class="btn atk" id="btn-KeyC">BCK</div>
            <div class="btn atk" id="btn-KeyV">TRP</div>
        </div>
    </div>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

canvas.width = 800;
canvas.height = 400;

// --- SHADERS ---
const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform mat3 u_matrix;
    void main() {
        vec2 position = (u_matrix * vec3(a_position, 1)).xy;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");
const matrixLocation = gl.getUniformLocation(program, "u_matrix");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);

// --- MATH ---
const m3 = {
    translation: (tx, ty) => [1,0,0, 0,1,0, tx,ty,1],
    rotation: (angle) => {
        let c = Math.cos(angle), s = Math.sin(angle);
        return [c,s,0, -s,c,0, 0,0,1];
    },
    scaling: (sx, sy) => [sx,0,0, 0,sy,0, 0,0,1],
    multiply: (a, b) => {
        let a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
        let b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
        return [
            b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22,
        ];
    }
};

// --- INPUT HANDLING (Hybrid Keyboard + Touch) ---
const keys = {};
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;

// Attach listeners to all virtual buttons
document.querySelectorAll('.btn').forEach(btn => {
    const keyId = btn.id.replace('btn-', '');
    
    const handleStart = (e) => { e.preventDefault(); keys[keyId] = true; };
    const handleEnd = (e) => { e.preventDefault(); keys[keyId] = false; };

    btn.addEventListener('touchstart', handleStart);
    btn.addEventListener('touchend', handleEnd);
    btn.addEventListener('mousedown', handleStart);
    btn.addEventListener('mouseup', handleEnd);
    btn.addEventListener('mouseleave', handleEnd);
});

// --- PLAYER LOGIC ---
const player = {
    x: 400, y: 300, vx: 0, vy: 0,
    facing: 1, state: 'IDLE', animTimer: 0, grounded: true,
    color: [0.2, 0.6, 1.0, 1.0]
};

function setAction(name, duration) {
    if (player.state === 'IDLE' || player.state === 'WALK') {
        player.state = name;
        player.animTimer = duration;
        document.getElementById('moveDisplay').innerText = "State: " + name;
    }
}

function drawRect(x, y, width, height, color, rotation = 0, originX = 0, originY = 0) {
    let mat = m3.translation(x, y);
    mat = m3.multiply(mat, m3.rotation(rotation));
    mat = m3.multiply(mat, m3.translation(-originX * width, -originY * height));
    mat = m3.multiply(mat, m3.scaling(width, height));
    gl.uniformMatrix3fv(matrixLocation, false, mat);
    gl.uniform4fv(colorLocation, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function update() {
    if (player.animTimer > 0) {
        player.animTimer--;
        if (player.animTimer <= 0) player.state = 'IDLE';
    }

    if (player.state === 'IDLE' || player.state === 'WALK') {
        if (keys['ArrowLeft']) { player.vx = -5; player.facing = -1; player.state = 'WALK'; }
        else if (keys['ArrowRight']) { player.vx = 5; player.facing = 1; player.state = 'WALK'; }
        else { player.vx *= 0.8; player.state = 'IDLE'; }

        if (keys['Space'] && player.grounded) {
            player.vy = -14;
            player.grounded = false;
        }
        
        if (keys['KeyA']) setAction('PUNCH', 12);
        if (keys['KeyS']) setAction('UPPERCUT', 18);
        if (keys['KeyD']) setAction('SWING', 22);
        if (keys['KeyZ']) setAction('KICK', 15);
        if (keys['KeyX']) setAction('LOWKICK', 12);
        if (keys['KeyC']) setAction('BACKKICK', 18);
        if (keys['KeyV']) setAction('TRIP', 20);
    }

    player.vy += 0.8;
    player.x += player.vx;
    player.y += player.vy;

    // Bounds
    if (player.y > 300) { player.y = 300; player.vy = 0; player.grounded = true; }
    if (player.x < 20) player.x = 20;
    if (player.x > 780) player.x = 780;

    render();
    requestAnimationFrame(update);
}

function render() {
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

    // Floor
    drawRect(0, 380, 800, 20, [0.3, 0.3, 0.3, 1.0]);

    const t = player.animTimer;
    const f = player.facing;
    let bY = player.y, rA = 0, lA = 0, rL = 0, lL = 0;

    // Animation Logic
    if (player.state === 'PUNCH') rA = f * -1.5;
    else if (player.state === 'UPPERCUT') { rA = f * -2.8; bY -= (t > 5 ? 15 : 0); }
    else if (player.state === 'SWING') rA = f * (Math.sin(t * 0.4) * 2.5);
    else if (player.state === 'KICK') rL = f * -1.8;
    else if (player.state === 'LOWKICK') { bY += 25; rL = f * -1.4; }
    else if (player.state === 'BACKKICK') lL = f * 1.8;
    else if (player.state === 'TRIP') { bY += 35; rL = f * -2.2; }
    else if (player.state === 'WALK') {
        let wc = Math.sin(Date.now() * 0.012);
        rL = wc * 0.7; lL = -wc * 0.7;
    }

    // Render Skeletal Parts
    drawRect(player.x - 15, bY, 30, 50, player.color); // Torso
    drawRect(player.x - 10, bY - 25, 20, 20, [0.9, 0.8, 0.7, 1.0]); // Head
    drawRect(player.x - 8, bY + 45, 12, 40, [0.1, 0.2, 0.5, 1.0], lL, 0.5, 0); // Leg L
    drawRect(player.x + 8, bY + 45, 12, 40, [0.1, 0.2, 0.5, 1.0], rL, 0.5, 0); // Leg R
    drawRect(player.x - 16, bY + 10, 35, 12, player.color, lA, (f>0?1:0), 0.5); // Arm L
    drawRect(player.x + 16, bY + 10, 35, 12, player.color, rA, (f>0?0:1), 0.5); // Arm R
}

update();
</script>
</body>
</html>

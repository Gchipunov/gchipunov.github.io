<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGL 2D Fighter - Fixed & Mobile</title>
    <style>
        body { 
            margin: 0; background: #111; color: white; font-family: 'Segoe UI', sans-serif; 
            overflow: hidden; display: flex; flex-direction: column; align-items: center;
            touch-action: none; 
        }
        canvas { 
            background: #222; width: 100vw; max-width: 800px; height: 50vh;
            border-bottom: 4px solid #444; image-rendering: pixelated;
        }
        .ui { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; }
        .move-label { font-size: 1.5rem; font-weight: bold; color: #0f0; text-shadow: 2px 2px #000; }

        .touch-controls {
            display: flex; justify-content: space-around; width: 100%; max-width: 800px;
            padding: 10px; box-sizing: border-box; flex-grow: 1;
        }
        .dpad, .action-grid { display: grid; gap: 8px; }
        .dpad { grid-template-areas: ". up ." "left . right"; }
        .action-grid { grid-template-columns: repeat(4, 1fr); }

        .btn {
            width: 55px; height: 55px; background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.4); border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 11px; user-select: none;
        }
        .btn:active { background: rgba(0, 255, 100, 0.4); transform: scale(0.9); }
        .btn.up { grid-area: up; height: 50px; background: rgba(100, 100, 255, 0.3); }
        .btn.atk { background: rgba(255, 80, 80, 0.2); }
    </style>
</head>
<body>

    <div class="ui">
        <div id="moveDisplay" class="move-label">State: IDLE</div>
    </div>

    <canvas id="glCanvas"></canvas>

    <div class="touch-controls">
        <div class="dpad">
            <div class="btn up" id="btn-Space">JUMP</div>
            <div class="btn" id="btn-ArrowLeft">LEFT</div>
            <div class="btn" id="btn-ArrowRight">RIGHT</div>
        </div>

        <div class="action-grid">
            <div class="btn atk" id="btn-KeyA">PUNCH</div>
            <div class="btn atk" id="btn-KeyS">UPPER</div>
            <div class="btn atk" id="btn-KeyD">SWING</div>
            <div class="btn atk" id="btn-KeyZ">KICK</div>
            <div class="btn atk" id="btn-KeyX">LOW</div>
            <div class="btn atk" id="btn-KeyC">BACK</div>
            <div class="btn atk" id="btn-KeyV">TRIP</div>
        </div>
    </div>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl', { antialias: false });

canvas.width = 800;
canvas.height = 400;

// Shaders - Fixed precision and uniform handling
const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform mat3 u_matrix;
    void main() {
        vec2 pos = (u_matrix * vec3(a_position, 1)).xy;
        vec2 zeroToOne = pos / u_resolution;
        vec2 clipSpace = (zeroToOne * 2.0) - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

function compileShader(gl, source, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    return s;
}

const program = gl.createProgram();
gl.attachShader(program, compileShader(gl, vsSource, gl.VERTEX_SHADER));
gl.attachShader(program, compileShader(gl, fsSource, gl.FRAGMENT_SHADER));
gl.linkProgram(program);
gl.useProgram(program);

const posLoc = gl.getAttribLocation(program, "a_position");
const resLoc = gl.getUniformLocation(program, "u_resolution");
const colLoc = gl.getUniformLocation(program, "u_color");
const matLoc = gl.getUniformLocation(program, "u_matrix");

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);

// Matrix Logic
const m3 = {
    identity: () => [1,0,0, 0,1,0, 0,0,1],
    translation: (tx, ty) => [1,0,0, 0,1,0, tx,ty,1],
    rotation: (angle) => {
        let c = Math.cos(angle), s = Math.sin(angle);
        return [c,s,0, -s,c,0, 0,0,1];
    },
    scaling: (sx, sy) => [sx,0,0, 0,sy,0, 0,0,1],
    multiply: (a, b) => {
        let b00 = b[0*3+0], b01 = b[0*3+1], b02 = b[0*3+2],
            b10 = b[1*3+0], b11 = b[1*3+1], b12 = b[1*3+2],
            b20 = b[2*3+0], b21 = b[2*3+1], b22 = b[2*3+2],
            a00 = a[0*3+0], a01 = a[0*3+1], a02 = a[0*3+2],
            a10 = a[1*3+0], a11 = a[1*3+1], a12 = a[1*3+2],
            a20 = a[2*3+0], a21 = a[2*3+1], a22 = a[2*3+2];
        return [
            b00*a00+b01*a10+b02*a20, b00*a01+b01*a11+b02*a21, b00*a02+b01*a12+b02*a22,
            b10*a00+b11*a10+b12*a20, b10*a01+b11*a11+b12*a21, b10*a02+b11*a12+b12*a22,
            b20*a00+b21*a10+b22*a20, b20*a01+b21*a11+b22*a21, b20*a02+b21*a12+b22*a22
        ];
    }
};

const keys = {};
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

document.querySelectorAll('.btn').forEach(btn => {
    const k = btn.id.replace('btn-', '');
    const press = e => { e.preventDefault(); keys[k] = true; };
    const release = e => { e.preventDefault(); keys[k] = false; };
    btn.addEventListener('touchstart', press);
    btn.addEventListener('touchend', release);
    btn.addEventListener('mousedown', press);
    btn.addEventListener('mouseup', release);
});

const p = {
    x: 400, y: 300, vx: 0, vy: 0,
    facing: 1, state: 'IDLE', timer: 0, grounded: true
};

function setAct(name, dur) {
    if (p.state === 'IDLE' || p.state === 'WALK') {
        p.state = name; p.timer = dur;
        document.getElementById('moveDisplay').innerText = "State: " + name;
    }
}

function drawPart(x, y, w, h, col, rot=0, ox=0.5, oy=0.5) {
    let m = m3.translation(x, y);
    m = m3.multiply(m, m3.rotation(rot));
    m = m3.multiply(m, m3.translation(-ox * w, -oy * h));
    m = m3.multiply(m, m3.scaling(w, h));
    
    gl.uniformMatrix3fv(matLoc, false, m);
    gl.uniform4fv(colLoc, col);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function loop() {
    // Logic
    if (p.timer > 0) {
        p.timer--;
        if (p.timer <= 0) p.state = 'IDLE';
    }

    if (p.state === 'IDLE' || p.state === 'WALK') {
        if (keys['ArrowLeft']) { p.vx = -5; p.facing = -1; p.state = 'WALK'; }
        else if (keys['ArrowRight']) { p.vx = 5; p.facing = 1; p.state = 'WALK'; }
        else { p.vx *= 0.8; p.state = 'IDLE'; }

        if (keys['Space'] && p.grounded) { p.vy = -15; p.grounded = false; }
        
        if (keys['KeyA']) setAct('PUNCH', 12);
        if (keys['KeyS']) setAct('UPPERCUT', 18);
        if (keys['KeyD']) setAct('SWING', 22);
        if (keys['KeyZ']) setAct('KICK', 15);
        if (keys['KeyX']) setAct('LOWKICK', 12);
        if (keys['KeyC']) setAct('BACKKICK', 18);
        if (keys['KeyV']) setAct('TRIP', 20);
    }

    p.vy += 0.8; p.x += p.vx; p.y += p.vy;
    if (p.y > 300) { p.y = 300; p.vy = 0; p.grounded = true; }
    if (p.x < 30) p.x = 30; if (p.x > 770) p.x = 770;

    // Render
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.07, 0.07, 0.07, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.enableVertexAttribArray(posLoc);
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Floor
    drawPart(400, 390, 800, 20, [0.3, 0.3, 0.3, 1.0]);

    // Anim Vars
    let bY = p.y, rA=0, lA=0, rL=0, lL=0, f = p.facing;
    let armCol = [0.2, 0.5, 1.0, 1.0], headCol = [1, 0.8, 0.7, 1];

    if (p.state === 'PUNCH') rA = f * -1.6;
    else if (p.state === 'UPPERCUT') { rA = f * -2.8; bY -= (p.timer > 8 ? 20 : 0); }
    else if (p.state === 'SWING') rA = f * (Math.sin(p.timer * 0.5) * 3);
    else if (p.state === 'KICK') rL = f * -1.8;
    else if (p.state === 'LOWKICK') { bY += 20; rL = f * -1.5; }
    else if (p.state === 'BACKKICK') lL = f * 1.8;
    else if (p.state === 'TRIP') { bY += 30; rL = f * -2.4; }
    else if (p.state === 'WALK') {
        let wc = Math.sin(Date.now() * 0.015);
        rL = wc * 0.8; lL = -wc * 0.8;
    }

    // Draw Character
    drawPart(p.x, bY + 45, 14, 40, [0.1, 0.2, 0.4, 1.0], lL, 0.5, 0); // Leg L
    drawPart(p.x, bY + 45, 14, 40, [0.1, 0.2, 0.4, 1.0], rL, 0.5, 0); // Leg R
    drawPart(p.x, bY, 34, 55, armCol); // Torso
    drawPart(p.x, bY - 35, 24, 24, headCol); // Head
    drawPart(p.x - (f*18), bY + 5, 38, 14, armCol, lA, (f>0?1:0), 0.5); // Arm L
    drawPart(p.x + (f*18), bY + 5, 38, 14, armCol, rA, (f>0?0:1), 0.5); // Arm R

    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

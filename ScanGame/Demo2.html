<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGL Package Scanner - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: monospace; user-select: none; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #crosshair {
            width: 10px; height: 10px; border: 2px solid white; border-radius: 50%;
            background: rgba(255,255,255,0.3);
        }
        #hud {
            position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 20px;
            text-shadow: 1px 1px 0 #000; pointer-events: none;
        }
        #msg {
            position: absolute; bottom: 150px; width: 100%; text-align: center;
            color: yellow; font-size: 24px; font-weight: bold;
            opacity: 0; transition: opacity 0.5s; text-shadow: 1px 1px 0 #000; pointer-events: none;
        }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
            color: white; pointer-events: auto; cursor: pointer; z-index: 10;
        }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 180px;
            pointer-events: none; /* Let touches pass through to canvas if not on button */
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
        }
        .control-group {
            pointer-events: auto;
            position: relative; width: 150px; height: 150px;
        }
        .btn {
            background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px; color: white; display: flex; justify-content: center; align-items: center;
            position: absolute; cursor: pointer; user-select: none; -webkit-user-select: none;
        }
        .btn:active, .btn.active { background: rgba(255, 255, 255, 0.5); }
        
        /* D-Pad */
        #btn-w { top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-s { bottom: 0; left: 50px; width: 50px; height: 50px; }
        #btn-a { top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-d { top: 50px; right: 0; width: 50px; height: 50px; }
        
        /* Action Button */
        #btn-action {
            width: 100px; height: 100px; right: 0; bottom: 25px; border-radius: 50%;
            background: rgba(0, 255, 0, 0.2); border-color: #0f0; font-weight: bold; font-size: 18px;
        }
    </style>
</head>
<body>

<canvas id="glcanvas"></canvas>

<div id="ui">
    <div id="crosshair"></div>
</div>

<div id="hud">
    STATUS: IDLE<br>
    SCORE: 0<br>
    HELD: NONE
</div>

<div id="msg"></div>

<div id="mobile-controls">
    <div class="control-group">
        <div class="btn" id="btn-w">W</div>
        <div class="btn" id="btn-s">S</div>
        <div class="btn" id="btn-a">A</div>
        <div class="btn" id="btn-d">D</div>
    </div>
    <div class="control-group">
        <div class="btn" id="btn-action">SCAN / DROP</div>
    </div>
</div>

<div id="overlay" id="startScreen">
    <div style="text-align:center">
        <h1>PACKAGE SORTER 3000</h1>
        <p>Sort packages into matching zones.</p>
        <p><strong>PC:</strong> WASD to Move | Mouse to Look | Click to Interact</p>
        <p><strong>Mobile:</strong> Left Pad to Move | Drag Screen to Look | Button to Interact</p>
        <br>
        <h2>TAP TO START</h2>
    </div>
</div>

<script>
/* =========================================
   MATH & UTILS (No Libraries)
   ========================================= */
const m4 = {
    perspective: (fov, aspect, near, far) => {
        const f = 1 / Math.tan(fov / 2);
        return [
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (near + far) * (1 / (near - far)), -1,
            0, 0, near * far * (1 / (near - far)) * 2, 0
        ];
    },
    multiply: (a, b) => {
        let r = [];
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                let s = 0;
                for (let k = 0; k < 4; k++) s += a[i * 4 + k] * b[k * 4 + j];
                r[i * 4 + j] = s;
            }
        }
        return r;
    },
    translation: (tx, ty, tz) => [1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1],
    yRotation: (rad) => [Math.cos(rad),0,-Math.sin(rad),0, 0,1,0,0, Math.sin(rad),0,Math.cos(rad),0, 0,0,0,1],
    xRotation: (rad) => [1,0,0,0, 0,Math.cos(rad),Math.sin(rad),0, 0,-Math.sin(rad),Math.cos(rad),0, 0,0,0,1],
    inverse: (m) => {
        let m00 = m[0 * 4 + 0], m01 = m[0 * 4 + 1], m02 = m[0 * 4 + 2], m03 = m[0 * 4 + 3];
        let m10 = m[1 * 4 + 0], m11 = m[1 * 4 + 1], m12 = m[1 * 4 + 2], m13 = m[1 * 4 + 3];
        let m20 = m[2 * 4 + 0], m21 = m[2 * 4 + 1], m22 = m[2 * 4 + 2], m23 = m[2 * 4 + 3];
        let m30 = m[3 * 4 + 0], m31 = m[3 * 4 + 1], m32 = m[3 * 4 + 2], m33 = m[3 * 4 + 3];
        let tmp_0  = m22 * m33, tmp_1  = m32 * m23, tmp_2  = m12 * m33, tmp_3  = m32 * m13;
        let tmp_4  = m12 * m23, tmp_5  = m22 * m13, tmp_6  = m02 * m33, tmp_7  = m32 * m03;
        let tmp_8  = m02 * m23, tmp_9  = m22 * m03, tmp_10 = m02 * m13, tmp_11 = m12 * m03;
        let t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
        let t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
        let t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
        let t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
        let d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
        return [
            d * t0, d * t1, d * t2, d * t3,
            d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),
            d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),
            d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),
            d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),
            d * ((tmp_12 = m22 * m33 - m32 * m23) * m13 + (tmp_13 = m32 * m13 - m12 * m33) * m23 + (tmp_14 = m12 * m23 - m22 * m13) * m33),
            d * ((tmp_15 = m32 * m03 - m02 * m33) * m23 + (tmp_16 = m02 * m23 - m22 * m03) * m33 - tmp_12 * m03),
            d * ((tmp_17 = m02 * m13 - m12 * m03) * m33 - tmp_15 * m13 - tmp_13 * m03),
            d * (tmp_12 * m01 + tmp_15 * m11 + tmp_13 * m21), 
            d * ((m21 * m32 - m31 * m22) * m13 + (m31 * m12 - m11 * m32) * m23 + (m11 * m22 - m21 * m12) * m33),
            d * ((m31 * m02 - m01 * m32) * m23 + (m01 * m22 - m21 * m02) * m33 + (m21 * m32 - m31 * m22) * m03),
            d * ((m01 * m12 - m11 * m02) * m33 + (m11 * m32 - m31 * m12) * m03 + (m31 * m02 - m01 * m32) * m13),
            d * ((m11 * m22 - m21 * m12) * m03 + (m21 * m02 - m01 * m22) * m13 + (m01 * m12 - m11 * m02) * m23)
        ];
    }
};

/* =========================================
   WEBGL SETUP
   ========================================= */
const canvas = document.querySelector("#glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) alert("WebGL not supported");

const vsSource = `
    attribute vec4 a_position;
    attribute vec3 a_normal;
    uniform mat4 u_matrix;
    uniform mat4 u_world;
    varying vec3 v_normal;
    void main() {
        gl_Position = u_matrix * a_position;
        v_normal = mat3(u_world) * a_normal; 
    }
`;

const fsSource = `
    precision mediump float;
    varying vec3 v_normal;
    uniform vec4 u_color;
    uniform float u_highlight;
    void main() {
        vec3 normal = normalize(v_normal);
        vec3 lightDir = normalize(vec3(0.5, 0.7, 1.0));
        float light = max(dot(normal, lightDir), 0.2);
        
        vec3 finalColor = u_color.rgb * light;
        if(u_highlight > 0.5) {
            finalColor = finalColor + vec3(0.3, 0.3, 0.3);
        }
        gl_FragColor = vec4(finalColor, u_color.a);
    }
`;

function createShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
        gl.deleteShader(s);
        return null;
    }
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(prog);
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog, "a_position");
const aNorm = gl.getAttribLocation(prog, "a_normal");
const uMat = gl.getUniformLocation(prog, "u_matrix");
const uWorld = gl.getUniformLocation(prog, "u_world");
const uCol = gl.getUniformLocation(prog, "u_color");
const uHigh = gl.getUniformLocation(prog, "u_highlight");

const cubeVerts = new Float32Array([
    -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
    -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,
    -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,
    -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
     0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,
    -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5,
]);
const cubeInds = new Uint16Array([
    0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11, 12,13,14, 12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23
]);
const cubeNorms = new Float32Array([
   0,0,1,0,0,1,0,0,1,0,0,1, 0,0,-1,0,0,-1,0,0,-1,0,0,-1, 0,1,0,0,1,0,0,1,0,0,1,0, 0,-1,0,0,-1,0,0,-1,0,0,-1,0, 1,0,0,1,0,0,1,0,0,1,0,0, -1,0,0,-1,0,0,-1,0,0,-1,0,0
]);

const bufPos = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);

const bufNorm = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, bufNorm);
gl.bufferData(gl.ARRAY_BUFFER, cubeNorms, gl.STATIC_DRAW);

const bufInd = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufInd);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeInds, gl.STATIC_DRAW);

/* =========================================
   GAME STATE
   ========================================= */
const state = {
    cam: { x: 0, y: 1.5, z: 5, yaw: 0, pitch: 0 },
    keys: {},
    packages: [],
    zones: [],
    heldPackage: null,
    score: 0,
    scanDist: 3.5,
    lastTime: 0,
    touch: { x: 0, y: 0, active: false } // For mobile look
};

const COLORS = {
    RED:   [1.0, 0.2, 0.2, 1.0],
    BLUE:  [0.2, 0.2, 1.0, 1.0],
    GREEN: [0.2, 1.0, 0.2, 1.0]
};
const TYPE_NAMES = ['RED', 'BLUE', 'GREEN'];

function initGame() {
    state.zones.push({ x: -4, y: 0.1, z: -4, color: COLORS.RED, type: 0, scale: 2 });
    state.zones.push({ x:  0, y: 0.1, z: -4, color: COLORS.GREEN, type: 2, scale: 2 });
    state.zones.push({ x:  4, y: 0.1, z: -4, color: COLORS.BLUE, type: 1, scale: 2 });

    for(let i=0; i<6; i++) spawnPackage();
}

function spawnPackage() {
    const type = Math.floor(Math.random()*3);
    const cols = Object.values(COLORS);
    state.packages.push({
        x: (Math.random()*10 - 5),
        y: 0.5,
        z: (Math.random()*4 + 2),
        color: cols[type],
        type: type,
        active: true,
        id: Math.random()
    });
}

function showMsg(txt) {
    const el = document.getElementById('msg');
    el.innerText = txt;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 1500);
}

/* =========================================
   INPUT
   ========================================= */
// Keyboard
document.addEventListener('keydown', e => state.keys[e.code] = true);
document.addEventListener('keyup', e => state.keys[e.code] = false);

document.getElementById('overlay').addEventListener('click', () => {
    // Attempt pointer lock (works on PC)
    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.requestPointerLock();
    document.getElementById('overlay').style.display = 'none';
});

// PC Mouse Look
document.addEventListener('mousemove', e => {
    if (document.pointerLockElement === canvas) {
        state.cam.yaw -= e.movementX * 0.002;
        state.cam.pitch -= e.movementY * 0.002;
        state.cam.pitch = Math.max(-1.5, Math.min(1.5, state.cam.pitch));
    }
});

// PC Mouse Click Interact
document.addEventListener('mousedown', () => {
    if (document.pointerLockElement === canvas) triggerInteraction();
});

// --- MOBILE TOUCH CONTROLS ---

// Mobile "Look" (drag on canvas)
canvas.addEventListener('touchstart', e => {
    state.touch.active = true;
    state.touch.x = e.touches[0].clientX;
    state.touch.y = e.touches[0].clientY;
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    if(!state.touch.active) return;
    e.preventDefault(); // Prevent scrolling
    const tx = e.touches[0].clientX;
    const ty = e.touches[0].clientY;
    
    const dx = tx - state.touch.x;
    const dy = ty - state.touch.y;
    
    // Adjust sensitivity
    state.cam.yaw -= dx * 0.005;
    state.cam.pitch -= dy * 0.005;
    state.cam.pitch = Math.max(-1.5, Math.min(1.5, state.cam.pitch));
    
    state.touch.x = tx;
    state.touch.y = ty;
}, {passive: false});

canvas.addEventListener('touchend', () => state.touch.active = false);

// Mobile Buttons
function bindBtn(id, code) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); state.keys[code] = true; btn.classList.add('active'); });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); state.keys[code] = false; btn.classList.remove('active'); });
}

bindBtn('btn-w', 'KeyW');
bindBtn('btn-s', 'KeyS');
bindBtn('btn-a', 'KeyA');
bindBtn('btn-d', 'KeyD');

// Action Button
const btnAction = document.getElementById('btn-action');
btnAction.addEventListener('touchstart', (e) => {
    e.preventDefault();
    triggerInteraction();
    btnAction.classList.add('active');
});
btnAction.addEventListener('touchend', (e) => {
    e.preventDefault();
    btnAction.classList.remove('active');
});


/* =========================================
   LOGIC & PHYSICS
   ========================================= */
function triggerInteraction() {
    if (state.heldPackage) {
        // DROP
        const zone = getLookedAtZone();
        state.heldPackage.active = true;
        state.heldPackage.x = state.cam.x + Math.sin(state.cam.yaw) * 1.5;
        state.heldPackage.z = state.cam.z - Math.cos(state.cam.yaw) * 1.5;
        state.heldPackage.y = 0.5;

        if (zone) {
            if (zone.type === state.heldPackage.type) {
                state.score += 100;
                showMsg("SCANNED & SORTED! +100");
                state.packages = state.packages.filter(p => p !== state.heldPackage);
                spawnPackage(); 
            } else {
                showMsg("WRONG BIN! TRY AGAIN");
            }
        } else {
             showMsg("DROPPED");
        }
        state.heldPackage = null;
    } else {
        // PICK UP
        const target = getLookedAtPackage();
        if (target) {
            state.heldPackage = target;
            target.active = false;
            showMsg("PACKAGE ACQUIRED");
        }
    }
    updateHud();
}

function updateHud() {
    let txt = "HELD: " + (state.heldPackage ? TYPE_NAMES[state.heldPackage.type] : "NONE");
    document.getElementById('hud').innerHTML = `STATUS: ACTIVE<br>SCORE: ${state.score}<br>${txt}`;
}

function getForwardVector() {
    return {
        x: Math.sin(state.cam.yaw) * Math.cos(state.cam.pitch),
        y: Math.sin(state.cam.pitch),
        z: -Math.cos(state.cam.yaw) * Math.cos(state.cam.pitch)
    };
}

function isLookingAt(objX, objY, objZ, size) {
    const dx = objX - state.cam.x;
    const dy = objY - state.cam.y;
    const dz = objZ - state.cam.z;
    const distSq = dx*dx + dy*dy + dz*dz;
    if (distSq > state.scanDist * state.scanDist) return false;
    const dist = Math.sqrt(distSq);
    const nx = dx/dist, ny = dy/dist, nz = dz/dist;
    const fwd = getForwardVector();
    const dot = nx*fwd.x + ny*fwd.y + nz*fwd.z;
    return dot > 0.95; 
}

function getLookedAtPackage() {
    return state.packages.find(p => p.active && isLookingAt(p.x, p.y, p.z, 1));
}

function getLookedAtZone() {
    return state.zones.find(z => {
        const dx = z.x - state.cam.x;
        const dz = z.z - state.cam.z;
        return (Math.sqrt(dx*dx + dz*dz) < z.scale);
    });
}

function update(dt) {
    const speed = 5 * dt;
    let dx = 0, dz = 0;
    
    if (state.keys['KeyW']) { dx += Math.sin(state.cam.yaw); dz -= Math.cos(state.cam.yaw); }
    if (state.keys['KeyS']) { dx -= Math.sin(state.cam.yaw); dz += Math.cos(state.cam.yaw); }
    if (state.keys['KeyA']) { dx -= Math.cos(state.cam.yaw); dz -= Math.sin(state.cam.yaw); }
    if (state.keys['KeyD']) { dx += Math.cos(state.cam.yaw); dz += Math.sin(state.cam.yaw); }

    state.cam.x += dx * speed;
    state.cam.z += dz * speed;
}

/* =========================================
   RENDER
   ========================================= */
function drawCube(matrix, color, highlight) {
    gl.uniformMatrix4fv(uMat, false, matrix);
    gl.uniformMatrix4fv(uWorld, false, matrix); 
    gl.uniform4fv(uCol, color);
    gl.uniform1f(uHigh, highlight ? 1.0 : 0.0);
    gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
}

function render(time) {
    const now = time * 0.001;
    const dt = now - state.lastTime;
    state.lastTime = now;

    update(dt);

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const aspect = canvas.width / canvas.height;
    const projection = m4.perspective(Math.PI / 3, aspect, 0.1, 100);
    
    const viewInv = m4.multiply(m4.translation(state.cam.x, state.cam.y, state.cam.z), m4.yRotation(state.cam.yaw));
    const viewInvFinal = m4.multiply(viewInv, m4.xRotation(state.cam.pitch));
    const view = m4.inverse(viewInvFinal);
    const viewProj = m4.multiply(projection, view);

    gl.bindBuffer(gl.ARRAY_BUFFER, bufPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPos);

    gl.bindBuffer(gl.ARRAY_BUFFER, bufNorm);
    gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aNorm);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufInd);

    // Floor
    let floorM = m4.translation(0, -0.5, 0);
    floorM = m4.multiply(floorM, [20,0,0,0, 0,1,0,0, 0,0,20,0, 0,0,0,1]);
    drawCube(m4.multiply(viewProj, floorM), [0.3, 0.3, 0.3, 1.0], false);

    // Zones
    state.zones.forEach(z => {
        let m = m4.translation(z.x, z.y - 0.5, z.z);
        m = m4.multiply(m, [z.scale,0,0,0, 0,0.1,0,0, 0,0,z.scale,0, 0,0,0,1]);
        drawCube(m4.multiply(viewProj, m), z.color, false);
    });

    // Packages
    const hoveredParams = getLookedAtPackage();
    state.packages.forEach(p => {
        if (!p.active) return;
        let m = m4.translation(p.x, p.y, p.z);
        m = m4.multiply(m, m4.translation(0, Math.sin(now * 2 + p.id) * 0.1, 0));
        let highlight = (p === hoveredParams && !state.heldPackage);
        drawCube(m4.multiply(viewProj, m), p.color, highlight);
    });

    // Held Package
    if (state.heldPackage) {
        const fwd = getForwardVector();
        const hx = state.cam.x + fwd.x * 1.5;
        const hy = state.cam.y + fwd.y * 1.5 - 0.3;
        const hz = state.cam.z + fwd.z * 1.5;
        
        let m = m4.translation(hx, hy, hz);
        m = m4.multiply(m, m4.yRotation(state.cam.yaw));
        m = m4.multiply(m, m4.xRotation(state.cam.pitch));
        m = m4.multiply(m, [0.5,0,0,0, 0,0.5,0,0, 0,0,0.5,0, 0,0,0,1]); 
        drawCube(m4.multiply(viewProj, m), state.heldPackage.color, false);
    }

    requestAnimationFrame(render);
}

initGame();
requestAnimationFrame(render);
</script>
</body>
</html>

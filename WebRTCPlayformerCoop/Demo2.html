<!DOCTYPE html>
<html>
<head>
    <title>WebGL WebRTC Platformer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; color: white; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Panel Styling */
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; pointer-events: none; z-index: 10; }
        #connection-panel { pointer-events: auto; max-width: 400px; }
        
        /* Standard UI Buttons */
        .ui-btn { padding: 8px 12px; cursor: pointer; background: #4CAF50; border: none; color: white; border-radius: 4px; margin-right: 5px; font-size: 14px; }
        .ui-btn:disabled { background: #555; cursor: default; }
        
        textarea { width: 100%; height: 60px; margin: 5px 0; background: #333; color: #0f0; border: 1px solid #555; font-size: 10px; }
        h1 { margin: 0 0 10px 0; font-size: 18px; }
        .hidden { display: none; }
        .status { font-weight: bold; color: #ffeb3b; margin-bottom: 10px; }

        /* --- NEW: MOBILE TOUCH CONTROLS --- */
        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 100px;
            pointer-events: none; /* Let touches pass through empty areas */
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            touch-action: none;
            outline: none;
        }

        .touch-btn:active, .touch-btn.active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }
    </style>
</head>
<body>

<div id="ui">
    <h1>WebGL Co-op Platformer</h1>
    <div id="status" class="status">Mode: Offline (Single Player)</div>
    
    <div id="connection-panel">
        <p><b>Multiplayer Setup (No Server Required)</b></p>
        <button class="ui-btn" id="btnCreate" onclick="net.createOffer()">1. Host Game</button>
        <textarea id="localSdp" placeholder="Your Connection Code will appear here..." readonly></textarea>
        
        <p>Send the code above to a friend. Paste their code below:</p>
        <textarea id="remoteSdp" placeholder="Paste Remote Code here..."></textarea>
        
        <div style="margin-top:5px;">
            <button class="ui-btn" id="btnJoin" onclick="net.acceptOffer()">2. Join Game</button>
            <button class="ui-btn" id="btnConnect" onclick="net.acceptAnswer()" disabled>3. Connect (Host Only)</button>
        </div>
    </div>
    
    <div style="margin-top: 15px; font-size: 12px; color: #aaa;">
        <b>Controls:</b> Arrow Keys, WASD, or Touch Buttons below.<br>
        P1 (Host) is Red. P2 (Joiner) is Blue.
    </div>
</div>

<div id="touch-controls">
    <div class="control-group">
        <div class="touch-btn" id="t-left">←</div>
        <div class="touch-btn" id="t-right">→</div>
    </div>
    <div class="control-group">
        <div class="touch-btn" id="t-jump">↑</div>
    </div>
</div>

<canvas id="glcanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    uniform vec4 u_color;
    varying vec4 v_color;

    void main() {
        vec2 position = (a_position * u_scale) + u_translation;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);
        v_color = u_color;
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
</script>

<script>
/* =========================================
   1. WEBGL RENDERER
   ========================================= */
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) alert("WebGL not supported");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vsSource = document.getElementById("vs").text;
const fsSource = document.getElementById("fs").text;
const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);

const positionLoc = gl.getAttribLocation(program, "a_position");
const resLoc = gl.getUniformLocation(program, "u_resolution");
const transLoc = gl.getUniformLocation(program, "u_translation");
const scaleLoc = gl.getUniformLocation(program, "u_scale");
const colorLoc = gl.getUniformLocation(program, "u_color");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0,  1, 0,  0, 1,
    0, 1,  1, 0,  1, 1,
]), gl.STATIC_DRAW);

function drawRect(x, y, width, height, color) {
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionLoc);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    gl.uniform2f(resLoc, gl.canvas.width, gl.canvas.height);
    gl.uniform2f(transLoc, x, y);
    gl.uniform2f(scaleLoc, width, height);
    gl.uniform4f(colorLoc, color[0], color[1], color[2], 1);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/* =========================================
   2. GAME LOGIC
   ========================================= */
const GRAVITY = 0.6;
const JUMP_FORCE = -12;
const SPEED = 5;

const gameState = {
    players: [
        { id: 0, x: 100, y: 300, w: 40, h: 40, vx: 0, vy: 0, color: [1, 0.2, 0.2], grounded: false },
        { id: 1, x: 200, y: 300, w: 40, h: 40, vx: 0, vy: 0, color: [0.2, 0.5, 1], grounded: false }
    ],
    platforms: [
        { x: 0, y: 550, w: 2000, h: 50 },
        { x: 300, y: 400, w: 200, h: 20 },
        { x: 600, y: 300, w: 200, h: 20 },
        { x: 100, y: 200, w: 150, h: 20 }
    ]
};

const input = {
    local: { left: false, right: false, up: false },
    remote: { left: false, right: false, up: false }
};

function updatePhysics() {
    if (net.isClient && net.connected) return; 

    gameState.players.forEach((p, index) => {
        let keys = (index === 0) ? input.local : input.remote;
        if (net.isClient) return; 
        
        if (keys.left) p.vx = -SPEED;
        else if (keys.right) p.vx = SPEED;
        else p.vx = 0;

        if (keys.up && p.grounded) {
            p.vy = JUMP_FORCE;
            p.grounded = false;
        }

        p.vy += GRAVITY;
        p.x += p.vx;
        p.y += p.vy;

        p.grounded = false;
        gameState.platforms.forEach(plat => {
            if (p.x < plat.x + plat.w &&
                p.x + p.w > plat.x &&
                p.y < plat.y + plat.h &&
                p.y + p.h > plat.y) {
                
                if (p.vy > 0 && p.y + p.h - p.vy <= plat.y) {
                    p.y = plat.y - p.h;
                    p.vy = 0;
                    p.grounded = true;
                }
            }
        });
        
        if(p.y > 1000) { p.x = 100; p.y = 100; p.vy = 0; }
    });
}

/* =========================================
   3. NETWORKING
   ========================================= */
const net = {
    pc: null, dc: null, isHost: false, isClient: false, connected: false,

    setup: function() {
        const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        this.pc = new RTCPeerConnection(config);

        this.pc.onicecandidate = e => {
            if (e.candidate) console.log("New ICE candidate");
            else document.getElementById('localSdp').value = JSON.stringify(this.pc.localDescription);
        };

        this.pc.ondatachannel = e => {
            this.dc = e.channel;
            this.setupDataChannel();
        };
    },

    createOffer: function() {
        this.isHost = true;
        this.setup();
        this.dc = this.pc.createDataChannel("game");
        this.setupDataChannel();
        this.pc.createOffer().then(d => this.pc.setLocalDescription(d));
        
        document.getElementById('btnCreate').disabled = true;
        document.getElementById('btnJoin').disabled = true;
        document.getElementById('btnConnect').disabled = false;
        document.getElementById('status').innerText = "Status: Generating Host Code...";
    },

    acceptOffer: function() {
        this.isClient = true;
        this.setup();
        const offer = JSON.parse(document.getElementById('remoteSdp').value);
        this.pc.setRemoteDescription(offer)
            .then(() => this.pc.createAnswer())
            .then(d => this.pc.setLocalDescription(d));

        document.getElementById('btnCreate').disabled = true;
        document.getElementById('btnJoin').disabled = true;
        document.getElementById('status').innerText = "Status: Generating Join Code...";
    },

    acceptAnswer: function() {
        const answer = JSON.parse(document.getElementById('remoteSdp').value);
        this.pc.setRemoteDescription(answer);
    },

    setupDataChannel: function() {
        this.dc.onopen = () => {
            this.connected = true;
            document.getElementById('status').innerText = "Status: CONNECTED!";
            document.getElementById('connection-panel').classList.add('hidden');
        };
        this.dc.onmessage = e => {
            const data = JSON.parse(e.data);
            if (this.isHost && data.type === 'input') input.remote = data.keys;
            if (!this.isHost && data.type === 'state') {
                gameState.players[0] = data.p1;
                gameState.players[1] = data.p2;
            }
        };
    },

    send: function(data) {
        if (this.connected && this.dc.readyState === "open") {
            this.dc.send(JSON.stringify(data));
        }
    }
};

/* =========================================
   4. INPUT HANDLING (KEYBOARD & TOUCH)
   ========================================= */
// Keyboard
window.addEventListener('keydown', e => handleKey(e.code, true));
window.addEventListener('keyup', e => handleKey(e.code, false));

function handleKey(code, isDown) {
    if (code === "ArrowLeft" || code === "KeyA") input.local.left = isDown;
    if (code === "ArrowRight" || code === "KeyD") input.local.right = isDown;
    if (code === "ArrowUp" || code === "KeyW") input.local.up = isDown;
}

// Touch
function bindTouch(elementId, keyName) {
    const el = document.getElementById(elementId);
    
    // Helper to update input state
    const set = (active) => {
        input.local[keyName] = active;
        if(active) el.classList.add('active');
        else el.classList.remove('active');
    };

    // Touch Events (Prevent Default to stop scrolling/zooming)
    el.addEventListener('touchstart', (e) => { e.preventDefault(); set(true); });
    el.addEventListener('touchend', (e) => { e.preventDefault(); set(false); });
    // Handle sliding off the button
    el.addEventListener('touchcancel', (e) => { e.preventDefault(); set(false); });

    // Mouse Events (for testing on desktop)
    el.addEventListener('mousedown', (e) => { set(true); });
    el.addEventListener('mouseup', (e) => { set(false); });
    el.addEventListener('mouseleave', (e) => { set(false); });
}

bindTouch('t-left', 'left');
bindTouch('t-right', 'right');
bindTouch('t-jump', 'up');

/* =========================================
   5. MAIN LOOP
   ========================================= */
function loop() {
    if (net.isHost || !net.connected) updatePhysics();
    
    if (net.connected) {
        if (net.isHost) {
            net.send({ type: 'state', p1: gameState.players[0], p2: gameState.players[1] });
        } else {
            net.send({ type: 'input', keys: input.local });
        }
    }

    gl.clearColor(0.2, 0.2, 0.2, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gameState.platforms.forEach(p => drawRect(p.x, p.y, p.w, p.h, [0.5, 0.5, 0.5]));
    gameState.players.forEach(p => drawRect(p.x, p.y, p.w, p.h, p.color));

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>WebGL WebRTC Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; pointer-events: none; }
        #connection-panel { pointer-events: auto; max-width: 400px; }
        button { padding: 8px 12px; cursor: pointer; background: #4CAF50; border: none; color: white; border-radius: 4px; margin-right: 5px; }
        button:disabled { background: #555; cursor: default; }
        textarea { width: 100%; height: 60px; margin: 5px 0; background: #333; color: #0f0; border: 1px solid #555; font-size: 10px; }
        h1 { margin: 0 0 10px 0; font-size: 18px; }
        .hidden { display: none; }
        .status { font-weight: bold; color: #ffeb3b; margin-bottom: 10px; }
    </style>
</head>
<body>

<div id="ui">
    <h1>WebGL Co-op Platformer</h1>
    <div id="status" class="status">Mode: Offline (Single Player)</div>
    
    <div id="connection-panel">
        <p><b>Multiplayer Setup (No Server Required)</b></p>
        <button id="btnCreate" onclick="net.createOffer()">1. Host Game</button>
        <textarea id="localSdp" placeholder="Your Connection Code will appear here..." readonly></textarea>
        
        <p>Send the code above to a friend. Paste their code below:</p>
        <textarea id="remoteSdp" placeholder="Paste Remote Code here..."></textarea>
        
        <div style="margin-top:5px;">
            <button id="btnJoin" onclick="net.acceptOffer()">2. Join Game</button>
            <button id="btnConnect" onclick="net.acceptAnswer()" disabled>3. Connect (Host Only)</button>
        </div>
    </div>
    
    <div style="margin-top: 15px; font-size: 12px; color: #aaa;">
        <b>Controls:</b> Arrow Keys or WASD to move/jump.<br>
        P1 (Host) is Red. P2 (Joiner) is Blue.
    </div>
</div>

<canvas id="glcanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    uniform vec4 u_color;
    varying vec4 v_color;

    void main() {
        // Scale the unit quad, translate it, then convert to clip space
        vec2 position = (a_position * u_scale) + u_translation;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        
        gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);
        v_color = u_color;
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
</script>

<script>
/* =========================================
   1. WEBGL RENDERER
   ========================================= */
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) alert("WebGL not supported");

// Resize handling
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// Shader setup
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vsSource = document.getElementById("vs").text;
const fsSource = document.getElementById("fs").text;
const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);

// Locations
const positionLoc = gl.getAttribLocation(program, "a_position");
const resLoc = gl.getUniformLocation(program, "u_resolution");
const transLoc = gl.getUniformLocation(program, "u_translation");
const scaleLoc = gl.getUniformLocation(program, "u_scale");
const colorLoc = gl.getUniformLocation(program, "u_color");

// Buffers (A unit quad)
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0,  1, 0,  0, 1,
    0, 1,  1, 0,  1, 1,
]), gl.STATIC_DRAW);

function drawRect(x, y, width, height, color) {
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionLoc);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    gl.uniform2f(resLoc, gl.canvas.width, gl.canvas.height);
    gl.uniform2f(transLoc, x, y);
    gl.uniform2f(scaleLoc, width, height);
    gl.uniform4f(colorLoc, color[0], color[1], color[2], 1);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/* =========================================
   2. GAME LOGIC
   ========================================= */
const GRAVITY = 0.6;
const JUMP_FORCE = -12;
const SPEED = 5;

// Initial State
const gameState = {
    players: [
        { id: 0, x: 100, y: 300, w: 40, h: 40, vx: 0, vy: 0, color: [1, 0.2, 0.2], grounded: false }, // P1 Red
        { id: 1, x: 200, y: 300, w: 40, h: 40, vx: 0, vy: 0, color: [0.2, 0.5, 1], grounded: false }  // P2 Blue
    ],
    platforms: [
        { x: 0, y: 550, w: 2000, h: 50 },    // Ground
        { x: 300, y: 400, w: 200, h: 20 },   // Plat 1
        { x: 600, y: 300, w: 200, h: 20 },   // Plat 2
        { x: 100, y: 200, w: 150, h: 20 }    // Plat 3
    ]
};

const input = {
    local: { left: false, right: false, up: false },
    remote: { left: false, right: false, up: false } // Received from network
};

// Physics Engine
function updatePhysics() {
    // Only the Host updates physics for both players
    // If we are Client, we just wait for state updates, 
    // BUT for smooth prediction we will run logic on both and sync.
    // To keep it simple: Host is authoritative.
    
    if (net.isClient && net.connected) return; 

    // Loop through both players
    gameState.players.forEach((p, index) => {
        let keys = (index === 0) ? input.local : input.remote;
        
        // If I am client, P2 is local
        if (net.isClient) return; // Should not happen due to check above, but logically Host controls P1 with local keys, P2 with remote keys.
        
        // Apply Input
        if (keys.left) p.vx = -SPEED;
        else if (keys.right) p.vx = SPEED;
        else p.vx = 0;

        if (keys.up && p.grounded) {
            p.vy = JUMP_FORCE;
            p.grounded = false;
        }

        // Apply Gravity
        p.vy += GRAVITY;
        p.x += p.vx;
        p.y += p.vy;

        // Collisions
        p.grounded = false;
        gameState.platforms.forEach(plat => {
            if (p.x < plat.x + plat.w &&
                p.x + p.w > plat.x &&
                p.y < plat.y + plat.h &&
                p.y + p.h > plat.y) {
                
                // Simple collision resolution (mostly floor)
                if (p.vy > 0 && p.y + p.h - p.vy <= plat.y) {
                    p.y = plat.y - p.h;
                    p.vy = 0;
                    p.grounded = true;
                }
            }
        });
        
        // Bounds
        if(p.y > 1000) { p.x = 100; p.y = 100; p.vy = 0; } // Respawn
    });
}

/* =========================================
   3. NETWORKING (WebRTC / DataChannels)
   ========================================= */
const net = {
    pc: null,
    dc: null,
    isHost: false,
    isClient: false,
    connected: false,

    setup: function() {
        const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        this.pc = new RTCPeerConnection(config);

        this.pc.onicecandidate = e => {
            if (e.candidate) console.log("New ICE candidate"); // In a real app, send this. Here we wait for complete SDP.
            else {
                // All candidates gathered, SDP ready to copy
                document.getElementById('localSdp').value = JSON.stringify(this.pc.localDescription);
            }
        };

        this.pc.ondatachannel = e => {
            this.dc = e.channel;
            this.setupDataChannel();
        };
    },

    createOffer: function() {
        this.isHost = true;
        this.setup();
        this.dc = this.pc.createDataChannel("game");
        this.setupDataChannel();
        
        this.pc.createOffer().then(d => this.pc.setLocalDescription(d));
        
        document.getElementById('btnCreate').disabled = true;
        document.getElementById('btnJoin').disabled = true;
        document.getElementById('btnConnect').disabled = false;
        document.getElementById('status').innerText = "Status: Generating Host Code...";
    },

    acceptOffer: function() {
        this.isClient = true;
        this.setup();
        const offer = JSON.parse(document.getElementById('remoteSdp').value);
        
        this.pc.setRemoteDescription(offer)
            .then(() => this.pc.createAnswer())
            .then(d => this.pc.setLocalDescription(d));

        document.getElementById('btnCreate').disabled = true;
        document.getElementById('btnJoin').disabled = true;
        document.getElementById('status').innerText = "Status: Generating Join Code...";
    },

    acceptAnswer: function() {
        const answer = JSON.parse(document.getElementById('remoteSdp').value);
        this.pc.setRemoteDescription(answer);
    },

    setupDataChannel: function() {
        this.dc.onopen = () => {
            this.connected = true;
            document.getElementById('status').innerText = "Status: CONNECTED!";
            document.getElementById('connection-panel').classList.add('hidden');
        };
        
        this.dc.onmessage = e => {
            const data = JSON.parse(e.data);
            
            if (this.isHost) {
                // Host receives Input from Client (P2)
                if (data.type === 'input') {
                    input.remote = data.keys;
                }
            } else {
                // Client receives State from Host
                if (data.type === 'state') {
                    gameState.players[0] = data.p1;
                    gameState.players[1] = data.p2;
                }
            }
        };
    },

    send: function(data) {
        if (this.connected && this.dc.readyState === "open") {
            this.dc.send(JSON.stringify(data));
        }
    }
};

/* =========================================
   4. INPUT HANDLING
   ========================================= */
window.addEventListener('keydown', e => handleKey(e.code, true));
window.addEventListener('keyup', e => handleKey(e.code, false));

function handleKey(code, isDown) {
    // Map Arrows and WASD
    if (code === "ArrowLeft" || code === "KeyA") input.local.left = isDown;
    if (code === "ArrowRight" || code === "KeyD") input.local.right = isDown;
    if (code === "ArrowUp" || code === "KeyW") input.local.up = isDown;
}

/* =========================================
   5. MAIN LOOP
   ========================================= */
function loop() {
    // 1. Update Physics (Authoritative on Host, Simulated on Client?)
    // Simpler: Host runs physics, sends state. Client sends input.
    if (net.isHost || !net.connected) {
        updatePhysics();
    }
    
    // 2. Network Sync
    if (net.connected) {
        if (net.isHost) {
            // Send World State to Client
            net.send({
                type: 'state',
                p1: gameState.players[0],
                p2: gameState.players[1]
            });
        } else {
            // Send Input to Host
            net.send({
                type: 'input',
                keys: input.local
            });
        }
    }

    // 3. Render
    // Clear
    gl.clearColor(0.2, 0.2, 0.2, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Draw Platforms
    gameState.platforms.forEach(p => {
        drawRect(p.x, p.y, p.w, p.h, [0.5, 0.5, 0.5]);
    });

    // Draw Players
    const p1 = gameState.players[0];
    const p2 = gameState.players[1];
    
    // Draw P1 (Red)
    drawRect(p1.x, p1.y, p1.w, p1.h, p1.color);
    
    // Draw P2 (Blue)
    drawRect(p2.x, p2.y, p2.w, p2.h, p2.color);

    requestAnimationFrame(loop);
}

// Start
loop();

</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>WebGL 2D Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
/** * SHADER SOURCES
 */
const vsSource = `
    attribute vec2 aPosition;
    uniform vec2 uResolution;
    void main() {
        vec2 zeroToOne = aPosition / uResolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }`;

const fsSource = `
    precision mediump float;
    uniform vec4 uColor;
    void main() { gl_FragColor = uColor; }`;

// Post-processing: CRT Warp and Scanlines
const postVsSource = `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
        vTexCoord = aPosition * 0.5 + 0.5;
        gl_Position = vec4(aPosition, 0.0, 1.0);
    }`;

const postFsSource = `
    precision mediump float;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
        vec2 uv = vTexCoord;
        // Subtle CRT Curvature
        vec2 centered = uv - 0.5;
        float dist = dot(centered, centered);
        uv = uv + centered * dist * 0.05;

        vec4 color = texture2D(uTexture, uv);
        // Scanlines
        float scanline = sin(uv.y * 800.0) * 0.04;
        color.rgb -= scanline;
        
        // Vignette
        float vignette = 1.0 - dist * 0.5;
        gl_FragColor = vec4(color.rgb * vignette, 1.0);
    }`;

/**
 * GAME LOGIC
 */
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');

function createShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    return s;
}

function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, vs));
    gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    return p;
}

const mainProg = createProgram(gl, vsSource, fsSource);
const postProg = createProgram(gl, postVsSource, postFsSource);

const player = { x: 400, y: 300, w: 30, h: 30, vx: 0, vy: 0, grounded: false };
const platforms = [
    { x: 0, y: 550, w: 800, h: 50 }, // Ground
    { x: 100, y: 400, w: 150, h: 20 },
    { x: 350, y: 300, w: 150, h: 20 },
    { x: 550, y: 200, w: 150, h: 20 }
];

const keys = {};
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;

// Framebuffer Setup for Post-Processing
const targetTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, targetTexture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
const fb = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);

const posBuf = gl.createBuffer();

function drawRect(x, y, w, h, color) {
    gl.useProgram(mainProg);
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        x, y, x+w, y, x, y+h,
        x, y+h, x+w, y, x+w, y+h
    ]), gl.STATIC_DRAW);
    
    const posLoc = gl.getAttribLocation(mainProg, "aPosition");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    
    gl.uniform2f(gl.getUniformLocation(mainProg, "uResolution"), 800, 600);
    gl.uniform4fv(gl.getUniformLocation(mainProg, "uColor"), color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function update() {
    if (keys['ArrowLeft']) player.vx = -5;
    else if (keys['ArrowRight']) player.vx = 5;
    else player.vx *= 0.8;

    if (keys['Space'] && player.grounded) {
        player.vy = -12;
        player.grounded = false;
    }

    player.vy += 0.6; // Gravity
    player.x += player.vx;
    player.y += player.vy;

    player.grounded = false;
    platforms.forEach(p => {
        if (player.x < p.x + p.w && player.x + player.w > p.x &&
            player.y + player.h > p.y && player.y + player.h < p.y + p.vy + 5) {
            player.y = p.y - player.h;
            player.vy = 0;
            player.grounded = true;
        }
    });

    // Render Scene to Framebuffer
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.viewport(0, 0, 1024, 1024);
    gl.clearColor(0.1, 0.1, 0.15, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    platforms.forEach(p => drawRect(p.x, p.y, p.w, p.h, [0.2, 0.6, 0.4, 1]));
    drawRect(player.x, player.y, player.w, player.h, [0.9, 0.3, 0.3, 1]);

    // Render Framebuffer to Screen with Post-Processing
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.useProgram(postProg);
    
    const quadBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
    
    const pPosLoc = gl.getAttribLocation(postProg, "aPosition");
    gl.enableVertexAttribArray(pPosLoc);
    gl.vertexAttribPointer(pPosLoc, 2, gl.FLOAT, false, 0, 0);
    
    gl.bindTexture(gl.TEXTURE_2D, targetTexture);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(update);
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.onresize = resize;
resize();
update();
</script>
</body>
</html>

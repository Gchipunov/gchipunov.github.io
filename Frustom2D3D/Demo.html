<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 2D Platformer with 3D Projection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        canvas {
            display: block;
            background-color: #000;
            border: 2px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        #controls {
            margin-top: 16px;
            padding: 10px 20px;
            background-color: #2a2a2a;
            border-radius: 8px;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <h1>WebGL 2D Platformer</h1>
    <canvas id="glCanvas" width="1024" height="768"></canvas>
    <div id="controls">
        <strong>Controls:</strong> Arrow Keys (Left/Right) to Move, Spacebar to Jump
    </div>

    <script>
        // --- Main execution start ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                return;
            }

            // --- Shader Programs ---
            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                }
            `;

            // Fragment shader program
            const fsSource = `
                precision mediump float;
                uniform vec4 uColor;
                void main(void) {
                    gl_FragColor = uColor;
                }
            `;

            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    color: gl.getUniformLocation(shaderProgram, 'uColor'),
                },
            };

            // --- Buffer for a simple square ---
            const buffers = initBuffers(gl);

            // --- Game State ---
            const player = {
                x: 100, y: 500, width: 40, height: 40,
                vx: 0, vy: 0,
                onGround: false,
                color: [0.0, 0.8, 1.0, 1.0] // Cyan
            };

            const platforms = [
                { x: 0, y: 0, width: canvas.width, height: 20, color: [0.5, 1.0, 0.5, 1.0] }, // Floor
                { x: 200, y: 150, width: 200, height: 20, color: [0.5, 1.0, 0.5, 1.0] },
                { x: 500, y: 300, width: 250, height: 20, color: [0.5, 1.0, 0.5, 1.0] },
                { x: 150, y: 450, width: 180, height: 20, color: [0.5, 1.0, 0.5, 1.0] },
                { x: 700, y: 600, width: 200, height: 20, color: [1.0, 0.5, 0.5, 1.0] } // Red platform
            ];

            const keys = {};
            window.addEventListener('keydown', (e) => keys[e.code] = true);
            window.addEventListener('keyup', (e) => keys[e.code] = false);
            
            const gameSettings = {
                gravity: -0.5,
                jumpForce: 12,
                moveSpeed: 5,
                friction: 0.8
            };

            // --- Game Loop ---
            let lastTime = 0;
            function gameLoop(currentTime) {
                currentTime *= 0.001; // convert to seconds
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                update(player, platforms, keys, gameSettings);
                drawScene(gl, programInfo, buffers, player, platforms);

                requestAnimationFrame(gameLoop);
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Game Logic ---
        function update(player, platforms, keys, settings) {
             // Horizontal movement
            if (keys['ArrowLeft']) {
                player.vx = -settings.moveSpeed;
            } else if (keys['ArrowRight']) {
                player.vx = settings.moveSpeed;
            }
            
            // Apply friction
            player.vx *= settings.friction;

            // Jumping
            if (keys['Space'] && player.onGround) {
                player.vy = settings.jumpForce;
                player.onGround = false;
            }
            
            // Apply gravity
            player.vy += settings.gravity;

            // Update position
            player.x += player.vx;
            player.y += player.vy;
            
            // Collision detection
            player.onGround = false;
            for (const platform of platforms) {
                // Check if player is horizontally within the platform's bounds
                if (player.x < platform.x + platform.width && player.x + player.width > platform.x) {
                    // Check for vertical collision (falling onto the platform)
                    if (player.y > platform.y && player.y - player.vy < platform.y) {
                         // Check if the player was above the platform in the previous frame
                         const previousY = player.y - player.vy;
                         if (previousY >= platform.y + platform.height) {
                            player.y = platform.y + platform.height;
                            player.vy = 0;
                            player.onGround = true;
                            break; // Exit loop once grounded
                         }
                    }
                }
            }

            // World bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > 1024) player.x = 1024 - player.width;
            if (player.y < 0) { // Fell off the bottom
                player.x = 100;
                player.y = 500;
                player.vx = 0;
                player.vy = 0;
            }
        }

        // --- WebGL Drawing ---
        function drawScene(gl, programInfo, buffers, player, platforms) {
            gl.clearColor(0.1, 0.1, 0.15, 1.0); // Dark blue-grey background
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // --- Camera and Projection Setup (from C++ code) ---
            const screenWidth = gl.canvas.width;
            const screenHeight = gl.canvas.height;
            
            // Camera is positioned at (center of screen, Z)
            const eye = [screenWidth / 2.0, screenHeight / 2.0, screenHeight]; // A Z-distance equal to screen height is a good starting point
            // Camera looks at (center of screen, 0), which is "down the z-axis"
            const center = [screenWidth / 2.0, screenHeight / 2.0, 0.0];
            // Up vector is standard (0, 1, 0)
            const up = [0.0, 1.0, 0.0];

            const nearVal = 1.0;
            const farVal = 10000.0;

            // Calculate the frustum planes for the 1:1 mapping at z=0
            const top = nearVal * (screenHeight / 2.0) / eye[2];
            const right = nearVal * (screenWidth / 2.0) / eye[2];
            const bottom = -top;
            const left = -right;

            const projectionMatrix = createFrustumMatrix(left, right, bottom, top, nearVal, farVal);
            const viewMatrix = createLookAtMatrix(eye, center, up);
            
            // The model matrix will be different for each object, so we combine view and projection here.
            // But for this simple case, we'll just pass the view matrix and calculate model*view in the drawing loop.
            // This is slightly less efficient but clearer.
            
            gl.useProgram(programInfo.program);
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

            // --- Draw Platforms ---
            for (const platform of platforms) {
                drawObject(gl, programInfo, buffers, platform, viewMatrix);
            }

            // --- Draw Player ---
            drawObject(gl, programInfo, buffers, player, viewMatrix);
        }
        
        function drawObject(gl, programInfo, buffers, object, viewMatrix) {
            // Create a model matrix for this object
            const modelMatrix = mat4.create();
            // Translate to the object's position
            mat4.translate(modelMatrix, modelMatrix, [object.x, object.y, 0]);
            // Scale to the object's size
            mat4.scale(modelMatrix, modelMatrix, [object.width, object.height, 1]);

            // Create the final ModelView matrix
            const modelViewMatrix = mat4.create();
            mat4.multiply(modelViewMatrix, viewMatrix, modelMatrix);
            
            // Bind the square buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

            // Set uniforms
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
            gl.uniform4fv(programInfo.uniformLocations.color, object.color);
            
            // Draw the square
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }


        // --- WebGL Initialization Helpers ---
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            // A simple 1x1 square. We will scale and translate it using the model matrix.
            const positions = [
                0.0, 1.0, // Top-left
                0.0, 0.0, // Bottom-left
                1.0, 1.0, // Top-right
                1.0, 0.0, // Bottom-right
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return { position: positionBuffer };
        }

        // --- Matrix and Vector Math (Ported from C++) ---

        // Vector helpers
        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }

        function cross(out, a, b) {
            out[0] = a[1] * b[2] - a[2] * b[1];
            out[1] = a[2] * b[0] - a[0] * b[2];
            out[2] = a[0] * b[1] - a[1] * b[0];
            return out;
        }

        function normalize(out, v) {
            let len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
            if (len > 1e-6) {
                out[0] = v[0] / len;
                out[1] = v[1] / len;
                out[2] = v[2] / len;
            }
            return out;
        }

        /**
         * Creates a perspective projection matrix equivalent to the legacy glFrustum function.
         */
        function createFrustumMatrix(left, right, bottom, top, nearVal, farVal) {
            const m = new Float32Array(16);
            m[0] = (2.0 * nearVal) / (right - left);
            m[1] = 0.0;
            m[2] = 0.0;
            m[3] = 0.0;

            m[4] = 0.0;
            m[5] = (2.0 * nearVal) / (top - bottom);
            m[6] = 0.0;
            m[7] = 0.0;

            m[8] = (right + left) / (right - left);
            m[9] = (top + bottom) / (top - bottom);
            m[10] = -(farVal + nearVal) / (farVal - nearVal);
            m[11] = -1.0;

            m[12] = 0.0;
            m[13] = 0.0;
            m[14] = -(2.0 * farVal * nearVal) / (farVal - nearVal);
            m[15] = 0.0;
            return m;
        }

        /**
         * Creates a view matrix equivalent to the legacy gluLookAt function.
         */
        function createLookAtMatrix(eye, center, up) {
            const m = new Float32Array(16);
            let f = [], s = [], u = [];

            f[0] = center[0] - eye[0];
            f[1] = center[1] - eye[1];
            f[2] = center[2] - eye[2];
            normalize(f, f);

            cross(s, f, up);
            normalize(s, s);

            cross(u, s, f);

            m[0] = s[0];
            m[1] = u[0];
            m[2] = -f[0];
            m[3] = 0.0;

            m[4] = s[1];
            m[5] = u[1];
            m[6] = -f[1];
            m[7] = 0.0;

            m[8] = s[2];
            m[9] = u[2];
            m[10] = -f[2];
            m[11] = 0.0;

            m[12] = -dot(s, eye);
            m[13] = -dot(u, eye);
            m[14] = dot(f, eye);
            m[15] = 1.0;
            return m;
        }
        
        // A minimal mat4 library to handle matrix operations needed for the model matrix
        const mat4 = {
            create: function() {
                const out = new Float32Array(16);
                out[0] = 1; out[5] = 1; out[10] = 1; out[15] = 1;
                return out;
            },
            translate: function(out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    // Copy 'a' to 'out' and then apply translation
                    // ... implementation omitted for brevity as we use in-place
                }
                return out;
            },
            scale: function(out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                out[0] = a[0] * x;
                out[1] = a[1] * x;
                // ... continue for all elements
                out[4] = a[4] * y;
                out[5] = a[5] * y;
                // ...
                out[8] = a[8] * z;
                out[9] = a[9] * z;
                // ...
                return out;
            },
            multiply: function(out, a, b) {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                // ... complete multiplication for all 16 elements
                let b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
                let b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
                let b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
                let b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

                out[0] = b00 * a00 + b10 * a01 + b20 * a02 + b30 * a03;
                out[1] = b01 * a00 + b11 * a01 + b21 * a02 + b31 * a03;
                out[2] = b02 * a00 + b12 * a01 + b22 * a02 + b32 * a03;
                out[3] = b03 * a00 + b13 * a01 + b23 * a02 + b33 * a03;
                out[4] = b00 * a10 + b10 * a11 + b20 * a12 + b30 * a13;
                out[5] = b01 * a10 + b11 * a11 + b21 * a12 + b31 * a13;
                out[6] = b02 * a10 + b12 * a11 + b22 * a12 + b32 * a13;
                out[7] = b03 * a10 + b13 * a11 + b23 * a12 + b33 * a13;
                out[8] = b00 * a20 + b10 * a21 + b20 * a22 + b30 * a23;
                out[9] = b01 * a20 + b11 * a21 + b21 * a22 + b31 * a23;
                out[10] = b02 * a20 + b12 * a21 + b22 * a22 + b32 * a23;
                out[11] = b03 * a20 + b13 * a21 + b23 * a22 + b33 * a23;
                out[12] = b00 * a30 + b10 * a31 + b20 * a32 + b30 * a33;
                out[13] = b01 * a30 + b11 * a31 + b21 * a32 + b31 * a33;
                out[14] = b02 * a30 + b12 * a31 + b22 * a32 + b32 * a33;
                out[15] = b03 * a30 + b13 * a31 + b23 * a32 + b33 * a33;
                return out;
            }
        };

    </script>
</body>
</html>

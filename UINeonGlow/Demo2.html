<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CrimeWars - Shader UI</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
    </style>
</head>
<body>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- Shader Definitions ---
    const UI_VERTEX_SHADER = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const UI_FRAGMENT_SHADER = `
        uniform vec3 color;
        uniform float hover;
        uniform float time;
        varying vec2 vUv;
        void main() {
            // Neon border logic
            float border = 0.02;
            float isBorder = step(1.0 - border, vUv.x) + step(vUv.x, border) + step(1.0 - border, vUv.y) + step(vUv.y, border);
            
            // Pulse effect
            float pulse = (sin(time * 3.0) * 0.1 + 0.9) * hover;
            
            vec3 finalColor = color;
            if(isBorder > 0.0) {
                finalColor += vec3(0.0, 1.0, 0.8) * (0.5 + pulse);
            }
            
            float alpha = 0.8 + (hover * 0.2);
            gl_FragColor = vec4(finalColor + (hover * 0.2), alpha);
        }
    `;

    // --- Engine Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 1000);
    camera.position.z = 10;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let currentMenu = "MAIN_MENU";
    const uiGroups = {};
    let hoveredObject = null;

    // --- Custom Clipped Geometry ---
    function createClippedRect(w, h, notchSize) {
        const shape = new THREE.Shape();
        shape.moveTo(-w/2 + notchSize, h/2);
        shape.lineTo(w/2, h/2);
        shape.lineTo(w/2, -h/2 + notchSize);
        shape.lineTo(w/2 - notchSize, -h/2);
        shape.lineTo(-w/2, -h/2);
        shape.lineTo(-w/2, h/2 - notchSize);
        shape.closePath();
        return new THREE.ShapeGeometry(shape);
    }

    // --- UI Component Factory ---
    function createButton(text, x, y, width, height, color, onClick) {
        const group = new THREE.Group();
        
        const geometry = createClippedRect(width, height, 15);
        const material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(color) },
                hover: { value: 0.0 },
                time: { value: 0.0 }
            },
            vertexShader: UI_VERTEX_SHADER,
            fragmentShader: UI_FRAGMENT_SHADER,
            transparent: true
        });

        const mesh = new THREE.Mesh(geometry, material);
        
        // Text texture
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 512; canvas.height = 128;
        context.fillStyle = '#00ffcc';
        context.font = 'Bold 60px Courier New';
        context.textAlign = 'center';
        context.fillText(text.toUpperCase(), 256, 80);
        
        const texture = new THREE.CanvasTexture(canvas);
        const textMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(width * 0.8, height * 0.6), 
            new THREE.MeshBasicMaterial({ map: texture, transparent: true })
        );
        textMesh.position.z = 0.1;

        group.add(mesh, textMesh);
        group.position.set(x, y, 0);
        group.userData = { onClick, isButton: true, material: material };
        
        return group;
    }

    function createPanel(title, x, y, w, h) {
        const group = new THREE.Group();
        const bg = new THREE.Mesh(createClippedRect(w, h, 20), new THREE.MeshBasicMaterial({ color: 0x0a0a0a, transparent: true, opacity: 0.9 }));
        const line = new THREE.LineSegments(
            new THREE.EdgesGeometry(createClippedRect(w, h, 20)), 
            new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.3 })
        );
        group.add(bg, line);
        group.position.set(x, y, 0);
        return group;
    }

    // --- Menus ---
    function initMenus() {
        // MAIN MENU
        uiGroups["MAIN_MENU"] = new THREE.Group();
        uiGroups["MAIN_MENU"].add(createButton("Enter Zone", 0, 100, 350, 70, 0x111111, () => switchMenu("PLAY")));
        uiGroups["MAIN_MENU"].add(createButton("Inventory", 0, 10, 350, 70, 0x111111, () => switchMenu("INVENTORY")));
        uiGroups["MAIN_MENU"].add(createButton("Settings", 0, -80, 350, 70, 0x111111, () => switchMenu("SETTINGS")));
        uiGroups["MAIN_MENU"].add(createButton("Exit Game", 0, -170, 350, 70, 0x220000, () => switchMenu("QUIT_CONFIRM")));

        // INVENTORY (Sub-panels)
        uiGroups["INVENTORY"] = new THREE.Group();
        const stash = createPanel("STASH", -220, 0, 400, 500);
        stash.add(createButton("HEAVY ARMOR", 0, 150, 350, 60, 0x111111, () => {}));
        stash.add(createButton("MEDKIT x4", 0, 70, 350, 60, 0x111111, () => {}));
        
        const loadout = createPanel("LOADOUT", 220, 0, 400, 500);
        loadout.add(createButton("PRIMARY: M4A1", 0, 150, 350, 60, 0x002222, () => {}));

        uiGroups["INVENTORY"].add(stash, loadout);
        uiGroups["INVENTORY"].add(createButton("Return", 0, -320, 200, 50, 0x333333, () => switchMenu("MAIN_MENU")));

        // SETTINGS
        uiGroups["SETTINGS"] = new THREE.Group();
        const sPanel = createPanel("CONFIG", 0, 0, 500, 400);
        sPanel.add(createButton("GRAPHICS: ULTRA", 0, 80, 400, 60, 0x111111, () => {}));
        sPanel.add(createButton("AUDIO: 100%", 0, 0, 400, 60, 0x111111, () => {}));
        uiGroups["SETTINGS"].add(sPanel);
        uiGroups["SETTINGS"].add(createButton("Back", 0, -250, 200, 50, 0x333333, () => switchMenu("MAIN_MENU")));

        // QUIT CONFIRM
        uiGroups["QUIT_CONFIRM"] = new THREE.Group();
        const qPanel = createPanel("ABANDON MISSION?", 0, 0, 450, 200);
        qPanel.add(createButton("YES, QUIT", -100, -20, 180, 60, 0x440000, () => window.close()));
        qPanel.add(createButton("NO, STAY", 100, -20, 180, 60, 0x004400, () => switchMenu("MAIN_MENU")));
        uiGroups["QUIT_CONFIRM"].add(qPanel);

        Object.values(uiGroups).forEach(g => { g.visible = false; scene.add(g); });
        uiGroups[currentMenu].visible = true;
    }

    function switchMenu(key) {
        uiGroups[currentMenu].visible = false;
        currentMenu = key;
        uiGroups[currentMenu].visible = true;
    }

    // --- Input Handling ---
    window.addEventListener('mousemove', (e) => {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(uiGroups[currentMenu].children, true);

        // Reset previous hover
        if (hoveredObject) hoveredObject.userData.material.uniforms.hover.value = 0;
        hoveredObject = null;

        for (let intersect of intersects) {
            let obj = intersect.object;
            while(obj.parent && !obj.userData.isButton) obj = obj.parent;
            if (obj.userData.isButton) {
                hoveredObject = obj;
                obj.userData.material.uniforms.hover.value = 1.0;
                break;
            }
        }
    });

    window.addEventListener('mousedown', () => {
        if (hoveredObject && hoveredObject.userData.onClick) hoveredObject.userData.onClick();
    });

    // --- Render Loop ---
    function animate(t) {
        requestAnimationFrame(animate);
        
        // Update shader time for all buttons in current menu
        uiGroups[currentMenu].traverse((child) => {
            if (child.userData.isButton) {
                child.userData.material.uniforms.time.value = t / 1000;
            }
        });

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.left = window.innerWidth / -2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = window.innerHeight / -2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    initMenus();
    animate(0);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Quantum Wave Packet Visualizer</title>
    <style>
        body { margin: 0; background: #020205; color: #4af; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .overlay {
            position: absolute; top: 30px; left: 30px; pointer-events: none;
            border-left: 2px solid #4af; padding-left: 15px;
        }
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; font-size: 1.5rem; }
        .equation { font-family: serif; font-style: italic; font-size: 1.2rem; margin-top: 10px; color: #fff; }
    </style>
</head>
<body>
    <div class="overlay">
        <h1>3D GAUSSIAN WAVE PACKET</h1>
        <div class="equation">iħ ∂Ψ/∂t = -ħ²/2m ∇²Ψ</div>
        <p style="font-size: 0.8rem; opacity: 0.7;">$|\Psi(x,y,t)|^2$ Probability Density</p>
    </div>
    <canvas id="glCanvas"></canvas>

<script type="text/javascript">
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) { alert("WebGL2 required"); }

    const vsSource = `#version 300 es
        layout(location = 0) in vec2 aPos;
        uniform mat4 uProjection;
        uniform mat4 uView;
        uniform float uTime;
        out float vHeight;
        out vec2 vUV;

        void main() {
            float x = aPos.x;
            float y = aPos.y;
            
            // Time-dependent Wave Packet parameters
            float t = uTime * 0.8;
            float sigma = 0.6 + 0.2 * sin(t * 0.5); // Dispersion simulation
            float x0 = 1.5 * cos(t); // Particle motion X
            float y0 = 1.5 * sin(t); // Particle motion Y
            
            // 2D Gaussian Envelope
            float distSq = pow(x - x0, 2.0) + pow(y - y0, 2.0);
            float amplitude = exp(-distSq / (2.0 * pow(sigma, 2.0)));
            
            // Complex Phase oscillation (for visual texture)
            float phase = sin(10.0 * (x * cos(t) + y * sin(t)) - t * 5.0);
            float h = amplitude * (1.0 + 0.2 * phase);

            vHeight = h;
            vUV = aPos;
            gl_Position = uProjection * uView * vec4(x, h - 0.5, y, 1.0);
        }
    `;

    const fsSource = `#version 300 es
        precision highp float;
        in float vHeight;
        in vec2 vUV;
        out vec4 fragColor;

        void main() {
            // Create a glowing grid effect
            float grid = smoothstep(0.95, 1.0, max(sin(vUV.x * 40.0), sin(vUV.y * 40.0)));
            
            // Base blue color for the wave
            vec3 color = vec3(0.2, 0.5, 1.0) * vHeight;
            
            // Add wireframe highlights
            color += vec3(0.5, 0.8, 1.0) * grid * vHeight * 2.0;
            
            // Add a subtle floor grid
            float floorGrid = 0.05 * smoothstep(0.98, 1.0, max(sin(vUV.x * 20.0), sin(vUV.y * 20.0)));
            
            fragColor = vec4(color + floorGrid, 1.0);
        }
    `;

    // --- Shader Boilerplate ---
    function createShader(gl, type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        return s;
    }
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
    gl.linkProgram(program);

    // --- Grid Generation ---
    const size = 100;
    const verts = [];
    for(let i=0; i<=size; i++) {
        for(let j=0; j<=size; j++) {
            verts.push((i/size)*10 - 5, (j/size)*10 - 5);
        }
    }
    const indices = [];
    for(let i=0; i<size; i++) {
        for(let j=0; j<size; j++) {
            let row1 = i * (size + 1);
            let row2 = (i + 1) * (size + 1);
            indices.push(row1+j, row1+j+1, row2+j, row2+j, row1+j+1, row2+j+1);
        }
    }

    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    const ebo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    // --- Transformation Matrices ---
    function getProjection(aspect) {
        const fov = 45 * Math.PI / 180;
        const zNear = 0.1, zFar = 100.0;
        const f = 1.0 / Math.tan(fov / 2);
        return new Float32Array([
            f/aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (zFar+zNear)/(zNear-zFar), -1,
            0, 0, (2*zFar*zNear)/(zNear-zFar), 0
        ]);
    }

    function render(time) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.01, 0.01, 0.03, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        gl.useProgram(program);
        
        // Simple View Matrix (Camera angled down)
        const view = new Float32Array([
            1, 0, 0, 0,
            0, 0.7, 0.7, 0,
            0, -0.7, 0.7, 0,
            0, 0, -12, 1
        ]);

        gl.uniformMatrix4fv(gl.getUniformLocation(program, "uProjection"), false, getProjection(canvas.width/canvas.height));
        gl.uniformMatrix4fv(gl.getUniformLocation(program, "uView"), false, view);
        gl.uniform1f(gl.getUniformLocation(program, "uTime"), time * 0.001);

        gl.bindVertexArray(vao);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
</script>
</body>
</html>

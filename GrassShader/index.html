<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Godot Grass Port - WebGL</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2.0 is not supported by your browser.');
        }

        // =============================================================
        // VERTEX SHADER
        // Simply renders a full-screen quad
        // =============================================================
        const vsSource = `#version 300 es
        in vec4 a_position;
        void main() {
            gl_Position = a_position;
        }`;

        // =============================================================
        // FRAGMENT SHADER
        // This is your provided Shader code wrapped for WebGL 2.0
        // =============================================================
        const fsSource = `#version 300 es
        precision highp float;

        uniform vec3 iResolution;
        uniform float iTime;
        uniform vec4 iMouse; // xy = current pos, zw = click pos

        out vec4 fragColor;

        // --- PASTE STARTS HERE ---

        // =================================================================
        // PORT: Godot "Stylized Grass" to WebGL/Shadertoy
        // Original Concept: GDQuest
        // Port & Implementation: Ray-Triangle Intersection Grid Traversal
        // =================================================================

        // --- GODOT UNIFORM CONSTANTS ---
        const float wind_speed = 1.5; 
        const float wind_strength = 0.4;
        const float wind_texture_tile_size = 20.0;
        const float wind_vertical_strength = 0.3;
        const vec2  wind_horizontal_direction = vec2(1.0, 0.5);
        const float character_radius = 1.5;
        const float character_push_strength = 1.5;

        // --- MATH & NOISE HELPERS ---

        float hash21(vec2 p) {
            p = fract(p * vec2(233.34, 851.73));
            p += dot(p, p + 23.45);
            return fract(p.x * p.y);
        }

        vec2 hash22(vec2 p) {
            vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.xx+p3.yz)*p3.zy);
        }

        float noise(in vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(mix(hash21(i + vec2(0.0, 0.0)), 
                           hash21(i + vec2(1.0, 0.0)), u.x),
                       mix(hash21(i + vec2(0.0, 1.0)), 
                           hash21(i + vec2(1.0, 1.0)), u.x), u.y);
        }

        // --- INTERSECTION LOGIC ---

        float iTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out vec2 uv_hit) {
            vec3 v0v1 = v1 - v0;
            vec3 v0v2 = v2 - v0;
            vec3 pvec = cross(rd, v0v2);
            float det = dot(v0v1, pvec);

            if (abs(det) < 0.00001) return -1.0; 

            float invDet = 1.0 / det;
            vec3 tvec = ro - v0;
            float u = dot(tvec, pvec) * invDet;

            if (u < 0.0 || u > 1.0) return -1.0;

            vec3 qvec = cross(tvec, v0v1);
            float v = dot(rd, qvec) * invDet;

            if (v < 0.0 || u + v > 1.0) return -1.0;

            uv_hit = vec2(u, v);
            return dot(v0v2, qvec) * invDet;
        }

        // --- THE CORE LOGIC ---

        vec3 applyDeformation(vec3 current_vertex, vec3 world_pos_xz, vec3 char_pos) {
            
            // 1. WIND
            vec2 normalized_wind_direction = normalize(wind_horizontal_direction);
            vec2 world_uv = world_pos_xz.xz / wind_texture_tile_size + normalized_wind_direction * iTime * wind_speed;
            float wind_noise_intensity = (noise(world_uv) - 0.5); 
            vec2 vert_space_horizontal_dir = normalized_wind_direction; 
            
            vec3 bump_wind = vec3(
                wind_noise_intensity * vert_space_horizontal_dir.x,
                1.0 - wind_noise_intensity, 
                wind_noise_intensity * vert_space_horizontal_dir.y 
            );
            
            bump_wind = normalize(bump_wind);
            bump_wind *= vec3(wind_strength, wind_vertical_strength, wind_strength);
            vec3 final_pos = current_vertex + bump_wind;
            
            // 2. CHARACTER INTERACTION
            vec3 grass_pivot = vec3(world_pos_xz.x, 0.0, world_pos_xz.z);
            vec3 dir_to_character = char_pos - grass_pivot;
            float dist_to_char = length(dir_to_character);
            float falloff = 1.0 - smoothstep(0.0, 1.0, dist_to_char / character_radius);
            
            if(length(dir_to_character) > 0.001)
                dir_to_character = normalize(dir_to_character);
                
            final_pos += -dir_to_character * falloff * character_push_strength * 1.0;
            
            return final_pos;
        }

        // --- MAIN RENDERING ---

        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
            vec3 ro = vec3(0.0, 2.5, -4.0); 
            vec3 lookAt = vec3(0.0, 0.5, 1.0);
            vec3 f = normalize(lookAt - ro);
            vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));
            vec3 u = cross(f, r);
            vec3 rd = normalize(f + uv.x * r + uv.y * u);

            // Mouse Logic
            vec3 charPos = vec3(999.0); 
            if (iMouse.z > 0.0) {
                vec2 m_uv = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;
                vec3 m_rd = normalize(f + m_uv.x * r + m_uv.y * u);
                float t_mouse = -ro.y / m_rd.y;
                if (t_mouse > 0.0) charPos = ro + m_rd * t_mouse;
            }

            vec3 col = mix(vec3(0.5, 0.7, 0.9), vec3(0.1, 0.3, 0.6), uv.y * 0.5 + 0.5);
            float t_ground = -ro.y / rd.y;
            
            float t_min = 100.0;
            vec3 grass_col = vec3(0.0);
            bool hit = false;
            
            if (t_ground > 0.0) {
                vec3 floorPos = ro + rd * t_ground;
                vec3 dirt = vec3(0.1, 0.25, 0.1) * (0.8 + 0.2 * noise(floorPos.xz * 2.0));
                col = mix(col, dirt, exp(-t_ground * 0.05)); 
                t_min = t_ground; 

                float density = 6.0; 
                vec3 current_pos = ro + rd * max(0.0, (2.5 - ro.y)/rd.y); 
                vec2 p = floorPos.xz; 
                vec2 ray_step = normalize(rd.xz);
                
                vec2 mapPos = floor(floorPos.xz * density);
                
                for(int i=0; i<30; i++) {
                    vec2 cell = mapPos;
                    vec2 cell_seed = cell;
                    vec2 rand = hash22(cell_seed); 
                    
                    vec3 blade_base = vec3((cell.x + rand.x) / density, 0.0, (cell.y + rand.y) / density);
                    float h = 0.6 + rand.x * 0.4; 
                    float w = 0.05;               
                    
                    float angle = rand.y * 6.28;
                    vec3 right = vec3(cos(angle), 0.0, sin(angle)) * w;
                    
                    vec3 v_bl = blade_base - right; 
                    vec3 v_br = blade_base + right; 
                    vec3 v_tip = blade_base + vec3(0.0, h, 0.0); 
                    
                    v_tip = applyDeformation(v_tip, blade_base, charPos);
                    
                    vec2 uv_hit;
                    float t = iTriangle(ro, rd, v_bl, v_br, v_tip, uv_hit);
                    
                    if(t > 0.0 && t < t_min) {
                        t_min = t;
                        hit = true;
                        
                        float height_grad = uv_hit.y; 
                        vec3 bottom_col = vec3(0.05, 0.2, 0.05);
                        vec3 top_col = vec3(0.6, 0.9, 0.2); 
                        grass_col = mix(bottom_col, top_col, height_grad);
                        
                        vec3 n = normalize(cross(v_br - v_bl, v_tip - v_bl));
                        float diff = max(0.0, dot(n, vec3(0.5, 0.8, 0.2)));
                        grass_col *= (0.5 + 0.5*diff);
                    }
                    
                    vec3 prevPos = floorPos - rd * (float(i) * 0.4);
                    mapPos = floor(prevPos.xz * density);
                }
            }

            if(hit) {
                col = grass_col;
                col = mix(col, vec3(0.5, 0.7, 0.9), 1.0 - exp(-t_min * 0.15));
            }

            col = pow(col, vec3(0.4545));
            fragColor = vec4(col, 1.0);
        }

        // --- PASTE ENDS HERE ---

        void main() {
            mainImage(fragColor, gl_FragCoord.xy);
        }
        `;

        // =============================================================
        // JS / WEBGL GLUE CODE
        // =============================================================

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
        }

        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
        const iTimeLocation = gl.getUniformLocation(program, "iTime");
        const iMouseLocation = gl.getUniformLocation(program, "iMouse");

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Two triangles covering the screen
        const positions = [
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
             1.0,  1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // --- MOUSE HANDLING ---
        let mouseX = 0;
        let mouseY = 0;
        let mouseClick = 0; // 0 or 1

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            // Flip Y for Shader (0 at bottom)
            mouseY = canvas.height - (e.clientY - rect.top);
        });

        canvas.addEventListener('mousedown', () => { mouseClick = 1.0; });
        canvas.addEventListener('mouseup', () => { mouseClick = 0.0; });
        // Touch support
        canvas.addEventListener('touchstart', () => { mouseClick = 1.0; });
        canvas.addEventListener('touchend', () => { mouseClick = 0.0; });
        canvas.addEventListener('touchmove', (e) => {
             const rect = canvas.getBoundingClientRect();
             mouseX = e.touches[0].clientX - rect.left;
             mouseY = canvas.height - (e.touches[0].clientY - rect.top);
        });


        function render(time) {
            time *= 0.001; // Convert to seconds

            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform3f(iResolutionLocation, gl.canvas.width, gl.canvas.height, 1.0);
            gl.uniform1f(iTimeLocation, time);
            
            // iMouse: xy = pos, z = click state (positive = click)
            gl.uniform4f(iMouseLocation, mouseX, mouseY, mouseClick, 0.0);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
            }
        }

        requestAnimationFrame(render);

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer</title>
    <link href="./output.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a202c; /* Equivalent to Tailwind's bg-gray-900 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #e2e8f0; /* Equivalent to Tailwind's text-gray-300 */
        }
        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #87CEEB; /* Sky blue background */
            border-radius: 0.5rem;
        }
        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* Let touches pass through the container */
        }
        .touch-btn {
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
            pointer-events: auto; /* Buttons are touchable */
            transition: background-color 0.2s;
        }
        .touch-btn:active {
            background-color: rgba(255, 255, 255, 0.5);
        }
        #controls-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        /* Hide touch controls on larger screens */
        @media (min-width: 768px) {
            #touch-controls {
                display: none;
            }
        }
        /* Show touch controls on smaller screens */
        @media (max-width: 767px) {
            #controls-info {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="controls-info">
            <p><b>PC Controls:</b></p>
            <p>A/D or ←/→ to Move</p>
            <p>W, Space, or ↑ to Jump/Swim</p>
        </div>
        <div id="touch-controls">
            <div style="display: flex; gap: 20px;">
                <button id="left-btn" class="touch-btn">←</button>
                <button id="right-btn" class="touch-btn">→</button>
            </div>
            <button id="jump-btn" class="touch-btn">↑</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL2 is not supported by your browser.');
        }

        // --- Shader Definitions ---
        const vertexShaderSource = `#version 300 es
            precision mediump float;
            in vec2 a_position;
            uniform vec2 u_resolution;
            uniform mat3 u_transform;

            void main() {
                vec2 position = (u_transform * vec3(a_position, 1)).xy;
                vec2 zeroToOne = position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision mediump float;
            uniform vec4 u_color;
            out vec4 outColor;

            void main() {
                outColor = u_color;
            }
        `;
        
        const waterFragmentShaderSource = `#version 300 es
            precision mediump float;
            uniform vec4 u_color;
            uniform float u_time;
            uniform vec2 u_resolution;
            
            out vec4 outColor;

            void main() {
                // Simple wave effect on the water surface
                vec2 st = gl_FragCoord.xy / u_resolution.xy;
                float wave = sin(st.x * 30.0 + u_time * 2.5) * 0.02;
                outColor = u_color + vec4(0.0, 0.0, wave, 0.0);
            }
        `;

        // --- WebGL Helper Functions ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) return shader;
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            const success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) return program;
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        // --- Shader Programs ---
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const solidFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const waterFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, waterFragmentShaderSource);
        
        const solidProgram = createProgram(gl, vertexShader, solidFragmentShader);
        const waterProgram = createProgram(gl, vertexShader, waterFragmentShader);

        // --- Attribute and Uniform Locations ---
        const solidPositionAttributeLocation = gl.getAttribLocation(solidProgram, "a_position");
        const solidResolutionUniformLocation = gl.getUniformLocation(solidProgram, "u_resolution");
        const solidColorUniformLocation = gl.getUniformLocation(solidProgram, "u_color");
        const solidTransformUniformLocation = gl.getUniformLocation(solidProgram, "u_transform");

        const waterPositionAttributeLocation = gl.getAttribLocation(waterProgram, "a_position");
        const waterResolutionUniformLocation = gl.getUniformLocation(waterProgram, "u_resolution");
        const waterColorUniformLocation = gl.getUniformLocation(waterProgram, "u_color");
        const waterTransformUniformLocation = gl.getUniformLocation(waterProgram, "u_transform");
        const waterTimeUniformLocation = gl.getUniformLocation(waterProgram, "u_time");

        // --- Vertex Data ---
        // You can create a single VAO and buffer for both programs.
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // A simple 1x1 square
        const positions = [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // --- Game State and Constants ---
        const worldWidth = 800;
        const worldHeight = 450;
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const SWIM_FORCE = -0.4;
        const BUOYANCY = 0.6;
        const MAX_FALL_SPEED = 10;
        const MAX_SWIM_SPEED = 3;
        const PLAYER_SPEED = 5;
        const FRICTION = 0.8;
        const WATER_FRICTION = 0.9;

        const player = {
            x: 50, y: 300, width: 20, height: 30,
            vx: 0, vy: 0,
            onGround: false,
            isInWater: false
        };

        const platforms = [
            // Ground
            { x: 0, y: 420, width: worldWidth, height: 30, color: [0.3, 0.6, 0.2, 1] },
            // Floating platforms
            { x: 150, y: 350, width: 100, height: 20, color: [0.5, 0.3, 0.1, 1] },
            { x: 300, y: 280, width: 100, height: 20, color: [0.5, 0.3, 0.1, 1] },
            { x: 450, y: 210, width: 100, height: 20, color: [0.5, 0.3, 0.1, 1] },
        ];
        
        // U-shaped water pool definition
        const waterPool = {
            // Solid parts of the pool container
            solids: [
                { x: 550, y: 400, width: 200, height: 20, color: [0.5, 0.5, 0.5, 1] }, // bottom
                { x: 550, y: 300, width: 20, height: 100, color: [0.5, 0.5, 0.5, 1] },  // left wall
                { x: 730, y: 300, width: 20, height: 100, color: [0.5, 0.5, 0.5, 1] },  // right wall
            ],
            // The water body itself
            water: { x: 570, y: 300, width: 160, height: 100, color: [0.2, 0.5, 0.8, 0.7] }
        };
        platforms.push(...waterPool.solids);

        // --- Input Handling ---
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // Touch Controls
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const jumpBtn = document.getElementById('jump-btn');

        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowRight'] = false; });
        jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; });
        jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['Space'] = false; });


        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(currentTime) {
            currentTime *= 0.001; // convert to seconds
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            update(deltaTime);
            draw(currentTime);

            requestAnimationFrame(gameLoop);
        }

        // --- Update Function ---
        function update(deltaTime) {
            // --- Horizontal Movement ---
            player.vx *= player.isInWater ? WATER_FRICTION : FRICTION;

            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.vx = -PLAYER_SPEED;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.vx = PLAYER_SPEED;
            }
            player.x += player.vx;

            // --- Vertical Movement ---
            // Apply gravity or buoyancy
            if (player.isInWater) {
                player.vy += GRAVITY - BUOYANCY;
                player.vy = Math.max(player.vy, -MAX_SWIM_SPEED); // Clamp upward speed
            } else {
                player.vy += GRAVITY;
            }
            player.vy = Math.min(player.vy, MAX_FALL_SPEED); // Clamp fall speed

            // Jumping / Swimming
            if (keys['KeyW'] || keys['ArrowUp'] || keys['Space']) {
                if (player.onGround) {
                    player.vy = JUMP_FORCE;
                    player.onGround = false;
                } else if (player.isInWater) {
                    player.vy += SWIM_FORCE;
                }
            }
            
            player.y += player.vy;
            player.onGround = false;

            // --- Collision Detection ---
            // Check against all platforms
            platforms.forEach(platform => {
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {
                    
                    // Collision resolution
                    const overlapX = Math.min(player.x + player.width, platform.x + platform.width) - Math.max(player.x, platform.x);
                    const overlapY = Math.min(player.y + player.height, platform.y + platform.height) - Math.max(player.y, platform.y);

                    if (overlapY < overlapX) {
                        // Vertical collision
                        if (player.vy > 0 && player.y + player.height - overlapY < platform.y + 1) { // Coming from top
                            player.y -= overlapY;
                            player.vy = 0;
                            player.onGround = true;
                        } else if (player.vy < 0 && player.y + overlapY > platform.y + platform.height - 1) { // Coming from bottom
                            player.y += overlapY;
                            player.vy = 0;
                        }
                    } else {
                        // Horizontal collision
                        if (player.vx > 0) { // Moving right
                            player.x -= overlapX;
                        } else if (player.vx < 0) { // Moving left
                            player.x += overlapX;
                        }
                        player.vx = 0;
                    }
                }
            });

            // --- Water Physics ---
            const water = waterPool.water;
            if (player.x + player.width > water.x &&
                player.x < water.x + water.width &&
                player.y + player.height > water.y &&
                player.y < water.y + water.height) {
                player.isInWater = true;
            } else {
                player.isInWater = false;
            }
            
            // World bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > worldWidth) player.x = worldWidth - player.width;
            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            }
            // Reset if falls off bottom
            if (player.y > worldHeight) {
                player.x = 50;
                player.y = 300;
                player.vx = 0;
                player.vy = 0;
            }
        }

        // --- Drawing Function ---
        function draw(time) {
            // --- Resize and Clear ---
            const container = document.getElementById('game-container');
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
            }
            
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0.53, 0.81, 0.92, 1); // Sky blue
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


            // --- Draw Water First (so it's behind) ---
            gl.useProgram(waterProgram);
            gl.bindVertexArray(vao);
            // Re-enable attribute for the water program
            gl.enableVertexAttribArray(waterPositionAttributeLocation);
            gl.vertexAttribPointer(waterPositionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            gl.uniform2f(waterResolutionUniformLocation, worldWidth, worldHeight);
            gl.uniform1f(waterTimeUniformLocation, time);
            
            const water = waterPool.water;
            gl.uniform4fv(waterColorUniformLocation, water.color);
            let waterMatrix = m3.projection(gl.canvas.width, gl.canvas.height);
            waterMatrix = m3.translate(waterMatrix, water.x, water.y);
            waterMatrix = m3.scale(waterMatrix, water.width, water.height);
            gl.uniformMatrix3fv(waterTransformUniformLocation, false, waterMatrix);
            gl.drawArrays(gl.TRIANGLES, 0, 6);


            // --- Draw Solid Objects ---
            gl.useProgram(solidProgram);
            gl.bindVertexArray(vao);
            // Re-enable attribute for the solid program
            gl.enableVertexAttribArray(solidPositionAttributeLocation);
            gl.vertexAttribPointer(solidPositionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            
            gl.uniform2f(solidResolutionUniformLocation, worldWidth, worldHeight);
            
            // Draw platforms
            platforms.forEach(p => {
                gl.uniform4fv(solidColorUniformLocation, p.color);
                let matrix = m3.projection(gl.canvas.width, gl.canvas.height);
                matrix = m3.translate(matrix, p.x, p.y);
                matrix = m3.scale(matrix, p.width, p.height);
                gl.uniformMatrix3fv(solidTransformUniformLocation, false, matrix);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            });

            // Draw player
            gl.uniform4f(solidColorUniformLocation, 0.9, 0.2, 0.2, 1); // Player color
            let playerMatrix = m3.projection(gl.canvas.width, gl.canvas.height);
            playerMatrix = m3.translate(playerMatrix, player.x, player.y);
            playerMatrix = m3.scale(playerMatrix, player.width, player.height);
            gl.uniformMatrix3fv(solidTransformUniformLocation, false, playerMatrix);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // --- Matrix Math Helper ---
        const m3 = {
            projection: function(width, height) {
                return [
                    2 / width, 0, 0,
                    0, -2 / height, 0,
                    -1, 1, 1
                ];
            },
            translation: function(tx, ty) {
                return [ 1, 0, 0, 0, 1, 0, tx, ty, 1 ];
            },
            scaling: function(sx, sy) {
                return [ sx, 0, 0, 0, sy, 0, 0, 0, 1 ];
            },
            multiply: function(a, b) {
                const a00 = a[0 * 3 + 0]; const a01 = a[0 * 3 + 1]; const a02 = a[0 * 3 + 2];
                const a10 = a[1 * 3 + 0]; const a11 = a[1 * 3 + 1]; const a12 = a[1 * 3 + 2];
                const a20 = a[2 * 3 + 0]; const a21 = a[2 * 3 + 1]; const a22 = a[2 * 3 + 2];
                const b00 = b[0 * 3 + 0]; const b01 = b[0 * 3 + 1]; const b02 = b[0 * 3 + 2];
                const b10 = b[1 * 3 + 0]; const b11 = b[1 * 3 + 1]; const b12 = b[1 * 3 + 2];
                const b20 = b[2 * 3 + 0]; const b21 = b[2 * 3 + 1]; const b22 = b[2 * 3 + 2];
                return [
                    b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22,
                    b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22,
                    b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22,
                ];
            },
            translate: function(m, tx, ty) { return m3.multiply(m, m3.translation(tx, ty)); },
            scale: function(m, sx, sy) { return m3.multiply(m, m3.scaling(sx, sy)); },
        };

        // --- Start the game ---
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

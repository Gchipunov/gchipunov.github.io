<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Procedural Terrain + Quaternions</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #instructions {
            position: absolute; top: 10px; left: 10px;
            color: white; font-family: sans-serif; font-weight: bold;
            text-shadow: 1px 1px 2px black; pointer-events: none;
            user-select: none;
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;
        }

        /* --- Touch Control Styles --- */
        #controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 160px;
            height: 160px;
            user-select: none;
            -webkit-user-select: none;
        }

        .btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.95); }

        #btn-up { top: 0; left: 55px; }
        #btn-down { bottom: 0; left: 55px; }
        #btn-left { top: 55px; left: 0; }
        #btn-right { top: 55px; right: 0; }

        /* Left side label for swipe zone */
        #swipe-hint {
            position: absolute; bottom: 30px; left: 30px;
            color: rgba(255,255,255,0.7); font-family: sans-serif;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <b>Controls:</b><br>
        • Drag Screen to <b>Look</b> (Quaternion)<br>
        • Buttons to <b>Move</b>
    </div>
    
    <div id="swipe-hint">Swipe area to Look</div>

    <canvas id="glCanvas"></canvas>

    <div id="controls">
        <div id="btn-up" class="btn">↑</div>
        <div id="btn-left" class="btn">←</div>
        <div id="btn-right" class="btn">→</div>
        <div id="btn-down" class="btn">↓</div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec3 aNormal;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uNormalMatrix;
        uniform float uTime;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vHeight;

        void main() {
            vec3 pos = aPosition;
            
            // Water wave effect
            if (pos.y <= -1.9) {
                pos.y += sin(pos.x * 5.0 + uTime) * 0.05 + cos(pos.z * 5.0 + uTime) * 0.05;
            }

            vPosition = pos;
            vHeight = aPosition.y;
            
            vNormal = mat3(uNormalMatrix) * aNormal;

            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(pos, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vHeight;

        const vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
        const vec3 ambientColor = vec3(0.2, 0.2, 0.2);
        const vec3 sunColor = vec3(1.0, 1.0, 0.9);

        void main() {
            vec3 normal = normalize(vNormal);
            float diff = max(dot(normal, lightDir), 0.0);
            
            vec3 waterColor = vec3(0.0, 0.4, 0.8);
            vec3 sandColor  = vec3(0.9, 0.85, 0.6);
            vec3 grassColor = vec3(0.1, 0.6, 0.1);
            vec3 rockColor  = vec3(0.5, 0.5, 0.5);

            vec3 baseColor;

            if (vHeight < -1.8) {
                baseColor = waterColor;
                vec3 viewDir = normalize(-vPosition);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                baseColor += spec * 0.5; 
            } else if (vHeight < -1.2) {
                float t = smoothstep(-1.8, -1.2, vHeight);
                baseColor = mix(sandColor, sandColor * 1.1, t);
            } else if (vHeight < 1.5) {
                float t = smoothstep(-1.2, -0.5, vHeight);
                baseColor = mix(sandColor, grassColor, t);
            } else {
                float t = smoothstep(1.5, 2.5, vHeight);
                baseColor = mix(grassColor, rockColor, t);
            }

            gl_FragColor = vec4(baseColor * (ambientColor + sunColor * diff), 1.0);
        }
    </script>

    <script>
        // --- 1. SETUP WEBGL ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) alert('WebGL not supported');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 2. SHADER HELPERS ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text));
        gl.linkProgram(program);

        // --- 3. MATH LIBRARY (Quaternions included) ---
        const Mat4 = {
            perspective: (fov, aspect, near, far) => {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                return [
                    f/aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far+near)*nf, -1,
                    0, 0, (2*far*near)*nf, 0
                ];
            },
            multiply: (a, b) => {
                let res = new Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) sum += a[i * 4 + k] * b[k * 4 + j];
                        res[i * 4 + j] = sum;
                    }
                }
                return res;
            },
            translate: (v) => [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                v[0], v[1], v[2], 1
            ],
            // Convert Quaternion to Rotation Matrix
            fromQuat: (q) => {
                const x = q[0], y = q[1], z = q[2], w = q[3];
                const x2 = x + x, y2 = y + y, z2 = z + z;
                const xx = x * x2, xy = x * y2, xz = x * z2;
                const yy = y * y2, yz = y * z2, zz = z * z2;
                const wx = w * x2, wy = w * y2, wz = w * z2;
                return [
                    1-(yy+zz), xy+wz, xz-wy, 0,
                    xy-wz, 1-(xx+zz), yz+wx, 0,
                    xz+wy, yz-wx, 1-(xx+yy), 0,
                    0, 0, 0, 1
                ];
            }
        };

        const Quat = {
            create: () => [0, 0, 0, 1],
            setAxisAngle: (axis, rad) => {
                rad = rad * 0.5;
                const s = Math.sin(rad);
                return [s * axis[0], s * axis[1], s * axis[2], Math.cos(rad)];
            },
            multiply: (a, b) => {
                const ax = a[0], ay = a[1], az = a[2], aw = a[3];
                const bx = b[0], by = b[1], bz = b[2], bw = b[3];
                return [
                    ax*bw + aw*bx + ay*bz - az*by,
                    ay*bw + aw*by + az*bx - ax*bz,
                    az*bw + aw*bz + ax*by - ay*bx,
                    aw*bw - ax*bx - ay*by - az*bz
                ];
            },
            normalize: (q) => {
                let len = Math.sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
                if (len > 0) {
                    len = 1 / len;
                    q[0] *= len; q[1] *= len; q[2] *= len; q[3] *= len;
                }
                return q;
            },
            // For camera movement: rotate vector by quat
            transformVec3: (q, v) => {
                const x = v[0], y = v[1], z = v[2];
                const qx = q[0], qy = q[1], qz = q[2], qw = q[3];
                
                // Calculate quat * vec
                const ix = qw * x + qy * z - qz * y;
                const iy = qw * y + qz * x - qx * z;
                const iz = qw * z + qx * y - qy * x;
                const iw = -qx * x - qy * y - qz * z;

                // Calculate result * inverse quat
                return [
                    ix * qw + iw * -qx + iy * -qz - iz * -qy,
                    iy * qw + iw * -qy + iz * -qx - ix * -qz,
                    iz * qw + iw * -qz + ix * -qy - iy * -qx
                ];
            }
        };

        // --- 4. TERRAIN GEN ---
        const size = 60, div = 80; 
        const positions = [], indices = [], normals = [];

        function getHeight(x, z) {
            let y = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2.0;
            y += Math.sin(x * 0.3 + z * 0.2) * 1.0;
            if (y < -2.0) return -2.0;
            return y;
        }

        // Generate Grid
        for(let z = 0; z <= div; z++) {
            for(let x = 0; x <= div; x++) {
                let xx = (x/div)*size - size/2;
                let zz = (z/div)*size - size/2;
                positions.push(xx, getHeight(xx, zz), zz);
            }
        }
        
        // Normals
        for(let z = 0; z <= div; z++) {
            for(let x = 0; x <= div; x++) {
                let d = 0.1;
                let xx = (x/div)*size - size/2;
                let zz = (z/div)*size - size/2;
                let hL = getHeight(xx-d, zz), hR = getHeight(xx+d, zz);
                let hD = getHeight(xx, zz-d), hU = getHeight(xx, zz+d);
                let nx = hL - hR, ny = 2.0 * d, nz = hD - hU; 
                let len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                normals.push(nx/len, ny/len, nz/len);
            }
        }

        // Indices
        for(let z = 0; z < div; z++) {
            for(let x = 0; x < div; x++) {
                let row1 = z*(div+1), row2 = (z+1)*(div+1);
                indices.push(row1+x, row2+x, row1+x+1, row1+x+1, row2+x, row2+x+1);
            }
        }

        // Buffers
        const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        const normBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
        const idxBuf = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        const locs = {
            pos: gl.getAttribLocation(program, 'aPosition'),
            norm: gl.getAttribLocation(program, 'aNormal'),
            mv: gl.getUniformLocation(program, 'uModelViewMatrix'),
            proj: gl.getUniformLocation(program, 'uProjectionMatrix'),
            nMat: gl.getUniformLocation(program, 'uNormalMatrix'),
            time: gl.getUniformLocation(program, 'uTime')
        };
        gl.enableVertexAttribArray(locs.pos);
        gl.enableVertexAttribArray(locs.norm);

        // --- 5. CAMERA & CONTROLS ---
        
        // State
        let camPos = [0, 5, 20];
        let camRot = Quat.create(); // World Rotation of Camera
        
        // Button State
        const keys = { up: false, down: false, left: false, right: false };
        function bindBtn(id, k) {
            const b = document.getElementById(id);
            const s = (e) => { e.preventDefault(); keys[k] = true; };
            const e = (e) => { e.preventDefault(); keys[k] = false; };
            b.addEventListener('mousedown', s); b.addEventListener('touchstart', s);
            b.addEventListener('mouseup', e); b.addEventListener('touchend', e);
            b.addEventListener('mouseleave', e);
        }
        bindBtn('btn-up', 'up'); bindBtn('btn-down', 'down');
        bindBtn('btn-left', 'left'); bindBtn('btn-right', 'right');

        // Touch/Mouse Look (Quaternion Logic)
        let isDragging = false, lastX, lastY;
        const startLook = (x, y) => { isDragging = true; lastX = x; lastY = y; };
        const endLook = () => { isDragging = false; };
        const moveLook = (x, y) => {
            if (!isDragging) return;
            const dx = (x - lastX) * 0.005;
            const dy = (y - lastY) * 0.005;
            
            // Quaternion Hot Tip:
            // 1. Create rot around World Y (Yaw)
            // 2. Create rot around Local X (Pitch)
            
            const qYaw = Quat.setAxisAngle([0, 1, 0], -dx); // Invert for natural feel
            const qPitch = Quat.setAxisAngle([1, 0, 0], -dy);

            // Apply Yaw Globally: New = Yaw * Old
            camRot = Quat.multiply(qYaw, camRot);
            
            // Apply Pitch Locally: New = Old * Pitch
            camRot = Quat.multiply(camRot, qPitch);
            
            Quat.normalize(camRot);
            
            lastX = x; lastY = y;
        };

        canvas.addEventListener('mousedown', e => startLook(e.clientX, e.clientY));
        window.addEventListener('mouseup', endLook);
        window.addEventListener('mousemove', e => moveLook(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', e => { if(e.touches.length==1) startLook(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
        window.addEventListener('touchend', endLook);
        window.addEventListener('touchmove', e => { if(e.touches.length==1) { e.preventDefault(); moveLook(e.touches[0].clientX, e.touches[0].clientY); }}, {passive:false});

        // --- 6. RENDER LOOP ---
        function render(time) {
            time *= 0.001;
            
            // --- Movement Logic ---
            const speed = 0.2;
            const forward = Quat.transformVec3(camRot, [0, 0, -1]); // Get forward vector from quat
            const right = Quat.transformVec3(camRot, [1, 0, 0]);    // Get right vector from quat

            // Flatten vectors for walking (optional, keeps us from flying into sky)
            // forward[1] = 0; right[1] = 0; 
            
            if (keys.up) { camPos[0]+=forward[0]*speed; camPos[1]+=forward[1]*speed; camPos[2]+=forward[2]*speed; }
            if (keys.down) { camPos[0]-=forward[0]*speed; camPos[1]-=forward[1]*speed; camPos[2]-=forward[2]*speed; }
            if (keys.right) { camPos[0]+=right[0]*speed; camPos[1]+=right[1]*speed; camPos[2]+=right[2]*speed; }
            if (keys.left) { camPos[0]-=right[0]*speed; camPos[1]-=right[1]*speed; camPos[2]-=right[2]*speed; }

            gl.useProgram(program);
            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(0.53, 0.81, 0.92, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Calc Matrices
            const proj = Mat4.perspective(45 * Math.PI/180, canvas.width/canvas.height, 0.1, 100.0);
            
            // ModelView = Inverse(CameraMatrix)
            // View = Inv(Rot) * Inv(Trans)
            // For Unit Quat, Inv(Q) = Conjugate([-x,-y,-z,w])
            
            const invRotQ = [-camRot[0], -camRot[1], -camRot[2], camRot[3]];
            const rotMat = Mat4.fromQuat(invRotQ);
            const transMat = Mat4.translate([-camPos[0], -camPos[1], -camPos[2]]);
            
            const mvMat = Mat4.multiply(rotMat, transMat);

            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.vertexAttribPointer(locs.pos, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, normBuf);
            gl.vertexAttribPointer(locs.norm, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);

            gl.uniformMatrix4fv(locs.proj, false, new Float32Array(proj));
            gl.uniformMatrix4fv(locs.mv, false, new Float32Array(mvMat));
            gl.uniformMatrix4fv(locs.nMat, false, new Float32Array(mvMat)); // Using MV for normals is okay for uniform scale
            gl.uniform1f(locs.time, time);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>

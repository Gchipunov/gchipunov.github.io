<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Procedural Terrain</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; /* Prevent scroll on mobile */ }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #instructions {
            position: absolute; top: 10px; left: 10px;
            color: white; font-family: sans-serif; font-weight: bold;
            text-shadow: 1px 1px 2px black; pointer-events: none;
            user-select: none;
        }

        /* --- Touch Control Styles --- */
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            user-select: none;
            -webkit-user-select: none;
        }

        .btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            -webkit-tap-highlight-color: transparent;
        }

        .btn:active { background: rgba(255, 255, 255, 0.6); }

        #btn-up { top: 0; left: 50px; }
        #btn-down { bottom: 0; left: 50px; }
        #btn-left { top: 50px; left: 0; }
        #btn-right { top: 50px; right: 0; }

        /* Hide buttons on large screens if desired, but keeping them for now */
    </style>
</head>
<body>
    <div id="instructions">Procedural Terrain<br>Drag or use Buttons to Rotate</div>
    
    <canvas id="glCanvas"></canvas>

    <div id="controls">
        <div id="btn-up" class="btn">↑</div>
        <div id="btn-left" class="btn">←</div>
        <div id="btn-right" class="btn">→</div>
        <div id="btn-down" class="btn">↓</div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec3 aNormal;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uNormalMatrix;
        uniform float uTime;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vHeight;

        void main() {
            vec3 pos = aPosition;
            
            // Simple water wave effect if height is at water level
            if (pos.y <= -1.9) {
                pos.y += sin(pos.x * 5.0 + uTime) * 0.05 + cos(pos.z * 5.0 + uTime) * 0.05;
            }

            vPosition = pos;
            vHeight = aPosition.y;
            
            // Transform normal
            vNormal = mat3(uNormalMatrix) * aNormal;

            gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(pos, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying float vHeight;

        // Light direction (fixed sun)
        const vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
        const vec3 ambientColor = vec3(0.2, 0.2, 0.2);
        const vec3 sunColor = vec3(1.0, 1.0, 0.9);

        void main() {
            vec3 normal = normalize(vNormal);
            
            // Calculate Diffuse Lighting (Lambert)
            float diff = max(dot(normal, lightDir), 0.0);
            
            // Define biome colors
            vec3 waterColor = vec3(0.0, 0.4, 0.8);
            vec3 sandColor  = vec3(0.9, 0.85, 0.6);
            vec3 grassColor = vec3(0.1, 0.6, 0.1);
            vec3 rockColor  = vec3(0.5, 0.5, 0.5);

            vec3 baseColor;

            // Biome Blending Logic
            if (vHeight < -1.8) {
                baseColor = waterColor;
                // Add specular highlight for water
                vec3 viewDir = normalize(-vPosition);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                baseColor += spec * 0.5; 
            } else if (vHeight < -1.2) {
                // Blend Water to Sand
                float t = smoothstep(-1.8, -1.2, vHeight);
                baseColor = mix(sandColor, sandColor * 1.1, t);
            } else if (vHeight < 1.5) {
                // Blend Sand to Grass
                float t = smoothstep(-1.2, -0.5, vHeight);
                baseColor = mix(sandColor, grassColor, t);
            } else {
                // Grass to Rock
                float t = smoothstep(1.5, 2.5, vHeight);
                baseColor = mix(grassColor, rockColor, t);
            }

            // Apply Light
            vec3 finalColor = baseColor * (ambientColor + sunColor * diff);

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // --- 1. SETUP WEBGL ---
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) { alert('WebGL not supported'); }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 2. SHADER HELPERS ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vsSource = document.getElementById('vertex-shader').text;
        const fsSource = document.getElementById('fragment-shader').text;
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // --- 3. MATH LIBRARY ---
        const Mat4 = {
            perspective: function(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                return [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, (2 * far * near) * nf, 0
                ];
            },
            identity: function() {
                return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            },
            rotateY: function(m, angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const mv0 = m[0], mv2 = m[2], mv8 = m[8], mv10 = m[10];
                const res = [...m];
                res[0] = c * mv0 + s * mv2;
                res[2] = c * mv2 - s * mv0;
                res[8] = c * mv8 + s * mv10;
                res[10] = c * mv10 - s * mv8;
                return res;
            },
            rotateX: function(m, angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const mv4 = m[4], mv5 = m[5], mv6 = m[6], mv7 = m[7];
                const mv8 = m[8], mv9 = m[9], mv10 = m[10], mv11 = m[11];
                const res = [...m];
                res[4] = c * mv4 + s * mv8;
                res[5] = c * mv5 + s * mv9;
                res[6] = c * mv6 + s * mv10;
                res[7] = c * mv7 + s * mv11;
                res[8] = c * mv8 - s * mv4;
                res[9] = c * mv9 - s * mv5;
                res[10] = c * mv10 - s * mv6;
                res[11] = c * mv11 - s * mv7;
                return res;
            },
            translate: function(m, x, y, z) {
                const res = [...m];
                res[12] = m[0] * x + m[4] * y + m[8] * z + m[12];
                res[13] = m[1] * x + m[5] * y + m[9] * z + m[13];
                res[14] = m[2] * x + m[6] * y + m[10] * z + m[14];
                res[15] = m[3] * x + m[7] * y + m[11] * z + m[15];
                return res;
            }
        };

        // --- 4. TERRAIN GENERATION ---
        const size = 60; 
        const div = 80; 
        const positions = [];
        const indices = [];
        const normals = [];

        function getHeight(x, z) {
            let y = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2.0;
            y += Math.sin(x * 0.3 + z * 0.2) * 1.0;
            y += Math.sin(x * 0.5 - z * 0.4) * 0.5;
            if (y < -2.0) return -2.0;
            return y;
        }

        for(let z = 0; z <= div; z++) {
            for(let x = 0; x <= div; x++) {
                const xPos = (x / div) * size - size / 2;
                const zPos = (z / div) * size - size / 2;
                const yPos = getHeight(xPos, zPos);
                positions.push(xPos, yPos, zPos);
            }
        }

        for(let z = 0; z <= div; z++) {
            for(let x = 0; x <= div; x++) {
                const d = 0.1;
                const hL = getHeight(((x / div) * size - size / 2) - d, (z / div) * size - size / 2);
                const hR = getHeight(((x / div) * size - size / 2) + d, (z / div) * size - size / 2);
                const hD = getHeight((x / div) * size - size / 2, ((z / div) * size - size / 2) - d);
                const hU = getHeight((x / div) * size - size / 2, ((z / div) * size - size / 2) + d);
                
                const vHorizontal = [2 * d, hR - hL, 0];
                const vVertical = [0, hU - hD, 2 * d];
                
                let nx = vVertical[1] * vHorizontal[2] - vVertical[2] * vHorizontal[1];
                let ny = vVertical[2] * vHorizontal[0] - vVertical[0] * vHorizontal[2];
                let nz = vVertical[0] * vHorizontal[1] - vVertical[1] * vHorizontal[0];
                
                const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                normals.push(nx/len, ny/len, nz/len);
            }
        }

        for(let z = 0; z < div; z++) {
            for(let x = 0; x < div; x++) {
                const row1 = z * (div + 1);
                const row2 = (z + 1) * (div + 1);
                indices.push(row1 + x, row2 + x, row1 + x + 1);
                indices.push(row1 + x + 1, row2 + x, row2 + x + 1);
            }
        }

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aNormal = gl.getAttribLocation(program, 'aNormal');
        const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
        const uNormalMatrix = gl.getUniformLocation(program, 'uNormalMatrix');
        const uTime = gl.getUniformLocation(program, 'uTime');

        gl.enableVertexAttribArray(aPosition);
        gl.enableVertexAttribArray(aNormal);

        // --- 5. CONTROLS (TOUCH + BUTTONS) ---
        let rotationX = 0.5;
        let rotationY = 0;
        
        // Track state of buttons
        const keys = { up: false, down: false, left: false, right: false };

        // Helper to bind touch/mouse events to buttons
        function bindButton(id, key) {
            const btn = document.getElementById(id);
            const start = (e) => { e.preventDefault(); keys[key] = true; };
            const end = (e) => { e.preventDefault(); keys[key] = false; };
            
            btn.addEventListener('mousedown', start);
            btn.addEventListener('touchstart', start);
            btn.addEventListener('mouseup', end);
            btn.addEventListener('touchend', end);
            btn.addEventListener('mouseleave', end);
        }

        bindButton('btn-up', 'up');
        bindButton('btn-down', 'down');
        bindButton('btn-left', 'left');
        bindButton('btn-right', 'right');

        // Canvas Swipe Logic
        let isDragging = false;
        let lastX, lastY;

        const handleStart = (x, y) => { isDragging = true; lastX = x; lastY = y; };
        const handleEnd = () => { isDragging = false; };
        const handleMove = (x, y) => {
            if (!isDragging) return;
            const dx = x - lastX;
            const dy = y - lastY;
            rotationY += dx * 0.005;
            rotationX += dy * 0.005;
            lastX = x;
            lastY = y;
        };

        // Mouse Listeners
        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));

        // Touch Listeners (for swiping on canvas)
        canvas.addEventListener('touchstart', e => {
            if(e.touches.length === 1) handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('touchmove', e => {
            if(e.touches.length === 1) {
                e.preventDefault(); // prevent scrolling
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});


        // --- 6. RENDER LOOP ---
        function render(time) {
            time *= 0.001; 

            // Apply Button Controls
            const speed = 0.02;
            if(keys.up) rotationX -= speed;
            if(keys.down) rotationX += speed;
            if(keys.left) rotationY -= speed;
            if(keys.right) rotationY += speed;

            // Clamp rotationX (optional, prevents flipping over)
            // rotationX = Math.max(0.1, Math.min(Math.PI / 2, rotationX));

            gl.useProgram(program);
            
            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(0.53, 0.81, 0.92, 1.0); 
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const fov = 45 * Math.PI / 180;
            const aspect = canvas.width / canvas.height;
            const projMatrix = Mat4.perspective(fov, aspect, 0.1, 100.0);
            
            let mvMatrix = Mat4.identity();
            mvMatrix = Mat4.translate(mvMatrix, 0, 0, -35);
            mvMatrix = Mat4.rotateX(mvMatrix, rotationX);
            mvMatrix = Mat4.rotateY(mvMatrix, rotationY);
            
            const nMatrix = mvMatrix; 

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            gl.uniformMatrix4fv(uProjectionMatrix, false, new Float32Array(projMatrix));
            gl.uniformMatrix4fv(uModelViewMatrix, false, new Float32Array(mvMatrix));
            gl.uniformMatrix4fv(uNormalMatrix, false, new Float32Array(nMatrix));
            gl.uniform1f(uTime, time);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 2D Platformer</title>
    <style>
        body { margin: 0; background-color: #111; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 1px solid #555; }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    <script>
        // --- Main Game Logic ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                return;
            }

            // --- 1. Shaders ---

            // Vertex shader: Calculates the final position of each vertex
            // by applying model, view, and projection transformations.
            const vsSource = `
                attribute vec4 a_position;
                uniform mat4 u_modelMatrix;
                uniform mat4 u_viewMatrix;
                uniform mat4 u_projectionMatrix;
                void main() {
                    // Final position = projection * view * model * original_position
                    gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * a_position;
                }
            `;

            // Fragment shader: Sets a uniform color for the entire shape.
            const fsSource = `
                precision mediump float;
                uniform vec4 u_color;
                void main() {
                    gl_FragColor = u_color;
                }
            `;

            // --- 2. Shader Program Setup ---

            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'a_position'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'u_projectionMatrix'),
                    viewMatrix: gl.getUniformLocation(shaderProgram, 'u_viewMatrix'),
                    modelMatrix: gl.getUniformLocation(shaderProgram, 'u_modelMatrix'),
                    color: gl.getUniformLocation(shaderProgram, 'u_color'),
                },
            };

            // --- 3. Geometry Buffer ---

            // A simple 1x1 square. We will scale and translate this for all objects.
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                // Front face
                -0.5, -0.5, 0.0,
                 0.5, -0.5, 0.0,
                 0.5,  0.5, 0.0,
                -0.5,  0.5, 0.0,
            ];
            // We need indices to draw two triangles to form a square
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            const indices = [
                0, 1, 2,  0, 2, 3, // front
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            // --- 4. Game State ---

            const player = {
                x: 0, y: 0, z: 0,
                width: 0.8, height: 1.0,
                velocityX: 0, velocityY: 0,
                color: [0.9, 0.2, 0.2, 1.0], // Red
                isOnGround: false,
                jumpStrength: 0.25
            };

            const platforms = [
                { x: 0, y: -4, z: 0, width: 10, height: 0.5, color: [0.4, 0.8, 0.4, 1.0] }, // Green
                { x: -5, y: -1, z: 1, width: 4, height: 0.5, color: [0.4, 0.6, 0.8, 1.0] }, // Blue
                { x: 5, y: 2, z: -1, width: 4, height: 0.5, color: [0.4, 0.6, 0.8, 1.0] }, // Blue
            ];

            const gravity = -0.01;
            const moveSpeed = 0.1;
            const input = { left: false, right: false, up: false };

            // --- 5. Input Handling ---

            window.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
                if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
                if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && player.isOnGround) {
                    player.velocityY = player.jumpStrength;
                    player.isOnGround = false;
                }
            });
            window.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
                if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
            });

            // --- 6. Game Loop ---

            let then = 0;
            function gameLoop(now) {
                now *= 0.001; // convert to seconds
                const deltaTime = now - then;
                then = now;

                update();
                drawScene();

                requestAnimationFrame(gameLoop);
            }
            requestAnimationFrame(gameLoop);


            // --- 7. Update Function (Game Logic) ---

            function update() {
                // Horizontal movement
                if (input.left) player.velocityX = -moveSpeed;
                else if (input.right) player.velocityX = moveSpeed;
                else player.velocityX = 0;

                player.x += player.velocityX;

                // Vertical movement (gravity)
                player.velocityY += gravity;
                player.y += player.velocityY;

                // Collision detection
                player.isOnGround = false;
                for (const platform of platforms) {
                    // Check for AABB collision
                    const isCollidingX = player.x < platform.x + platform.width / 2 && player.x > platform.x - platform.width / 2;
                    const isAbove = player.y - player.height / 2 > platform.y - platform.height / 2;
                    const willCollideY = (player.y - player.height / 2 + player.velocityY) < (platform.y + platform.height / 2);

                    if (isCollidingX && isAbove && willCollideY) {
                         player.y = platform.y + platform.height / 2 + player.height / 2;
                         player.velocityY = 0;
                         player.isOnGround = true;
                    }
                }
                
                // Fall off screen
                if (player.y < -10) {
                    player.x = 0;
                    player.y = 5;
                    player.velocityY = 0;
                }
            }


            // --- 8. Draw Function (Rendering) ---

            function drawScene() {
                gl.clearColor(0.1, 0.1, 0.15, 1.0); // Clear to a dark bluish-gray
                gl.clearDepth(1.0);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // --- Projection and View Matrices ---
                const fieldOfView = 45 * Math.PI / 180; // in radians
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const zNear = 0.1;
                const zFar = 100.0;
                const projectionMatrix = mat4.create();
                mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

                const viewMatrix = mat4.create();
                // Position the camera at (0, 0, 15) looking at (0, 0, 0)
                mat4.lookAt(viewMatrix, [0, 0, 15], [0, 0, 0], [0, 1, 0]);

                // --- Draw Objects ---
                const allObjects = [player, ...platforms];
                
                gl.useProgram(programInfo.program);
                
                // Set uniforms that are the same for all objects
                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(programInfo.uniformLocations.viewMatrix, false, viewMatrix);

                // Bind the vertex buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                allObjects.forEach(obj => {
                    const modelMatrix = mat4.create();
                    mat4.translate(modelMatrix, modelMatrix, [obj.x, obj.y, obj.z]);
                    mat4.scale(modelMatrix, modelMatrix, [obj.width, obj.height, 1.0]);

                    gl.uniformMatrix4fv(programInfo.uniformLocations.modelMatrix, false, modelMatrix);
                    gl.uniform4fv(programInfo.uniformLocations.color, obj.color);

                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                });
            }
        }


        // --- Helper Functions ---

        // Initialize a shader program, so WebGL knows how to draw our data
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        // Create a shader of the given type, upload the source and compile it.
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
    </script>

    <script>
        var mat4 = {};
        mat4.create = function() { return new Float32Array(16); };
        mat4.translate = function(out, a, v) {
            let x = v[0], y = v[1], z = v[2];
            let a00, a01, a02, a03; let a10, a11, a12, a13; let a20, a21, a22, a23;
            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
                out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
            }
            return out;
        };
        mat4.scale = function(out, a, v) {
            let x = v[0], y = v[1], z = v[2];
            out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
            out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
            out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        };
        mat4.perspective = function(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[11] = -1; out[12] = 0; out[13] = 0; out[15] = 0;
            if (far != null && far !== Infinity) {
                const nf = 1 / (near - far);
                out[10] = (far + near) * nf;
                out[14] = 2 * far * near * nf;
            } else {
                out[10] = -1;
                out[14] = -2 * near;
            }
            return out;
        };
        mat4.lookAt = function(out, eye, center, up) {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            let eyex = eye[0], eyey = eye[1], eyez = eye[2];
            let upx = up[0], upy = up[1], upz = up[2];
            let centerx = center[0], centery = center[1], centerz = center[2];
            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;
            x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) { x0 = 0; x1 = 0; x2 = 0; }
            else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
            y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) { y0 = 0; y1 = 0; y2 = 0; }
            else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
            out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
            out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
            out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyez + z2 * eyez);
            out[15] = 1;
            return out;
        };
    </script>
</body>
</html>

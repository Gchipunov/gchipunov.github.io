<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL SAT Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #instructions {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h3>WebGL 2D Platformer (SAT Physics)</h3>
        <p>Use <b>Arrow Keys</b> or <b>WASD</b> to move and jump.</p>
        <p>Platforms Rotated: 15&deg;, 25&deg;, 45&deg;</p>
    </div>
    <canvas id="glcanvas"></canvas>

<script>
/** * MATH UTILITIES (Matrix & Vector)
 * Essential for WebGL transformations and SAT Physics
 */
const Mat3 = {
    identity: () => [1,0,0, 0,1,0, 0,0,1],
    projection: (width, height) => [2/width, 0, 0, 0, -2/height, 0, -1, 1, 1],
    translation: (tx, ty) => [1,0,0, 0,1,0, tx,ty,1],
    
    // FIX APPLIED HERE:
    // Swapped position of 's' and '-s' to match standard CCW rotation in column-major format
    rotation: (angleInRadians) => {
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        // Column 0: [c, s, 0], Column 1: [-s, c, 0], Column 2: [0, 0, 1]
        return [c, s, 0, -s, c, 0, 0, 0, 1];
    },
    
    scaling: (sx, sy) => [sx,0,0, 0,sy,0, 0,0,1],
    multiply: (a, b) => {
        const a00=a[0], a01=a[1], a02=a[2];
        const a10=a[3], a11=a[4], a12=a[5];
        const a20=a[6], a21=a[7], a22=a[8];
        const b00=b[0], b01=b[1], b02=b[2];
        const b10=b[3], b11=b[4], b12=b[5];
        const b20=b[6], b21=b[7], b22=b[8];
        return [
            b00*a00+b01*a10+b02*a20, b00*a01+b01*a11+b02*a21, b00*a02+b01*a12+b02*a22,
            b10*a00+b11*a10+b12*a20, b10*a01+b11*a11+b12*a21, b10*a02+b11*a12+b12*a22,
            b20*a00+b21*a10+b22*a20, b20*a01+b21*a11+b22*a21, b20*a02+b21*a12+b22*a22,
        ];
    }
};

const Vec2 = {
    add: (v1, v2) => ({x: v1.x + v2.x, y: v1.y + v2.y}),
    sub: (v1, v2) => ({x: v1.x - v2.x, y: v1.y - v2.y}),
    dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
    scale: (v, s) => ({x: v.x * s, y: v.y * s}),
    normalize: (v) => {
        const len = Math.sqrt(v.x*v.x + v.y*v.y);
        return len > 0 ? {x: v.x/len, y: v.y/len} : {x:0, y:0};
    },
    rotate: (v, angle) => {
        const c = Math.cos(angle), s = Math.sin(angle);
        return {x: v.x*c - v.y*s, y: v.x*s + v.y*c};
    }
};

/**
 * WEBGL SETUP
 */
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) { alert("WebGL not supported"); }

// Resize canvas
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// Shaders
const vsSource = `
    attribute vec2 a_position;
    uniform mat3 u_matrix;
    void main() {
        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

// Look up locations
const positionLoc = gl.getAttribLocation(program, "a_position");
const matrixLoc = gl.getUniformLocation(program, "u_matrix");
const colorLoc = gl.getUniformLocation(program, "u_color");

// Create buffers (A unit quad centered at 0,0)
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -0.5, -0.5,
     0.5, -0.5,
    -0.5,  0.5,
    -0.5,  0.5,
     0.5, -0.5,
     0.5,  0.5,
]), gl.STATIC_DRAW);

gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

function drawRect(x, y, w, h, rotation, color) {
    let matrix = Mat3.projection(gl.canvas.width, gl.canvas.height);
    matrix = Mat3.multiply(matrix, Mat3.translation(x, y));
    matrix = Mat3.multiply(matrix, Mat3.rotation(rotation));
    matrix = Mat3.multiply(matrix, Mat3.scaling(w, h));

    gl.uniformMatrix3fv(matrixLoc, false, matrix);
    gl.uniform4fv(colorLoc, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/**
 * GAME PHYSICS (SAT - Separating Axis Theorem)
 */

class Box {
    constructor(x, y, w, h, angle = 0, isStatic = true) {
        this.pos = {x, y};
        this.w = w;
        this.h = h;
        this.angle = angle; // radians
        this.isStatic = isStatic;
        this.color = isStatic ? [0.6, 0.6, 0.6, 1] : [1, 0.3, 0.3, 1];
        
        // Physics state
        this.vel = {x: 0, y: 0};
        this.grounded = false;
    }

    // Get the 4 corners of the rotated box in world space
    getCorners() {
        const c = Math.cos(this.angle);
        const s = Math.sin(this.angle);
        const hw = this.w / 2;
        const hh = this.h / 2;

        // Local corners relative to center
        const locals = [
            {x: -hw, y: -hh}, {x: hw, y: -hh},
            {x: hw, y: hh},   {x: -hw, y: hh}
        ];

        // Transform to world space
        return locals.map(p => ({
            x: this.pos.x + (p.x * c - p.y * s),
            y: this.pos.y + (p.x * s + p.y * c)
        }));
    }

    // Get the two axes (normals) for SAT
    getAxes() {
        const c = Math.cos(this.angle);
        const s = Math.sin(this.angle);
        return [
            {x: c, y: s},   // Axis parallel to width
            {x: -s, y: c}   // Axis parallel to height
        ];
    }
}

// SAT Collision Detection
function checkCollision(b1, b2) {
    const corners1 = b1.getCorners();
    const corners2 = b2.getCorners();
    const axes = [...b1.getAxes(), ...b2.getAxes()];
    
    let minOverlap = Infinity;
    let smallestAxis = null;

    for (let axis of axes) {
        // Project both shapes onto the axis
        const p1 = project(corners1, axis);
        const p2 = project(corners2, axis);

        if (!overlap(p1, p2)) {
            return false; // Separating axis found, no collision
        } else {
            // Calculate overlap amount
            const o = getOverlap(p1, p2);
            if (o < minOverlap) {
                minOverlap = o;
                smallestAxis = axis;
            }
        }
    }

    // Ensure axis points from b2 to b1
    const centerDir = Vec2.sub(b1.pos, b2.pos);
    if (Vec2.dot(centerDir, smallestAxis) < 0) {
        smallestAxis = Vec2.scale(smallestAxis, -1);
    }

    return {
        overlap: minOverlap,
        axis: smallestAxis
    };
}

function project(corners, axis) {
    let min = Infinity, max = -Infinity;
    for (let p of corners) {
        const dot = p.x * axis.x + p.y * axis.y;
        if (dot < min) min = dot;
        if (dot > max) max = dot;
    }
    return {min, max};
}

function overlap(p1, p2) {
    return !(p1.max < p2.min || p2.max < p1.min);
}

function getOverlap(p1, p2) {
    return Math.min(p1.max, p2.max) - Math.max(p1.min, p2.min);
}

/**
 * GAME LOGIC
 */

// Degrees to Radians
const rad = deg => deg * Math.PI / 180;

// Setup World
const player = new Box(100, 300, 30, 30, 0, false);
const platforms = [
    new Box(400, 550, 800, 40, 0),             // Ground
    new Box(300, 450, 200, 20, rad(15)),       // 15 deg
    new Box(600, 350, 200, 20, rad(-25)),      // 25 deg (tilted other way for variety)
    new Box(150, 250, 200, 20, rad(45))        // 45 deg
];

// Input Handling
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// Config
const GRAVITY = 0.5;
const JUMP_FORCE = -12;
const SPEED = 5;
const FRICTION = 0.8; // Ground friction
const AIR_RESISTANCE = 0.95;

function update() {
    // 1. Apply Forces
    player.vel.y += GRAVITY;

    // Horizontal Movement
    if (keys['ArrowLeft'] || keys['KeyA']) player.vel.x -= 1;
    if (keys['ArrowRight'] || keys['KeyD']) player.vel.x += 1;

    // Cap horizontal speed for tighter control
    if (player.vel.x > SPEED) player.vel.x = SPEED;
    if (player.vel.x < -SPEED) player.vel.x = -SPEED;

    // Apply Friction
    if (player.grounded) {
        player.vel.x *= FRICTION;
    } else {
        player.vel.x *= AIR_RESISTANCE;
    }

    // Stop if very slow
    if (Math.abs(player.vel.x) < 0.1) player.vel.x = 0;

    // Jump
    if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && player.grounded) {
        player.vel.y = JUMP_FORCE;
        player.grounded = false;
    }

    // 2. Apply Velocity
    player.pos.x += player.vel.x;
    player.pos.y += player.vel.y;
    
    // Rotate player slightly based on velocity for visual flair
    player.angle = (player.vel.x * 0.05);

    // 3. Collision Resolution (XPBD-ish style projection)
    player.grounded = false;

    // We check collision with all platforms
    for (let plat of platforms) {
        const col = checkCollision(player, plat);
        
        if (col) {
            // Move player out of collision (Position Projection)
            const pushX = col.axis.x * col.overlap;
            const pushY = col.axis.y * col.overlap;
            
            player.pos.x += pushX;
            player.pos.y += pushY;

            // Physics Response (Kill velocity into the surface)
            // Project velocity onto the collision normal
            const dot = player.vel.x * col.axis.x + player.vel.y * col.axis.y;
            
            // If moving towards the wall/floor, stop that component
            if (dot < 0) {
                player.vel.x -= col.axis.x * dot;
                player.vel.y -= col.axis.y * dot;
            }

            // Check if this counts as "ground" (normal pointing roughly up)
            // Normalized Y component of axis should be pointing up (negative in screen space usually, 
            // but here Y+ is down in standard translation, wait... 
            // our projection matrix: 0,0 is center, Y+ is UP or DOWN?
            // Matrix uses 2/height * -1. In webgl usually Y is up, but let's check projection.
            // Projection: y scale is negative (-2/height), so Y pixel coords increase downwards.
            // So "Up" is negative Y in pixel space.
            
            if (col.axis.y < -0.7) { 
                player.grounded = true;
            }
        }
    }

    // Reset if fallen off screen
    if (player.pos.y > canvas.height + 100) {
        player.pos = {x: 100, y: 300};
        player.vel = {x: 0, y: 0};
    }
}

function draw() {
    gl.clearColor(0.13, 0.13, 0.13, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Enable transparency blending
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // Draw Platforms
    for (let p of platforms) {
        drawRect(p.pos.x, p.pos.y, p.w, p.h, p.angle, p.color);
    }

    // Draw Player
    drawRect(player.pos.x, player.pos.y, player.w, player.h, player.angle, player.color);
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

loop();

</script>
</body>
</html>

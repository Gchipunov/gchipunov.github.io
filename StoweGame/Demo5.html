<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Warehouse Sim - Mobile Reticle Mode</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a1a; touch-action: none; }
        canvas { display: block; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; z-index: 10; }
        h1 { margin: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; color: #4facfe; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        
        #stats {
            margin-top: 10px; background: rgba(0, 0, 0, 0.85); padding: 12px; border-radius: 8px; border: 1px solid #444; width: 200px;
        }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
        .highlight { color: #f093fb; font-weight: bold; }

        /* Target Box */
        #target-box {
            margin-top: 5px; padding: 5px; background: rgba(255, 0, 100, 0.2); border: 1px solid #ff0066; border-radius: 4px;
            color: #ff99bb; text-align: center; font-weight: bold; animation: pulse-border 1s infinite alternate; font-size: 14px;
        }
        @keyframes pulse-border { from { border-color: #ff0066; } to { border-color: #ffffff; } }

        /* --- RETICLE (CROSSHAIR) --- */
        #reticle {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 20;
        }
        #reticle::before, #reticle::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.8);
        }
        #reticle::before { top: 9px; left: 0; width: 20px; height: 2px; } /* Horizontal */
        #reticle::after { top: 0; left: 9px; width: 2px; height: 20px; } /* Vertical */

        /* --- STOW BUTTON (The Fix) --- */
        #stow-btn {
            position: absolute; bottom: 30px; right: 30px; width: 100px; height: 100px;
            background: rgba(0, 0, 0, 0.5); border: 4px solid #666; border-radius: 50%;
            color: #aaa; font-weight: bold; font-size: 18px; cursor: pointer; z-index: 30;
            display: flex; align-items: center; justify-content: center;
            touch-action: manipulation; -webkit-tap-highlight-color: transparent;
            transition: all 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        
        /* State: Ready to Stow */
        #stow-btn.active {
            background: rgba(0, 255, 0, 0.3); border-color: #00ff00; color: white;
            transform: scale(1.1); box-shadow: 0 0 20px #00ff00;
        }
        
        /* State: Error / Wrong Bin */
        #stow-btn.error {
            background: rgba(255, 0, 0, 0.3); border-color: #ff0000; color: white;
            animation: shake 0.3s;
        }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } 100% { transform: translateX(0); } }

        /* Mobile Movement Controls (D-Pad) */
        .d-pad { position: absolute; bottom: 30px; left: 20px; width: 120px; height: 120px; z-index: 30; }
        .d-btn {
            position: absolute; width: 40px; height: 40px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px; color: white; display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer;
        }
        .d-btn:active { background: rgba(79, 172, 254, 0.5); }
        #btn-u { top: 0; left: 40px; }
        #btn-d { bottom: 0; left: 40px; }
        #btn-l { top: 40px; left: 0; }
        #btn-r { top: 40px; right: 0; }

        #cursor-info {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            color: #ffd700; font-size: 14px; text-shadow: 1px 1px 2px black; opacity: 0; transition: opacity 0.2s; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Stow Sim: Reticle Mode</h1>
        <div id="stats">
            <div class="stat-row"><span>Stow Rate:</span> <span id="rate-val" class="highlight">0 UPH</span></div>
            <div class="stat-row"><span>Score:</span> <span id="score-val">0</span></div>
            <div id="target-box">TARGET: <span id="target-loc">Scanning...</span></div>
        </div>
    </div>

    <div id="reticle"></div>
    <div id="cursor-info">Aisle A</div>

    <div id="stow-btn">STOW</div>

    <div class="d-pad">
        <div class="d-btn" id="btn-u">▲</div>
        <div class="d-btn" id="btn-l">◀</div>
        <div class="d-btn" id="btn-r">▶</div>
        <div class="d-btn" id="btn-d">▼</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // CONFIG
        const CONFIG = { aisles: ['A', 'B', 'C', 'D'], lines: 2, floors: 4, binSize: { w: 2, h: 1.5, d: 2 }, aisleGap: 8, lineGap: 0.2 };
        
        // GAME STATE
        let score = 0, stowedCount = 0, startTime = Date.now();
        let bins = [], currentTargetBin = null, aimedBin = null;
        
        // SCENE
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.FogExp2(0x222222, 0.015);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 12, 15);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // LIGHTS
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // CONTROLS
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // MATERIALS
        const mats = {
            empty: new THREE.MeshStandardMaterial({ color: 0x444444, transparent: true, opacity: 0.3, side: THREE.DoubleSide }),
            target: new THREE.MeshStandardMaterial({ color: 0xff0066, emissive: 0xff0066, emissiveIntensity: 1, transparent: true, opacity: 0.6 }),
            hoverCorrect: new THREE.MeshStandardMaterial({ color: 0x00ff00, opacity: 0.6, transparent: true }),
            hoverWrong: new THREE.MeshStandardMaterial({ color: 0xffff00, opacity: 0.5, transparent: true }),
            filled: new THREE.MeshStandardMaterial({ color: 0x4facfe }),
            error: new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 2 }),
            line: new THREE.LineBasicMaterial({ color: 0x666666 })
        };

        // BUILD RACKS
        const geo = new THREE.BoxGeometry(CONFIG.binSize.w, CONFIG.binSize.h, CONFIG.binSize.d);
        const edges = new THREE.EdgesGeometry(geo);
        const grid = new THREE.GridHelper(100, 50, 0x444444, 0x111111);
        scene.add(grid);

        CONFIG.aisles.forEach((aisle, idx) => {
            const x = (idx * CONFIG.aisleGap) - ((CONFIG.aisles.length * CONFIG.aisleGap) / 2);
            for(let l=1; l<=CONFIG.lines; l++) {
                const z = (l===1) ? -(CONFIG.binSize.d/2 + CONFIG.lineGap) : (CONFIG.binSize.d/2 + CONFIG.lineGap);
                for(let f=1; f<=CONFIG.floors; f++) {
                    const y = (f * CONFIG.binSize.h) - (CONFIG.binSize.h/2);
                    const bin = new THREE.Mesh(geo, mats.empty.clone());
                    bin.position.set(x, y, z);
                    bin.add(new THREE.LineSegments(edges, mats.line));
                    bin.userData = { isBin: true, aisle, line: l, floor: f, filled: false, isError: false };
                    scene.add(bin);
                    bins.push(bin);
                }
            }
        });

        // UI ELEMENTS
        const uiScore = document.getElementById('score-val');
        const uiRate = document.getElementById('rate-val');
        const uiTarget = document.getElementById('target-loc');
        const uiInfo = document.getElementById('cursor-info');
        const stowBtn = document.getElementById('stow-btn');

        // LOGIC
        function pickTarget() {
            const empty = bins.filter(b => !b.userData.filled);
            if(empty.length === 0) return alert("Complete!");
            currentTargetBin = empty[Math.floor(Math.random() * empty.length)];
            uiTarget.innerText = `${currentTargetBin.userData.aisle}-${currentTargetBin.userData.line}-${currentTargetBin.userData.floor}`;
        }
        pickTarget();

        // --- THE MAGIC: RETICLE RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        // (0, 0) is the normalized coordinate for the center of the screen
        const centerScreen = new THREE.Vector2(0, 0); 

        function checkReticle() {
            raycaster.setFromCamera(centerScreen, camera);
            const intersects = raycaster.intersectObjects(bins);
            
            aimedBin = null; // Reset
            uiInfo.style.opacity = 0;
            stowBtn.classList.remove('active');

            if(intersects.length > 0) {
                const obj = intersects[0].object;
                if(obj.userData.isBin) {
                    aimedBin = obj;
                    
                    // Update UI Info
                    uiInfo.innerText = `Bin: ${obj.userData.aisle}-${obj.userData.line}-${obj.userData.floor}`;
                    uiInfo.style.opacity = 1;

                    // Button Feedback
                    if(obj === currentTargetBin && !obj.userData.filled) {
                        stowBtn.classList.add('active'); // Turn Green
                    }
                }
            }
        }

        // --- STOW ACTION ---
        function triggerStow() {
            if(!aimedBin) return; // Stowing into thin air

            if(aimedBin !== currentTargetBin) {
                // ERROR
                flashError(aimedBin);
                stowBtn.classList.add('error');
                setTimeout(() => stowBtn.classList.remove('error'), 300);
                return;
            }

            if(aimedBin.userData.filled) return;

            // SUCCESS
            aimedBin.userData.filled = true;
            aimedBin.material = mats.filled; // Permanent fill color
            
            // Add package visual
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.binSize.w*0.8, CONFIG.binSize.h*0.8, CONFIG.binSize.d*0.8),
                new THREE.MeshStandardMaterial({ color: Math.random()*0xffffff })
            );
            box.scale.set(0,0,0);
            aimedBin.add(box);
            
            // Animation
            let s = 0;
            const grow = () => { s+=0.1; box.scale.set(s,s,s); if(s<1) requestAnimationFrame(grow); };
            grow();

            // Stats
            score += 10; stowedCount++;
            uiScore.innerText = score;
            const mins = (Date.now() - startTime)/60000;
            uiRate.innerText = Math.floor(stowedCount / (mins || 1) * 60) + " UPH";

            pickTarget();
        }

        function flashError(bin) {
            bin.userData.isError = true;
            setTimeout(() => { bin.userData.isError = false; }, 300);
        }

        // BUTTON EVENTS (Touch Down & Click)
        // preventDefault stops the browser from zooming/selecting text on rapid taps
        stowBtn.addEventListener('touchstart', (e) => { e.preventDefault(); triggerStow(); }, {passive: false});
        stowBtn.addEventListener('mousedown', (e) => { e.preventDefault(); triggerStow(); });

        // MOVEMENT BUTTONS
        const moveStep = 1.5;
        const move = (x, z) => { 
            const offset = new THREE.Vector3(x, 0, z).applyQuaternion(camera.quaternion);
            camera.position.add(offset); controls.target.add(offset); 
        };
        document.getElementById('btn-u').onclick = () => move(0, -moveStep);
        document.getElementById('btn-d').onclick = () => move(0, moveStep);
        document.getElementById('btn-l').onclick = () => move(-moveStep, 0);
        document.getElementById('btn-r').onclick = () => move(moveStep, 0);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // GAME LOOP
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 1. Raycast from Center
            checkReticle();

            // 2. Update Bin Visuals based on State
            bins.forEach(bin => {
                if(bin.userData.filled) return; // Stay blue/filled
                if(bin.userData.isError) { bin.material = mats.error; return; }

                if (bin === aimedBin) {
                    // We are looking at this bin
                    if (bin === currentTargetBin) bin.material = mats.hoverCorrect;
                    else bin.material = mats.hoverWrong;
                } 
                else if (bin === currentTargetBin) {
                    // This is the target, but we aren't looking at it -> Blink
                    const pulse = 0.5 + Math.sin(Date.now() * 0.005) * 0.5;
                    bin.material = mats.target;
                    bin.material.emissiveIntensity = pulse * 2;
                } 
                else {
                    bin.material = mats.empty;
                }
            });

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

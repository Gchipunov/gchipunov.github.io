<!DOCTYPE html>
<html>
<head>
    <title>Three.js + Cannon-es Physics Car</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; }
        canvas { display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        .control-button {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid #000;
            border-radius: 50%;
            text-align: center;
            line-height: 65px;
            font-size: 20px;
            font-weight: bold;
            color: #000;
            user-select: none;
            touch-action: manipulation; /* Improves touch responsiveness */
        }
    </style>
</head>
<body>
    <div id="controls">
        <div id="turn-left" class="control-button">‚¨ÖÔ∏è</div>
        <div id="accelerate" class="control-button">‚¨ÜÔ∏è</div>
        <div id="turn-right" class="control-button">‚û°Ô∏è</div>
        <div id="brake" class="control-button">üõë</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
    
    <script>
        // --- SCENE SETUP (THREE.JS) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);

        // --- PHYSICS SETUP (CANNON-ES) ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // Standard gravity
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Ground Plane (Visual - Three.js)
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial_visual = new THREE.MeshLambertMaterial({ color: 0x55aa55 });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial_visual);
        groundMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        scene.add(groundMesh);

        // Ground Plane (Physics - Cannon-es)
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 }); // Mass 0 makes it static
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rotate to match visual
        world.addBody(groundBody);


        // --- CAR/BOX SETUP ---
        // Visual (Three.js)
        const carGeometry = new THREE.BoxGeometry(1, 1, 2); // A simple box for the car body
        const carMaterial_visual = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const carMesh = new THREE.Mesh(carGeometry, carMaterial_visual);
        scene.add(carMesh);

        // Physics (Cannon-es)
        const carShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 1)); // Half extents of the box
        const carBody = new CANNON.Body({ mass: 5, shape: carShape });
        carBody.position.set(0, 5, 0); // Start the car above the ground
        carBody.angularFactor.set(0, 1, 0); // Prevent rolling/pitching (simple driving)
        world.addBody(carBody);


        // --- CONTROLS AND GAME LOGIC ---
        const controls = {
            forward: false,
            backward: false,
            left: false,
            right: false,
        };
        const forceAmount = 100;
        const steeringSpeed = 0.8;

        // Touch Control Handlers
        function setupTouchControl(id, key) {
            const element = document.getElementById(id);
            element.addEventListener('touchstart', (e) => {
                e.preventDefault();
                controls[key] = true;
            });
            element.addEventListener('touchend', (e) => {
                e.preventDefault();
                controls[key] = false;
            });
        }

        setupTouchControl('accelerate', 'forward');
        setupTouchControl('brake', 'backward');
        setupTouchControl('turn-left', 'left');
        setupTouchControl('turn-right', 'right');

        // Keyboard Control (for testing on desktop)
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp': controls.forward = true; break;
                case 'ArrowDown': controls.backward = true; break;
                case 'ArrowLeft': controls.left = true; break;
                case 'ArrowRight': controls.right = true; break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'ArrowUp': controls.forward = false; break;
                case 'ArrowDown': controls.backward = false; break;
                case 'ArrowLeft': controls.left = false; break;
                case 'ArrowRight': controls.right = false; break;
            }
        });
        
        // Window Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- GAME LOOP ---
        const timeStep = 1 / 60; // Physics simulation rate
        let lastTimestamp = 0;

        function animate(timestamp) {
            requestAnimationFrame(animate);

            // Calculate deltaTime for smooth physics stepping
            const deltaTime = (timestamp - lastTimestamp) / 1000;
            world.step(timeStep, deltaTime, 3);
            lastTimestamp = timestamp;

            // 1. APPLY CONTROL FORCES
            const worldQuaternion = carBody.quaternion;
            const directionVector = new THREE.Vector3(0, 0, 1);
            directionVector.applyQuaternion(carBody.quaternion); // Get forward direction

            if (controls.forward) {
                carBody.applyForce(new CANNON.Vec3(
                    directionVector.x * forceAmount, 
                    0, 
                    directionVector.z * forceAmount
                ), carBody.position);
            }
            if (controls.backward) {
                carBody.applyForce(new CANNON.Vec3(
                    -directionVector.x * forceAmount, 
                    0, 
                    -directionVector.z * forceAmount
                ), carBody.position);
            }
            
            // 2. APPLY STEERING TORQUE
            if (controls.left) {
                carBody.angularVelocity.y = steeringSpeed;
            } else if (controls.right) {
                carBody.angularVelocity.y = -steeringSpeed;
            } else {
                // Decelerate turning when no button is pressed
                carBody.angularVelocity.y *= 0.8; 
            }

            // 3. SYNCHRONIZE VISUALS WITH PHYSICS
            carMesh.position.copy(carBody.position);
            carMesh.quaternion.copy(carBody.quaternion);
            
            // 4. CAMERA FOLLOW
            camera.position.x = carBody.position.x - directionVector.x * 5;
            camera.position.z = carBody.position.z - directionVector.z * 5;
            camera.position.y = carBody.position.y + 3; // Keep camera elevated
            camera.lookAt(carBody.position);

            // 5. RENDER
            renderer.render(scene, camera);
        }

        animate(0); // Start the loop
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Physics Water</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gl-canvas"></canvas>

    <script id="physics-vs" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_position * 0.5 + 0.5;
        }
    </script>

    <script id="physics-fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec2 v_texCoord;
        uniform sampler2D u_watermap; // Input height map (previous state)
        uniform vec2 u_delta; // Texel size: (1.0/width, 1.0/height)
        uniform bool u_isDrop;
        uniform vec2 u_dropPosition;

        const float DAMPING = 0.985;

        void main() {
            vec4 info = texture2D(u_watermap, v_texCoord);
            
            // Add a drop on mouse interaction
            if (u_isDrop) {
                float dist = distance(v_texCoord, u_dropPosition);
                if (dist < 0.02) { // radius of the drop
                    info.x -= 0.2; // Add energy (negative height)
                }
            }

            float center = texture2D(u_watermap, v_texCoord).x;
            float up = texture2D(u_watermap, v_texCoord + vec2(0.0, u_delta.y)).x;
            float down = texture2D(u_watermap, v_texCoord - vec2(0.0, u_delta.y)).x;
            float left = texture2D(u_watermap, v_texCoord - vec2(u_delta.x, 0.0)).x;
            float right = texture2D(u_watermap, v_texCoord + vec2(u_delta.x, 0.0)).x;

            float oldHeight = info.y; // Height from t-2
            float newHeight = (up + down + left + right) / 2.0 - oldHeight;
            newHeight *= DAMPING;

            // Store new height in 'x' and current height in 'y' for the next frame
            gl_FragColor = vec4(newHeight, center, 0.0, 1.0);
        }
    </script>

    <script id="water-vs" type="x-shader/x-vertex">
        attribute vec3 a_position;
        attribute vec2 a_texCoord;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_world;
        uniform sampler2D u_watermap; // Final height map

        varying vec3 v_worldPosition;
        varying vec2 v_texCoord;
        varying vec3 v_normal;

        void main() {
            v_texCoord = a_texCoord;
            float height = texture2D(u_watermap, a_texCoord).x * 0.1; // Scale height
            vec3 displacedPosition = a_position + vec3(0.0, height, 0.0);

            // Calculate normals by sampling neighboring heights
            float hL = texture2D(u_watermap, a_texCoord - vec2(0.01, 0.0)).x * 0.1;
            float hR = texture2D(u_watermap, a_texCoord + vec2(0.01, 0.0)).x * 0.1;
            float hD = texture2D(u_watermap, a_texCoord - vec2(0.0, 0.01)).x * 0.1;
            float hU = texture2D(u_watermap, a_texCoord + vec2(0.0, 0.01)).x * 0.1;

            v_normal = normalize(vec3(hL - hR, 0.2, hD - hU));
            
            vec4 worldPos = u_world * vec4(displacedPosition, 1.0);
            v_worldPosition = worldPos.xyz;
            gl_Position = u_projection * u_view * worldPos;
        }
    </script>

    <script id="water-fs" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 u_cameraPosition;
        uniform vec3 u_lightDirection;

        varying vec3 v_worldPosition;
        varying vec3 v_normal;

        void main() {
            vec3 viewDirection = normalize(u_cameraPosition - v_worldPosition);
            vec3 normal = normalize(v_normal);

            // Simple lighting
            float diffuse = max(0.0, dot(normal, u_lightDirection)) * 0.6 + 0.4;
            vec3 waterColor = vec3(0.1, 0.4, 0.7);

            // Specular highlights
            vec3 reflectDir = reflect(-u_lightDirection, normal);
            float spec = pow(max(dot(viewDirection, reflectDir), 0.0), 64.0);
            vec3 specular = vec3(1.0) * spec * 0.8;
            
            // Fresnel effect
            float fresnel = pow(1.0 - max(0.0, dot(viewDirection, normal)), 3.0);
            fresnel = mix(0.1, 1.0, fresnel); // Blend factor for fake reflection

            vec3 skyColor = vec3(0.5, 0.7, 0.9);
            vec3 finalColor = mix(waterColor * diffuse, skyColor, fresnel) + specular;

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    
    <script>
        'use strict';

        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported!');
        }

        // Enable required extensions
        const floatTextureExt = gl.getExtension('OES_texture_float');
        if (!floatTextureExt) {
            alert('Floating point textures not supported!');
        }

        // -- Shader Programs --
        const physicsProgram = createProgram(gl, 'physics-vs', 'physics-fs');
        const waterProgram = createProgram(gl, 'water-vs', 'water-fs');
        
        // -- Program Info (locations) --
        const physicsInfo = {
            program: physicsProgram,
            attribs: { position: gl.getAttribLocation(physicsProgram, 'a_position') },
            uniforms: {
                watermap: gl.getUniformLocation(physicsProgram, 'u_watermap'),
                delta: gl.getUniformLocation(physicsProgram, 'u_delta'),
                isDrop: gl.getUniformLocation(physicsProgram, 'u_isDrop'),
                dropPosition: gl.getUniformLocation(physicsProgram, 'u_dropPosition'),
            },
        };
        const waterInfo = {
            program: waterProgram,
            attribs: {
                position: gl.getAttribLocation(waterProgram, 'a_position'),
                texCoord: gl.getAttribLocation(waterProgram, 'a_texCoord'),
            },
            uniforms: {
                projection: gl.getUniformLocation(waterProgram, 'u_projection'),
                view: gl.getUniformLocation(waterProgram, 'u_view'),
                world: gl.getUniformLocation(waterProgram, 'u_world'),
                watermap: gl.getUniformLocation(waterProgram, 'u_watermap'),
                cameraPosition: gl.getUniformLocation(waterProgram, 'u_cameraPosition'),
                lightDirection: gl.getUniformLocation(waterProgram, 'u_lightDirection'),
            },
        };

        // -- Geometry --
        const quadBuffer = createQuadBuffer(gl); // For FBO rendering
        const plane = createPlaneGeometry(gl, 128); // Water surface

        // -- Physics Simulation (FBO) --
        const TEXTURE_SIZE = 256;
        let fbo1 = createFBO(gl, TEXTURE_SIZE);
        let fbo2 = createFBO(gl, TEXTURE_SIZE);
        let currentFBO = fbo1;
        let nextFBO = fbo2;

        // -- Interaction --
        let isMouseDown = false;
        let mouseCoords = { x: 0, y: 0 };
        canvas.addEventListener('mousedown', () => isMouseDown = true);
        canvas.addEventListener('mouseup', () => isMouseDown = false);
        canvas.addEventListener('mousemove', e => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                mouseCoords.x = (e.clientX - rect.left) / canvas.width;
                mouseCoords.y = 1.0 - (e.clientY - rect.top) / canvas.height;
                addDrop(mouseCoords.x, mouseCoords.y);
            }
        });

        function addDrop(x, y) {
            gl.useProgram(physicsInfo.program);
            gl.bindFramebuffer(gl.FRAMEBUFFER, nextFBO.framebuffer);
            gl.viewport(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentFBO.texture);
            gl.uniform1i(physicsInfo.uniforms.watermap, 0);

            gl.uniform1f(physicsInfo.uniforms.isDrop, 1.0);
            gl.uniform2f(physicsInfo.uniforms.dropPosition, x, y);

            renderQuad();

            gl.uniform1f(physicsInfo.uniforms.isDrop, 0.0);
            swapFBOs();
        }

        function swapFBOs() {
            let temp = currentFBO;
            currentFBO = nextFBO;
            nextFBO = temp;
        }

        function renderQuad() {
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            gl.enableVertexAttribArray(physicsInfo.attribs.position);
            gl.vertexAttribPointer(physicsInfo.attribs.position, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }

        // -- Render Loop --
        function render(time) {
            time *= 0.001; // convert to seconds
            resizeCanvasToDisplaySize(gl.canvas);

            // 1. Update Physics
            gl.useProgram(physicsInfo.program);
            gl.bindFramebuffer(gl.FRAMEBUFFER, nextFBO.framebuffer);
            gl.viewport(0, 0, TEXTURE_SIZE, TEXTURE_SIZE);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentFBO.texture);
            gl.uniform1i(physicsInfo.uniforms.watermap, 0);
            gl.uniform2f(physicsInfo.uniforms.delta, 1 / TEXTURE_SIZE, 1 / TEXTURE_SIZE);

            renderQuad();
            swapFBOs();

            // 2. Render Water
            gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Render to canvas
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(waterInfo.program);

            // Matrices
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, 45 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.1, 100.0);
            
            const viewMatrix = mat4.create();
            const cameraPosition = [0, 2, 4];
            mat4.lookAt(viewMatrix, cameraPosition, [0, 0, 0], [0, 1, 0]);
            
            const worldMatrix = mat4.create();
            mat4.scale(worldMatrix, worldMatrix, [2, 2, 2]);

            gl.uniformMatrix4fv(waterInfo.uniforms.projection, false, projectionMatrix);
            gl.uniformMatrix4fv(waterInfo.uniforms.view, false, viewMatrix);
            gl.uniformMatrix4fv(waterInfo.uniforms.world, false, worldMatrix);
            
            // Other uniforms
            gl.uniform3fv(waterInfo.uniforms.cameraPosition, cameraPosition);
            gl.uniform3fv(waterInfo.uniforms.lightDirection, vec3.normalize([], [0.5, 1, 0.5]));

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentFBO.texture);
            gl.uniform1i(waterInfo.uniforms.watermap, 0);

            // Bind and draw plane
            gl.bindBuffer(gl.ARRAY_BUFFER, plane.position);
            gl.vertexAttribPointer(waterInfo.attribs.position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(waterInfo.attribs.position);

            gl.bindBuffer(gl.ARRAY_BUFFER, plane.texCoord);
            gl.vertexAttribPointer(waterInfo.attribs.texCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(waterInfo.attribs.texCoord);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, plane.indices);
            gl.drawElements(gl.TRIANGLES, plane.count, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);


        // --- Helper Functions ---
        function createShader(gl, type, sourceId) {
            const source = document.getElementById(sourceId).text;
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsId, fsId) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsId);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsId);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        
        function createQuadBuffer(gl) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const positions = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            return buffer;
        }

        function createPlaneGeometry(gl, segments) {
            const positions = [];
            const texCoords = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    const x = (j / segments) * 2 - 1; // -1 to 1
                    const z = (i / segments) * 2 - 1; // -1 to 1
                    const u = j / segments;
                    const v = i / segments;
                    positions.push(x, 0, z);
                    texCoords.push(u, v);
                }
            }

            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * (segments + 1) + j;
                    const b = a + 1;
                    const c = a + (segments + 1);
                    const d = c + 1;
                    indices.push(a, b, c, c, b, d);
                }
            }

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            return {
                position: posBuffer,
                texCoord: texCoordBuffer,
                indices: indexBuffer,
                count: indices.length,
            };
        }

        function createFBO(gl, size) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.FLOAT, null);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            // Clean up
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return { framebuffer, texture };
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

    </script>
</body>
</html>

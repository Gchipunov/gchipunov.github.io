<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Speed Pusher Sorter</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0; font-size: 24px; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 14px; color: #aaa; }
        #score-board { margin-top: 10px; font-size: 18px; font-weight: bold; color: #00ffcc; }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            text-align: center;
            color: white;
            border: 2px solid #ff0055;
        }
        button {
            padding: 10px 20px;
            background: #ff0055;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
        }
        button:hover { background: #ff4488; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>Inductor Logic</h1>
        <p>SORT RULES:</p>
        <p>ðŸŸ© <strong>A, B, C, D</strong> âž” PUSH (Next Lane)</p>
        <p>ðŸŸ¦ <strong>E, G, H, J</strong> âž” IGNORE (Main Lane)</p>
        <p>ðŸŸ¥ <strong>TRASH</strong> âž” PUSH (Reject)</p>
        <div id="score-board">Score: 0 | Lives: 5</div>
    </div>

    <div id="instructions">Press [SPACE] or Click to PUSH</div>

    <div id="game-over">
        <h2 style="color:#ff0055">SYSTEM FAILURE</h2>
        <p id="final-score">Score: 0</p>
        <button onclick="location.reload()">RESTART SYSTEM</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GAME CONFIGURATION ---
        const CONVEYOR_SPEED = 0.4;
        const PUSH_SPEED = 0.8;
        const SPAWN_RATE = 60; // Frames between spawns
        
        // Sorting Logic
        const PUSH_TYPES = ['A', 'B', 'C', 'D'];
        const KEEP_TYPES = ['E', 'G', 'H', 'J'];
        const TRASH_TYPES = ['X', 'BAD', 'N/A']; 

        // State
        let score = 0;
        let lives = 5;
        let isGameOver = false;
        let frameCount = 0;
        const packages = [];
        
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 20, 50);

        // Camera (Isometric view)
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 20, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- ENVIRONMENT ASSETS ---

        // 1. Main Conveyor Belt
        const beltGeo = new THREE.BoxGeometry(4, 1, 60);
        const beltMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const belt = new THREE.Mesh(beltGeo, beltMat);
        belt.position.set(0, -1, 0);
        belt.receiveShadow = true;
        scene.add(belt);

        // 2. The "Next Lane" (The divert lane at 90 deg)
        const sortLaneGeo = new THREE.BoxGeometry(30, 1, 4);
        const sortLaneMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
        const sortLane = new THREE.Mesh(sortLaneGeo, sortLaneMat);
        sortLane.position.set(15, -1, 2); // 2 units forward from center
        sortLane.receiveShadow = true;
        scene.add(sortLane);

        // Visual Markers
        const zoneMarkerGeo = new THREE.PlaneGeometry(4, 4);
        const zoneMarkerMat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
        const zoneMarker = new THREE.Mesh(zoneMarkerGeo, zoneMarkerMat);
        zoneMarker.rotation.x = -Math.PI / 2;
        zoneMarker.position.set(0, -0.4, 2);
        scene.add(zoneMarker);

        // 3. The Pusher Mechanism
        const pusherGroup = new THREE.Group();
        const pusherHeadGeo = new THREE.BoxGeometry(0.5, 1.5, 3);
        const pusherHeadMat = new THREE.MeshLambertMaterial({ color: 0xffaa00 });
        const pusherHead = new THREE.Mesh(pusherHeadGeo, pusherHeadMat);
        pusherHead.castShadow = true;
        
        const pistonGeo = new THREE.CylinderGeometry(0.2, 0.2, 4);
        const pistonMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const piston = new THREE.Mesh(pistonGeo, pistonMat);
        piston.rotation.z = Math.PI / 2;
        piston.position.x = -2;

        pusherGroup.add(pusherHead);
        pusherGroup.add(piston);
        pusherGroup.position.set(-3, 0.5, 2); // Start retracted
        scene.add(pusherGroup);

        // --- HELPER FUNCTIONS ---

        // Texture Generator for Letters (Avoids external assets)
        function createTextTexture(text, colorStr) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = colorStr;
            ctx.fillRect(0,0,128,128);
            
            // Border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 5;
            ctx.strokeRect(0,0,128,128);

            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- GAME LOGIC ---

        class Package {
            constructor() {
                // Determine Type
                const rand = Math.random();
                if (rand < 0.4) {
                    this.label = PUSH_TYPES[Math.floor(Math.random() * PUSH_TYPES.length)];
                    this.action = "PUSH";
                    this.color = "#2ecc71"; // Green
                } else if (rand < 0.8) {
                    this.label = KEEP_TYPES[Math.floor(Math.random() * KEEP_TYPES.length)];
                    this.action = "KEEP";
                    this.color = "#3498db"; // Blue
                } else {
                    this.label = TRASH_TYPES[Math.floor(Math.random() * TRASH_TYPES.length)];
                    this.action = "PUSH"; // Trash also needs to be pushed off
                    this.color = "#e74c3c"; // Red
                }

                // Mesh
                const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const tex = createTextTexture(this.label, this.color);
                const mat = new THREE.MeshStandardMaterial({ map: tex });
                this.mesh = new THREE.Mesh(geo, mat);
                
                this.mesh.position.set(0, 0.75, -25); // Start at back of belt
                this.mesh.castShadow = true;
                
                this.isPushed = false;
                this.active = true;

                scene.add(this.mesh);
            }

            update() {
                if (!this.active) return;

                // Move forward
                this.mesh.position.z += CONVEYOR_SPEED;

                // Move sideways if pushed
                if (this.isPushed) {
                    this.mesh.position.x += PUSH_SPEED;
                }

                // CHECK: Pusher Collision
                // If package is in the "Kill Zone" (z approx 2) and Pusher is Extended
                if (pusherState === 'EXTENDING' || pusherState === 'EXTENDED') {
                    if (Math.abs(this.mesh.position.z - 2) < 1.5 && !this.isPushed) {
                        this.isPushed = true;
                        // Visual knock
                        this.mesh.rotation.y = Math.random();
                    }
                }

                // CHECK: End of Belt Logic
                
                // 1. Success Sort (Pushed off to side)
                if (this.mesh.position.x > 8) {
                    this.resolve(this.action === "PUSH");
                }
                
                // 2. Missed Sort (Went past end of main belt)
                if (this.mesh.position.z > 15) {
                    this.resolve(this.action === "KEEP");
                }
            }

            resolve(success) {
                if (!this.active) return;
                
                this.active = false;
                scene.remove(this.mesh); // Remove visual

                if (success) {
                    score += 100;
                    document.getElementById('score-board').style.color = "#00ffcc";
                } else {
                    lives--;
                    document.getElementById('score-board').style.color = "#ff0055";
                    // Screen shake effect logic could go here
                }
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('score-board').innerText = `Score: ${score} | Lives: ${lives}`;
            if (lives <= 0) endGame();
        }

        function endGame() {
            isGameOver = true;
            document.getElementById('final-score').innerText = "Final Score: " + score;
            document.getElementById('game-over').style.display = "block";
        }

        // --- INPUT & PUSHER LOGIC ---

        let pusherState = 'IDLE'; // IDLE, EXTENDING, EXTENDED, RETRACTING
        let pusherTimer = 0;

        function activatePusher() {
            if (pusherState === 'IDLE') {
                pusherState = 'EXTENDING';
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') activatePusher();
        });
        window.addEventListener('mousedown', activatePusher);
        window.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            activatePusher();
        });

        function updatePusher() {
            const extendLimit = 0.5; // X position
            const retractLimit = -3; // X position
            const speed = 0.8;

            switch (pusherState) {
                case 'EXTENDING':
                    pusherGroup.position.x += speed;
                    if (pusherGroup.position.x >= extendLimit) {
                        pusherGroup.position.x = extendLimit;
                        pusherState = 'EXTENDED';
                        pusherTimer = 5; // Hold frames
                    }
                    break;
                case 'EXTENDED':
                    pusherTimer--;
                    if (pusherTimer <= 0) pusherState = 'RETRACTING';
                    break;
                case 'RETRACTING':
                    pusherGroup.position.x -= speed * 0.5; // Retract slower
                    if (pusherGroup.position.x <= retractLimit) {
                        pusherGroup.position.x = retractLimit;
                        pusherState = 'IDLE';
                    }
                    break;
            }
        }

        // --- MAIN LOOP ---

        function animate() {
            requestAnimationFrame(animate);

            if (isGameOver) return;

            // Spawning
            frameCount++;
            if (frameCount % SPAWN_RATE === 0) {
                packages.push(new Package());
            }

            // Updates
            updatePusher();
            
            // Update Packages & Clean up array
            for (let i = packages.length - 1; i >= 0; i--) {
                packages[i].update();
                if (!packages[i].active) {
                    packages.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>

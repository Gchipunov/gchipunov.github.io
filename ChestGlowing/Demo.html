<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Glowing Chest</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; }
        canvas { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec4 aPosition;
        attribute vec3 aNormal;
        uniform mat4 uMvpMatrix;
        uniform mat4 uModelMatrix;
        varying vec3 vNormal;
        varying vec3 vPosition;

        void main() {
            gl_Position = uMvpMatrix * aPosition;
            vNormal = vec3(uModelMatrix * vec4(aNormal, 0.0));
            vPosition = vec3(uModelMatrix * aPosition);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;
        varying vec3 vNormal;
        varying vec3 vPosition;
        uniform vec3 uLightPos;
        uniform float uTime;

        void main() {
            vec3 normal = normalize(vNormal);
            vec3 lightDir = normalize(uLightPos - vPosition);
            
            // Basic Diffuse
            float diff = max(dot(normal, lightDir), 0.2);
            vec3 baseColor = vec3(0.3, 0.2, 0.1); // Wooden brown
            
            // Glowing "Inner Light" effect
            // We use a sine wave to pulse the intensity
            float pulse = (sin(uTime * 3.0) * 0.5) + 0.5;
            vec3 glowColor = vec4(1.0, 0.8, 0.0, 1.0).rgb; // Golden glow
            
            // Add glow based on height (simulating light leaking from the lid)
            float glowMask = smoothstep(0.0, 0.2, vPosition.y) * smoothstep(0.5, 0.3, vPosition.y);
            vec3 finalColor = (baseColor * diff) + (glowColor * glowMask * pulse * 1.5);
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script>
        const canvas = document.querySelector('#glCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) { alert('WebGL not supported'); }

        // Shader setup helper
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
        gl.linkProgram(program);
        gl.useProgram(program);

        // Cube Geometry (Simplified Chest)
        const vertices = new Float32Array([
            -0.5,-0.5,0.5, 0.5,-0.5,0.5, 0.5,0.5,0.5, -0.5,0.5,0.5, // Front
            -0.5,-0.5,-0.5, -0.5,0.5,-0.5, 0.5,0.5,-0.5, 0.5,-0.5,-0.5 // Back
        ]);
        const indices = new Uint16Array([
            0,1,2, 0,2,3, 4,5,6, 4,6,7, 3,2,6, 3,6,5, 0,1,7, 0,7,4, 1,2,6, 1,6,7, 0,3,5, 0,5,4
        ]);
        
        // Normals (simplified for a cube)
        const normals = new Float32Array([
            0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1
        ]);

        function initBuffer(data, attribute, size) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
            const loc = gl.getAttribLocation(program, attribute);
            gl.enableVertexAttribArray(loc);
            gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
        }

        initBuffer(vertices, 'aPosition', 3);
        initBuffer(normals, 'aNormal', 3);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        // Matrices
        const uMvpMatrix = gl.getUniformLocation(program, 'uMvpMatrix');
        const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
        const uLightPos = gl.getUniformLocation(program, 'uLightPos');
        const uTime = gl.getUniformLocation(program, 'uTime');

        const projMatrix = mat4.create();
        const viewMatrix = mat4.create();
        const modelMatrix = mat4.create();
        const mvpMatrix = mat4.create();

        mat4.perspective(projMatrix, 45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100.0);
        mat4.lookAt(viewMatrix, [2, 2, 5], [0, 0, 0], [0, 1, 0]);

        function render(time) {
            time *= 0.001; // Convert to seconds
            
            gl.viewport(0, 0, canvas.width = window.innerWidth, canvas.height = window.innerHeight);
            gl.clearColor(0.02, 0.02, 0.05, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.fromRotation(modelMatrix, time * 0.5, [0, 1, 0]);
            mat4.multiply(mvpMatrix, projMatrix, viewMatrix);
            mat4.multiply(mvpMatrix, mvpMatrix, modelMatrix);

            gl.uniformMatrix4fv(uMvpMatrix, false, mvpMatrix);
            gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
            gl.uniform3f(uLightPos, 2.0, 4.0, 3.0);
            gl.uniform1f(uTime, time);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>

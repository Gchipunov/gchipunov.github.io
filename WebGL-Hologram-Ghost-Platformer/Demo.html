<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Hologram Ghost Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 10px; left: 10px; color: #00f2ff; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">ARROWS to Move | SPACE to Jump</div>
    <canvas id="glCanvas"></canvas>

<script>
/**
 * SHADER SOURCES
 */
const VERTEX_SHADER_SRC = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    void main() {
        vec2 scaledPosition = a_position * u_scale;
        vec2 position = scaledPosition + u_translation;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;

const HOLOGRAM_FRAG_SRC = `
    precision mediump float;
    uniform float u_time;
    uniform vec4 u_color;
    void main() {
        // Create scanlines based on screen Y
        float scanline = sin(gl_FragCoord.y * 0.8 + u_time * 10.0) * 0.2 + 0.8;
        
        // Rapid flickering effect
        float flicker = clamp(sin(u_time * 50.0) * 0.1 + 0.9, 0.0, 1.0);
        
        // Edge glow (simulated)
        float alpha = u_color.a * scanline * flicker;
        
        gl_FragColor = vec4(u_color.rgb, alpha);
    }
`;

const FLAT_FRAG_SRC = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

/**
 * WEBGL HELPER CLASS
 */
class ShaderProgram {
    constructor(gl, vsSource, fsSource) {
        const vs = this.compile(gl, gl.VERTEX_SHADER, vsSource);
        const fs = this.compile(gl, gl.FRAGMENT_SHADER, fsSource);
        this.program = gl.createProgram();
        gl.attachShader(this.program, vs);
        gl.attachShader(this.program, fs);
        gl.linkProgram(this.program);
        
        this.attribs = {
            position: gl.getAttribLocation(this.program, "a_position"),
        };
        this.uniforms = {
            resolution: gl.getUniformLocation(this.program, "u_resolution"),
            translation: gl.getUniformLocation(this.program, "u_translation"),
            scale: gl.getUniformLocation(this.program, "u_scale"),
            color: gl.getUniformLocation(this.program, "u_color"),
            time: gl.getUniformLocation(this.program, "u_time"),
        };
    }
    compile(gl, type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        return s;
    }
}

/**
 * GAME ENGINE
 */
const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl");

// Setup Blending for the "Ghost" transparency
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending for glow

const holoShader = new ShaderProgram(gl, VERTEX_SHADER_SRC, HOLOGRAM_FRAG_SRC);
const flatShader = new ShaderProgram(gl, VERTEX_SHADER_SRC, FLAT_FRAG_SRC);

// Create a simple unit quad buffer
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0,  1, 0,  0, 1,
    0, 1,  1, 0,  1, 1,
]), gl.STATIC_DRAW);

// Game State
const player = {
    x: 100, y: 100,
    w: 30, h: 50,
    vx: 0, vy: 0,
    grounded: false
};

const platforms = [
    {x: 0, y: 550, w: 2000, h: 50}, // Ground
    {x: 200, y: 400, w: 150, h: 20},
    {x: 450, y: 300, w: 150, h: 20},
    {x: 150, y: 200, w: 150, h: 20}
];

const keys = {};
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;

function update() {
    // Movement
    if (keys['ArrowLeft']) player.vx -= 0.8;
    if (keys['ArrowRight']) player.vx += 0.8;
    if (keys['Space'] && player.grounded) {
        player.vy = -12;
        player.grounded = false;
    }

    // Physics
    player.vy += 0.5; // Gravity
    player.x += player.vx;
    player.y += player.vy;
    player.vx *= 0.9; // Friction

    // Collision
    player.grounded = false;
    platforms.forEach(p => {
        if (player.x < p.x + p.w && player.x + player.w > p.x &&
            player.y + player.h > p.y && player.y + player.h < p.y + p.h + 10 &&
            player.vy >= 0) {
            player.y = p.y - player.h;
            player.vy = 0;
            player.grounded = true;
        }
    });

    // Wrap around screen
    if (player.x > canvas.width) player.x = -player.w;
    if (player.x < -player.w) player.x = canvas.width;
}

function draw(time) {
    update();
    
    // Resize
    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    gl.clearColor(0.02, 0.02, 0.05, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // 1. Draw Platforms (Flat Shader)
    gl.useProgram(flatShader.program);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(flatShader.attribs.position);
    gl.vertexAttribPointer(flatShader.attribs.position, 2, gl.FLOAT, false, 0, 0);
    
    gl.uniform2f(flatShader.uniforms.resolution, canvas.width, canvas.height);
    gl.uniform4f(flatShader.uniforms.color, 0.2, 0.2, 0.3, 1.0);

    platforms.forEach(p => {
        gl.uniform2f(flatShader.uniforms.translation, p.x, p.y);
        gl.uniform2f(flatShader.uniforms.scale, p.w, p.h);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    });

    // 2. Draw Player (Hologram Shader)
    gl.useProgram(holoShader.program);
    gl.uniform2f(holoShader.uniforms.resolution, canvas.width, canvas.height);
    gl.uniform2f(holoShader.uniforms.translation, player.x, player.y);
    gl.uniform2f(holoShader.uniforms.scale, player.w, player.h);
    gl.uniform4f(holoShader.uniforms.color, 0.0, 0.9, 1.0, 0.7); // Cyan ghost
    gl.uniform1f(holoShader.uniforms.time, time * 0.001);
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>
</body>
</html>

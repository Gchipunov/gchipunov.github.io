<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer</title>
    <style>
        /* Basic styling to make the canvas and controls fill the screen */
        body { 
            margin: 0; 
            background-color: #000;
            overflow: hidden; /* Prevents scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
        }
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }
        /* Styles for the on-screen touch controls */
        #touch-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            user-select: none; /* Prevents text selection on buttons */
        }
        .control-group {
            display: flex;
            gap: 20px;
        }
        .control-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        /* Style for when a button is being pressed */
        .control-button:active {
            background-color: rgba(255, 255, 255, 0.6);
        }
        /* Gemini Button Style */
        .gemini-style {
            background-color: rgba(138, 43, 226, 0.4); /* Purple */
            border-color: rgba(138, 43, 226, 0.8);
        }
        .gemini-style:active {
            background-color: rgba(138, 43, 226, 0.7);
        }

        /* Styles for the message box that displays Gemini's response */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 80%;
            text-align: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        /* Loading indicator for API calls */
        #loading-indicator {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 101;
        }

        @keyframes spin {
            0% { transform: translateX(-50%) rotate(0deg); }
            100% { transform: translateX(-50%) rotate(360deg); }
        }

        /* Utility class to hide elements */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- The canvas where the game is rendered -->
    <canvas id="glCanvas"></canvas>

    <!-- HTML elements for the on-screen touch controls -->
    <div id="touch-controls">
        <div class="control-group">
            <div id="left-btn" class="control-button">◀</div>
            <div id="right-btn" class="control-button">▶</div>
        </div>
        <div class="control-group">
            <!-- ✨ Gemini API trigger button -->
            <div id="gemini-btn" class="control-button gemini-style hidden">✨</div>
            <div id="action-btn" class="control-button">E</div>
            <div id="jump-btn" class="control-button">▲</div>
        </div>
    </div>

    <!-- Element to show loading state -->
    <div id="loading-indicator" class="hidden"></div>
    <!-- Element to display messages from the Gemini API -->
    <div id="message-box" class="hidden"></div>

    <script>
        // Entry point
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                const msgBox = document.getElementById('message-box');
                msgBox.textContent = 'Unable to initialize WebGL. Your browser may not support it.';
                msgBox.classList.remove('hidden');
                return;
            }

            // --- 1. Shaders (GLSL Code) ---
            const vsSource = `
                attribute vec4 aVertexPosition;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 uObjectColor;
                void main() {
                    gl_FragColor = uObjectColor;
                }
            `;

            // --- 2. Shader Program Setup ---
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            const programInfo = {
                program: shaderProgram,
                attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition') },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    objectColor: gl.getUniformLocation(shaderProgram, 'uObjectColor'),
                },
            };

            // --- 3. Geometry Buffer ---
            const squareBuffer = initBuffers(gl);

            // --- 4. Game State and Objects ---
            const player = {
                x: 100, y: 300, width: 30, height: 30,
                vx: 0, vy: 0,
                color: [1.0, 1.0, 1.0, 1.0], // White
                canJump: false,
                hasTrash: false
            };
            const trashCan = { x: 600, y: 100, width: 25, height: 40, color: [0.1, 0.8, 0.2, 1.0] };
            const platforms = [
                { x: 0, y: 0, width: 800, height: 50, color: [0.5, 0.5, 0.5, 1.0] }, // Floor
                { x: 200, y: 150, width: 150, height: 20, color: [0.5, 0.5, 0.5, 1.0] },
                { x: 450, y: 250, width: 200, height: 20, color: [0.5, 0.5, 0.5, 1.0] },
                { x: 50, y: 350, width: 100, height: 20, color: [0.5, 0.5, 0.5, 1.0] }
            ];

            // --- 5. Game Logic Variables ---
            const gravity = -0.5;
            const jumpStrength = 12;
            const moveSpeed = 5;
            let keys = {};
            let isApiCallInProgress = false;

            // --- 6. Input Handling ---
            window.addEventListener('keydown', (e) => { keys[e.key] = true; });
            window.addEventListener('keyup', (e) => { keys[e.key] = false; });
            setupTouchControls();

            // --- 7. Main Game Loop ---
            let lastTime = 0;
            function gameLoop(currentTime) {
                currentTime *= 0.001;
                update(currentTime - lastTime);
                lastTime = currentTime;
                drawScene(gl, programInfo, squareBuffer);
                requestAnimationFrame(gameLoop);
            }

            // --- 8. Update Function ---
            function update(deltaTime) {
                const prevPlayerY = player.y;
                player.vx = 0;
                if (keys['a'] || keys['ArrowLeft']) player.vx = -moveSpeed;
                if (keys['d'] || keys['ArrowRight']) player.vx = moveSpeed;
                player.x += player.vx;

                if ((keys['w'] || keys['ArrowUp'] || keys[' ']) && player.canJump) {
                    player.vy = jumpStrength;
                    player.canJump = false;
                }
                
                if (keys['e']) {
                    const dist = Math.hypot(player.x - trashCan.x, player.y - trashCan.y);
                    if (dist < 50 && !player.hasTrash) {
                        player.hasTrash = true;
                    } else if (player.hasTrash) {
                        player.hasTrash = false;
                        trashCan.x = player.x + player.width;
                    }
                    keys['e'] = false;
                }

                player.vy += gravity;
                player.y += player.vy;

                player.canJump = false;
                for (const platform of platforms) {
                    if (isColliding(player, platform)) {
                        if (player.vy <= 0 && prevPlayerY >= (platform.y + platform.height)) {
                           player.y = platform.y + platform.height;
                           player.vy = 0;
                           player.canJump = true;
                           break;
                        }
                    }
                }
                
                const geminiBtn = document.getElementById('gemini-btn');
                if (player.hasTrash) {
                    trashCan.x = player.x;
                    trashCan.y = player.y + player.height;
                    geminiBtn.classList.remove('hidden');
                } else {
                    geminiBtn.classList.add('hidden');
                }
            }

            // --- 9. Drawing Function ---
            function drawScene(gl, programInfo, buffer) {
                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0.1, 0.1, 0.2, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                const projectionMatrix = mat4.create();
                mat4.ortho(projectionMatrix, 0, gl.canvas.width, 0, gl.canvas.height, -1, 1);
                gl.useProgram(programInfo.program);
                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

                platforms.forEach(p => drawObject(gl, programInfo, buffer, p));
                drawObject(gl, programInfo, buffer, trashCan);
                drawObject(gl, programInfo, buffer, player);
            }

            // --- 10. Touch Control Setup ---
            function setupTouchControls() {
                const controls = {
                    'left-btn': 'ArrowLeft', 'right-btn': 'ArrowRight',
                    'jump-btn': ' ', 'action-btn': 'e'
                };
                for (const [id, key] of Object.entries(controls)) {
                    const btn = document.getElementById(id);
                    btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; }, { passive: false });
                    btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, { passive: false });
                }
                // Gemini button has a special click handler
                const geminiBtn = document.getElementById('gemini-btn');
                geminiBtn.addEventListener('touchstart', (e) => { e.preventDefault(); getTrashFact(); }, { passive: false });
            }

            // --- 11. ✨ Gemini API Integration ---
            async function getTrashFact() {
                if (isApiCallInProgress) return;
                isApiCallInProgress = true;

                const loadingIndicator = document.getElementById('loading-indicator');
                const messageBox = document.getElementById('message-box');
                loadingIndicator.classList.remove('hidden');
                messageBox.classList.add('hidden');

                const prompt = "Tell me a very short, kid-friendly, one-sentence fun fact or joke about trash, recycling, or garbage cans.";
                let responseText = "Sorry, my brain is a bit trashy right now!";

                try {
                    const text = await callGeminiWithBackoff(prompt);
                    if (text) {
                        responseText = text;
                    }
                } catch (error) {
                    console.error("Gemini API call failed:", error);
                } finally {
                    loadingIndicator.classList.add('hidden');
                    messageBox.textContent = responseText;
                    messageBox.classList.remove('hidden');
                    isApiCallInProgress = false;
                    setTimeout(() => {
                        messageBox.classList.add('hidden');
                    }, 5000); // Message disappears after 5 seconds
                }
            }
            
            async function callGeminiWithBackoff(prompt, maxRetries = 3) {
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiKey = ""; // API key is handled by the environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const result = await response.json();
                        if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                            return result.candidates[0].content.parts[0].text;
                        } else {
                             throw new Error("Invalid response structure from API.");
                        }
                    } catch (error) {
                        if (i === maxRetries - 1) throw error;
                        const delay = Math.pow(2, i) * 1000; // Exponential backoff: 1s, 2s, 4s
                        await new Promise(res => setTimeout(res, delay));
                    }
                }
            }


            // Start the game
            requestAnimationFrame(gameLoop);
        }

        // ===================================================================
        //                      HELPER FUNCTIONS
        // ===================================================================
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Shader program link error:', gl.getProgramInfoLog(shaderProgram)); return null;
            }
            return shaderProgram;
        }
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null;
            }
            return shader;
        }
        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return positionBuffer;
        }
        function drawObject(gl, programInfo, buffer, object) {
            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [object.x + object.width / 2, object.y + object.height / 2, 0]);
            mat4.scale(modelViewMatrix, modelViewMatrix, [object.width, object.height, 1]);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
            gl.uniform4fv(programInfo.uniformLocations.objectColor, object.color);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }
        const mat4 = {
          create: function() { return new Float32Array(16); },
          ortho: function(out, left, right, bottom, top, near, far) {
            let lr = 1 / (left - right); let bt = 1 / (bottom - top); let nf = 1 / (near - far);
            out[0] = -2 * lr; out[1] = 0; out[2] = 0; out[3] = 0; out[4] = 0; out[5] = -2 * bt; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = 2 * nf; out[11] = 0;
            out[12] = (left + right) * lr; out[13] = (top + bottom) * bt; out[14] = (far + near) * nf; out[15] = 1;
            return out;
          },
          translate: function(out, a, v) {
            let x = v[0], y = v[1];
            out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3]; out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
            out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
            out[12] = a[0] * x + a[4] * y + a[8] * v[2] + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * v[2] + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * v[2] + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * v[2] + a[15];
            return out;
          },
          scale: function(out, a, v) {
            out[0] = a[0] * v[0]; out[1] = a[1] * v[0]; out[2] = a[2] * v[0]; out[3] = a[3] * v[0];
            out[4] = a[4] * v[1]; out[5] = a[5] * v[1]; out[6] = a[6] * v[1]; out[7] = a[7] * v[1];
            out[8] = a[8] * v[2]; out[9] = a[9] * v[2]; out[10] = a[10] * v[2]; out[11] = a[11] * v[2];
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
          }
        };
    </script>
</body>
</html>

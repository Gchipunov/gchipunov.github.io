<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL SPH Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
    // ========= Main Setup =========
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
        alert('WebGL not supported!');
    }

    // Vertex shader for simple colored objects
    const vsSource = `
        attribute vec4 aVertexPosition;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        }
    `;

    // Fragment shader for simple colored objects
    const fsSource = `
        precision mediump float;
        uniform vec4 uColor;
        void main(void) {
            gl_FragColor = uColor;
        }
    `;
    
    // Vertex shader for particles
    const vsParticleSource = `
        attribute vec4 aVertexPosition;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
            gl_PointSize = 4.0;
        }
    `;

    // Helper to compile shaders and link program
    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
    const particleShaderProgram = initShaderProgram(gl, vsParticleSource, fsSource);

    const programInfo = {
        program: shaderProgram,
        attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
        },
        uniformLocations: {
            projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            color: gl.getUniformLocation(shaderProgram, 'uColor'),
        },
    };
    
    const particleProgramInfo = {
        program: particleShaderProgram,
        attribLocations: {
            vertexPosition: gl.getAttribLocation(particleShaderProgram, 'aVertexPosition'),
        },
        uniformLocations: {
            projectionMatrix: gl.getUniformLocation(particleShaderProgram, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(particleShaderProgram, 'uModelViewMatrix'),
            color: gl.getUniformLocation(particleShaderProgram, 'uColor'),
        },
    };


    // ========= AABB Cube & Geometry =========
    function createCubeBuffer(gl) {
        const positions = [
            // Front face
            -0.5, -0.5,  0.5, 0.5, -0.5,  0.5, 0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
            // Back face
            -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, 0.5,  0.5, -0.5, 0.5, -0.5, -0.5,
            // Top face
            -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, 0.5,  0.5,  0.5, 0.5,  0.5, -0.5,
            // Bottom face
            -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
            // Right face
             0.5, -0.5, -0.5, 0.5,  0.5, -0.5, 0.5,  0.5,  0.5, 0.5, -0.5,  0.5,
            // Left face
            -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5,
        ];
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        
        const indices = [
            0,  1,  2,      0,  2,  3,    // front
            4,  5,  6,      4,  6,  7,    // back
            8,  9,  10,     8,  10, 11,   // top
            12, 13, 14,     12, 14, 15,   // bottom
            16, 17, 18,     16, 18, 19,   // right
            20, 21, 22,     20, 22, 23,   // left
        ];
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        return { position: positionBuffer, indices: indexBuffer };
    }

    const cubeBuffer = createCubeBuffer(gl);

    // Simple matrix library (gl-matrix is recommended for real projects)
    const mat4 = {
        create: () => new Float32Array(16),
        identity: (out) => { out.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return out; },
        perspective: (out, fovy, aspect, near, far) => {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
            return out;
        },
        translate: (out, a, v) => {
            let x = v[0], y = v[1], z = v[2];
            let a00, a01, a02, a03; let a10, a11, a12, a13;
            let a20, a21, a22, a23;
            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
                out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
            }
            return out;
        },
        scale: (out, a, v) => {
            let x = v[0], y = v[1], z = v[2];
            out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
            out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
            out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
        }
    };

    // ========= Platformer Logic =========
    const player = {
        pos: [0, 1.5, 0],
        vel: [0, 0, 0],
        size: [1, 1, 1],
        onGround: false,
        color: [1.0, 0.5, 0.2, 1.0] // Orange
    };

    const platforms = [
        { pos: [0, -2, 0], size: [20, 1, 20], color: [0.5, 0.5, 0.5, 1.0] }, // Ground
        { pos: [-8, 2, 0], size: [6, 1, 6], color: [0.4, 0.6, 0.4, 1.0] },
        { pos: [8, 4, 0], size: [6, 1, 6], color: [0.4, 0.4, 0.6, 1.0] },
        { pos: [0, 8, 0], size: [8, 1, 8], color: [0.6, 0.4, 0.4, 1.0] }  // Waterfall source platform
    ];

    const keys = {};
    window.addEventListener('keydown', (e) => keys[e.code] = true);
    window.addEventListener('keyup', (e) => keys[e.code] = false);

    const GRAVITY = -0.015;
    const JUMP_STRENGTH = 0.4;
    const MOVE_SPEED = 0.1;
    
    function updatePlayer(dt) {
        // Horizontal movement
        if (keys['KeyA'] || keys['ArrowLeft']) player.vel[0] = -MOVE_SPEED;
        else if (keys['KeyD'] || keys['ArrowRight']) player.vel[0] = MOVE_SPEED;
        else player.vel[0] = 0;

        // Apply gravity
        player.vel[1] += GRAVITY;
        
        // Jumping
        if ((keys['Space'] || keys['KeyW'] || keys['ArrowUp']) && player.onGround) {
            player.vel[1] = JUMP_STRENGTH;
            player.onGround = false;
        }

        // Update position based on velocity
        player.pos[0] += player.vel[0];
        player.pos[1] += player.vel[1];

        // Collision detection
        player.onGround = false;
        platforms.forEach(p => checkCollision(player, p));
    }
    
    // AABB Collision Check and Resolution
    function checkCollision(objA, objB) {
        const a_min = [objA.pos[0] - objA.size[0]/2, objA.pos[1] - objA.size[1]/2];
        const a_max = [objA.pos[0] + objA.size[0]/2, objA.pos[1] + objA.size[1]/2];
        const b_min = [objB.pos[0] - objB.size[0]/2, objB.pos[1] - objB.size[1]/2];
        const b_max = [objB.pos[0] + objB.size[0]/2, objB.pos[1] + objB.size[1]/2];

        if (a_max[0] > b_min[0] && a_min[0] < b_max[0] &&
            a_max[1] > b_min[1] && a_min[1] < b_max[1]) {

            // Collision detected, resolve it. This is a simple but effective resolution.
            const overlapX1 = b_max[0] - a_min[0];
            const overlapX2 = a_max[0] - b_min[0];
            const overlapY1 = b_max[1] - a_min[1];
            const overlapY2 = a_max[1] - b_min[1];

            const minOverlapX = Math.min(overlapX1, overlapX2);
            const minOverlapY = Math.min(overlapY1, overlapY2);

            if (minOverlapY < minOverlapX) {
                // Vertical collision is smaller, resolve vertically
                if (overlapY1 < overlapY2) { // Player is coming from below
                    objA.pos[1] = b_max[1] + objA.size[1] / 2;
                    if (objA.vel[1] < 0) objA.vel[1] = 0; // Stop downward movement
                    objA.onGround = true; // Landed on top
                } else { // Player is coming from above
                    objA.pos[1] = b_min[1] - objA.size[1] / 2;
                    if (objA.vel[1] > 0) objA.vel[1] = 0; // Hit ceiling
                }
            } else {
                // Horizontal collision is smaller, resolve horizontally
                if (overlapX1 < overlapX2) {
                    objA.pos[0] = b_max[0] + objA.size[0] / 2;
                } else {
                    objA.pos[0] = b_min[0] - objA.size[0] / 2;
                }
            }
        }
    }


    // ========= SPH Simulation =========
    const SPH_PARAMS = {
        PARTICLE_COUNT: 400,
        H: 1.0,          // Smoothing radius
        H2: 1.0 * 1.0,
        GAS_CONST: 2000.0, // Gas constant for pressure calculation
        REST_DENSITY: 30.0, // Rest density of the fluid
        VISCOSITY: 250.0,   // Viscosity constant
        MASS: 65.0,
        DT: 0.0007,      // Timestep for simulation (smaller is more stable)
        GRAVITY: [0, -9.8 * 150, 0] // Stronger gravity for fluid
    };

    // Pre-calculate kernel constants
    SPH_PARAMS.POLY6 = 315.0 / (64.0 * Math.PI * Math.pow(SPH_PARAMS.H, 9));
    SPH_PARAMS.SPIKY_GRAD = -45.0 / (Math.PI * Math.pow(SPH_PARAMS.H, 6));
    SPH_PARAMS.VISC_LAP = 45.0 / (Math.PI * Math.pow(SPH_PARAMS.H, 6));
    
    class SPHSolver {
        constructor() {
            this.particles = [];
            this.particleBuffer = gl.createBuffer();
            this.particlePositions = new Float32Array(SPH_PARAMS.PARTICLE_COUNT * 3);

            for (let i = 0; i < SPH_PARAMS.PARTICLE_COUNT; i++) {
                this.particles.push({
                    pos: [Math.random() * 4 - 2, 9.5 + Math.random(), 0],
                    vel: [0, 0, 0],
                    force: [0, 0, 0],
                    density: 0,
                    pressure: 0
                });
            }
        }

        computeDensityPressure() {
            for (let i = 0; i < this.particles.length; i++) {
                const pi = this.particles[i];
                pi.density = 0;
                for (let j = 0; j < this.particles.length; j++) {
                    const pj = this.particles[j];
                    const r_vec = [pi.pos[0] - pj.pos[0], pi.pos[1] - pj.pos[1], pi.pos[2] - pj.pos[2]];
                    const r2 = r_vec[0]*r_vec[0] + r_vec[1]*r_vec[1] + r_vec[2]*r_vec[2];

                    if (r2 < SPH_PARAMS.H2) {
                        // Poly6 Kernel: W_poly6(r) = (h^2 - r^2)^3
                        pi.density += SPH_PARAMS.MASS * SPH_PARAMS.POLY6 * Math.pow(SPH_PARAMS.H2 - r2, 3);
                    }
                }
                // Pressure from density (using ideal gas state equation)
                // p = k * (rho - rho_0)
                pi.pressure = SPH_PARAMS.GAS_CONST * (pi.density - SPH_PARAMS.REST_DENSITY);
            }
        }

        computeForces() {
            for (let i = 0; i < this.particles.length; i++) {
                const pi = this.particles[i];
                let f_pressure = [0, 0, 0];
                let f_viscosity = [0, 0, 0];
                
                for (let j = 0; j < this.particles.length; j++) {
                    if (i === j) continue;
                    const pj = this.particles[j];
                    const r_vec = [pi.pos[0] - pj.pos[0], pi.pos[1] - pj.pos[1], pi.pos[2] - pj.pos[2]];
                    const r2 = r_vec[0]*r_vec[0] + r_vec[1]*r_vec[1] + r_vec[2]*r_vec[2];
                    
                    if (r2 < SPH_PARAMS.H2) {
                        const r = Math.sqrt(r2);
                        // Pressure force (using Spiky kernel gradient)
                        // F = - (p_i + p_j) / (2 * rho_j) * grad(W_spiky)
                        const pressure_term = SPH_PARAMS.MASS * (pi.pressure + pj.pressure) / (2 * pj.density);
                        const spiky_grad_term = SPH_PARAMS.SPIKY_GRAD * Math.pow(SPH_PARAMS.H - r, 2) / r;

                        f_pressure[0] += pressure_term * spiky_grad_term * r_vec[0];
                        f_pressure[1] += pressure_term * spiky_grad_term * r_vec[1];
                        
                        // Viscosity force (using Viscosity kernel laplacian)
                        // F = mu * (v_j - v_i) / rho_j * laplacian(W_visc)
                        const visc_term = SPH_PARAMS.VISCOSITY * SPH_PARAMS.MASS / pj.density;
                        const visc_lap_term = SPH_PARAMS.VISC_LAP * (SPH_PARAMS.H - r);

                        f_viscosity[0] += visc_term * (pj.vel[0] - pi.vel[0]) * visc_lap_term;
                        f_viscosity[1] += visc_term * (pj.vel[1] - pi.vel[1]) * visc_lap_term;
                    }
                }

                // Total force is pressure + viscosity + external (gravity)
                pi.force[0] = f_pressure[0] + f_viscosity[0] + SPH_PARAMS.GRAVITY[0];
                pi.force[1] = f_pressure[1] + f_viscosity[1] + SPH_PARAMS.GRAVITY[1];
            }
        }
        
        integrate() {
            for (const p of this.particles) {
                // Update velocity (Forward Euler integration)
                // v(t+dt) = v(t) + a(t)*dt = v(t) + (F/m)*dt
                p.vel[0] += p.force[0] / p.density * SPH_PARAMS.DT;
                p.vel[1] += p.force[1] / p.density * SPH_PARAMS.DT;

                // Update position
                // x(t+dt) = x(t) + v(t+dt)*dt
                p.pos[0] += p.vel[0] * SPH_PARAMS.DT;
                p.pos[1] += p.vel[1] * SPH_PARAMS.DT;

                // Boundary conditions (collision with platforms)
                this.handleParticleCollisions(p);

                // Simple floor collision & particle reset for waterfall effect
                if (p.pos[1] < -1.5) {
                   p.pos = [Math.random() * 4 - 2, 9.5 + Math.random() * 2, 0];
                   p.vel = [0, -10, 0]; // Give it some initial downward velocity
                }
            }
        }
        
        handleParticleCollisions(p) {
            const DAMPING = -0.5; // How much velocity is lost on impact
            
            // Player collision (treat player as a moving box)
            const playerBounds = {
                min: [player.pos[0] - player.size[0]/2, player.pos[1] - player.size[1]/2],
                max: [player.pos[0] + player.size[0]/2, player.pos[1] + player.size[1]/2],
            };
            if (p.pos[0] > playerBounds.min[0] && p.pos[0] < playerBounds.max[0] &&
                p.pos[1] > playerBounds.min[1] && p.pos[1] < playerBounds.max[1]) {
                 // A simple push based on particle velocity - very basic interaction
                 player.vel[0] += p.vel[0] * 0.001;
                 player.vel[1] += p.vel[1] * 0.001;
            }

            // Platform collisions
            for (const plat of platforms) {
                const bounds = {
                    min: [plat.pos[0] - plat.size[0]/2, plat.pos[1] - plat.size[1]/2],
                    max: [plat.pos[0] + plat.size[0]/2, plat.pos[1] + plat.size[1]/2],
                };
                if (p.pos[0] > bounds.min[0] && p.pos[0] < bounds.max[0] &&
                    p.pos[1] > bounds.min[1] && p.pos[1] < bounds.max[1]) {
                    
                    // Particle is inside a platform, find which face is closest and push it out
                    const dists = [
                        Math.abs(p.pos[0] - bounds.min[0]),
                        Math.abs(p.pos[0] - bounds.max[0]),
                        Math.abs(p.pos[1] - bounds.min[1]),
                        Math.abs(p.pos[1] - bounds.max[1])
                    ];
                    
                    const minDist = Math.min(...dists);

                    if (minDist === dists[0]) { p.pos[0] = bounds.min[0]; p.vel[0] *= DAMPING; }
                    else if (minDist === dists[1]) { p.pos[0] = bounds.max[0]; p.vel[0] *= DAMPING; }
                    else if (minDist === dists[2]) { p.pos[1] = bounds.min[1]; p.vel[1] *= DAMPING; }
                    else if (minDist === dists[3]) { p.pos[1] = bounds.max[1]; p.vel[1] *= DAMPING; }
                }
            }
        }

        update() {
            this.computeDensityPressure();
            this.computeForces();
            this.integrate();

            // Update buffer for rendering
            for (let i = 0; i < this.particles.length; i++) {
                this.particlePositions[i * 3 + 0] = this.particles[i].pos[0];
                this.particlePositions[i * 3 + 1] = this.particles[i].pos[1];
                this.particlePositions[i * 3 + 2] = this.particles[i].pos[2];
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.particleBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this.particlePositions, gl.DYNAMIC_DRAW);
        }

        draw(projectionMatrix, viewMatrix) {
            gl.useProgram(particleProgramInfo.program);
            
            gl.uniformMatrix4fv(particleProgramInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(particleProgramInfo.uniformLocations.modelViewMatrix, false, viewMatrix);
            gl.uniform4fv(particleProgramInfo.uniformLocations.color, [0.2, 0.6, 1.0, 1.0]); // Blue particles

            gl.bindBuffer(gl.ARRAY_BUFFER, this.particleBuffer);
            gl.vertexAttribPointer(particleProgramInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(particleProgramInfo.attribLocations.vertexPosition);
            
            gl.drawArrays(gl.POINTS, 0, SPH_PARAMS.PARTICLE_COUNT);
        }
    }

    const sphSolver = new SPHSolver();

    // ========= Main Render Loop =========
    function drawScene() {
        gl.clearColor(0.1, 0.1, 0.15, 1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const fieldOfView = 45 * Math.PI / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
        
        const viewMatrix = mat4.create();
        mat4.identity(viewMatrix);
        mat4.translate(viewMatrix, viewMatrix, [-0.0, -2.0, -30.0]); // Camera position

        // Draw platforms
        platforms.forEach(p => drawCube(projectionMatrix, viewMatrix, p.pos, p.size, p.color));
        
        // Draw player
        drawCube(projectionMatrix, viewMatrix, player.pos, player.size, player.color);

        // Draw SPH particles
        sphSolver.draw(projectionMatrix, viewMatrix);
    }
    
    function drawCube(projectionMatrix, viewMatrix, position, scale, color) {
        gl.useProgram(programInfo.program);
        
        const modelViewMatrix = mat4.create();
        mat4.translate(modelViewMatrix, viewMatrix, position);
        mat4.scale(modelViewMatrix, modelViewMatrix, scale);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer.position);
        gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeBuffer.indices);

        gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
        gl.uniform4fv(programInfo.uniformLocations.color, color);
        
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
    }

    let lastTime = 0;
    function gameLoop(currentTime) {
        currentTime *= 0.001; // convert to seconds
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        // Update logic
        updatePlayer(deltaTime);
        
        // SPH simulation can be sensitive, so we run it in fixed sub-steps
        const steps = 4;
        for(let i = 0; i < steps; i++) {
            sphSolver.update();
        }

        // Render scene
        drawScene();

        requestAnimationFrame(gameLoop);
    }

    // Start the game loop
    requestAnimationFrame(gameLoop);

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2D Platformer with Ray-Melt</title>
    <style>
        body { 
            margin: 0; 
            background-color: #1a1a1a; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            overflow: hidden; /* Prevents scroll bars */
        }
        canvas { 
            background-color: #000; 
            border: 2px solid #555; 
            touch-action: none; /* Prevents default touch actions like zoom/pan */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Settings
        const gravity = 0.5;
        const playerSpeed = 5;
        const jumpPower = 12;

        // --- Input Handlers ---
        const keys = {};
        window.addEventListener('keydown', (e) => { keys[e.code] = true; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });

        // --- Touch Controls State ---
        const touchControls = {
            left: false,
            right: false,
            jump: false,
            // 'shoot' is handled by tap, not continuous press
            activeTouches: {}
        };

        // --- Touch Event Listeners ---
        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function handleTouchStart(evt) {
            evt.preventDefault();
            const touches = evt.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const pos = getTouchPos(canvas, touch);
                touchControls.activeTouches[touch.identifier] = pos;

                // Left side of screen for movement
                if (pos.x < canvas.width / 2) {
                    if (pos.x < canvas.width / 4) {
                        touchControls.left = true;
                    } else {
                        touchControls.right = true;
                    }
                } else { // Right side of screen for actions
                    if (pos.y < canvas.height / 2) {
                        touchControls.jump = true;
                    } else {
                        // Handle shooting as a discrete tap event
                        if (player.shootCooldown <= 0) {
                            fireBullet(player, 1); // 1 for right direction
                            player.shootCooldown = 20;
                        }
                    }
                }
            }
        }
        
        function handleTouchEnd(evt) {
            evt.preventDefault();
            const touches = evt.changedTouches;
            for (let i = 0; i < touches.length; i++) {
                const touch = touches[i];
                const pos = touchControls.activeTouches[touch.identifier];
                
                if (pos) {
                    // Stop movement/jump when finger is lifted
                    if (pos.x < canvas.width / 2) {
                        if (pos.x < canvas.width / 4) {
                            touchControls.left = false;
                        } else {
                            touchControls.right = false;
                        }
                    } else {
                        if (pos.y < canvas.height / 2) {
                            touchControls.jump = false;
                        }
                    }
                    delete touchControls.activeTouches[touch.identifier];
                }
            }
        }
        
        canvas.addEventListener('touchstart', handleTouchStart, false);
        canvas.addEventListener('touchend', handleTouchEnd, false);
        canvas.addEventListener('touchcancel', handleTouchEnd, false);


        // --- Game Objects ---
        let player = {
            x: 100, y: 500, width: 30, height: 50,
            vx: 0, vy: 0,
            color: '#00aaff',
            onGround: false,
            shootCooldown: 0,
            facing: 1 // 1 for right, -1 for left
        };

        let enemy = {
            x: 650, y: 500, width: 30, height: 50,
            vx: 2, vy: 0,
            color: '#ff4400',
            onGround: false,
            shootCooldown: 0,
            direction: -1 
        };

        let platforms = [
            { x: 0, y: 550, width: 800, height: 50, health: Infinity, maxHealth: Infinity },
            { x: 250, y: 450, width: 100, height: 30, health: 100, maxHealth: 100 },
            { x: 450, y: 400, width: 100, height: 30, health: 100, maxHealth: 100 },
            { x: 350, y: 300, width: 80, height: 80, health: 200, maxHealth: 200 }
        ];

        let bullets = [];

        // --- Ray-Casting Collision Logic ---
        function raycast(ray) {
            let closestHit = null;
            let minDistance = Infinity;

            for (const box of platforms) {
                const dx = ray.x2 - ray.x1;
                const dy = ray.y2 - ray.y1;

                for (let i = 0; i < 1; i += 0.01) {
                    const pointX = ray.x1 + dx * i;
                    const pointY = ray.y1 + dy * i;

                    if (pointX > box.x && pointX < box.x + box.width &&
                        pointY > box.y && pointY < box.y + box.height) {
                        const distance = Math.sqrt((pointX - ray.x1) ** 2 + (pointY - ray.y1) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestHit = box;
                        }
                        break;
                    }
                }
            }
            return closestHit;
        }
        
        // --- Helper function for shooting ---
        function fireBullet(shooter, direction) {
            bullets.push({
                x1: shooter.x + shooter.width / 2,
                y1: shooter.y + shooter.height / 2,
                x2: shooter.x + shooter.width / 2 + (1000 * direction),
                y2: shooter.y + shooter.height / 2,
                color: shooter.color,
                life: 0.1
            });
        }


        // --- Update Functions ---
        function updatePlayer() {
            // Horizontal Movement (Keyboard OR Touch)
            if (keys['KeyA'] || keys['ArrowLeft'] || touchControls.left) {
                player.vx = -playerSpeed;
                player.facing = -1;
            } else if (keys['KeyD'] || keys['ArrowRight'] || touchControls.right) {
                player.vx = playerSpeed;
                player.facing = 1;
            } else {
                player.vx = 0;
            }

            // Jumping (Keyboard OR Touch)
            if ((keys['KeyW'] || keys['ArrowUp'] || touchControls.jump) && player.onGround) {
                player.vy = -jumpPower;
                player.onGround = false;
            }

            // Keyboard Shooting
            if (keys['Space'] && player.shootCooldown <= 0) {
                fireBullet(player, player.facing);
                player.shootCooldown = 20;
            }
            if (player.shootCooldown > 0) player.shootCooldown--;


            // Apply physics
            player.y += player.vy;
            player.x += player.vx;
            player.vy += gravity;
            player.onGround = false;

            // Collision with platforms
            for (const p of platforms) {
                if (player.x < p.x + p.width && player.x + player.width > p.x &&
                    player.y < p.y + p.height && player.y + player.height > p.y)
                {
                    if (player.vy > 0 && player.y + player.height - player.vy <= p.y) {
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                    }
                }
            }
        }

        function updateEnemy() {
            enemy.x += enemy.vx * enemy.direction;
            if (enemy.x < 550 || enemy.x > 700) {
                enemy.direction *= -1;
            }
            enemy.y += enemy.vy;
            enemy.vy += gravity;
            enemy.onGround = false;

            for (const p of platforms) {
                if (enemy.x < p.x + p.width && enemy.x + enemy.width > p.x &&
                    enemy.y < p.y + p.height && enemy.y + enemy.height > p.y)
                {
                    if (enemy.vy > 0 && enemy.y + enemy.height - enemy.vy <= p.y) {
                        enemy.y = p.y - enemy.height;
                        enemy.vy = 0;
                        enemy.onGround = true;
                    }
                }
            }
            
            if (enemy.shootCooldown <= 0) {
                fireBullet(enemy, -1); // AI always shoots left
                enemy.shootCooldown = 60;
            }
            if(enemy.shootCooldown > 0) enemy.shootCooldown--;
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.life -= 1/60;

                if (b.life <= 0) {
                    const hitBox = raycast(b);
                    if (hitBox && hitBox.health !== Infinity) {
                        hitBox.health -= 10;
                    }
                    bullets.splice(i, 1);
                }
            }
        }

        function updatePlatforms() {
            for (let i = platforms.length - 1; i >= 0; i--) {
                const p = platforms[i];
                if (p.health <= 0) {
                    platforms.splice(i, 1);
                }
            }
        }


        // --- Draw Functions ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTouchControls(); // Draw the controls overlay
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = enemy.color;
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

            for (const p of platforms) {
                if (p.health === Infinity) {
                     ctx.fillStyle = '#888';
                } else {
                    const healthPercent = p.health / p.maxHealth;
                    const red = 200 * (1 - healthPercent);
                    const green = 200 * healthPercent;
                    ctx.fillStyle = `rgb(${red}, ${green}, 50)`;
                    const shrink = (1 - healthPercent) * 5;
                    ctx.fillRect(p.x + shrink, p.y + shrink, p.width - shrink * 2, p.height - shrink * 2);
                }
                ctx.fillRect(p.x, p.y, p.width, p.height);
            }

            for (const b of bullets) {
                ctx.strokeStyle = b.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(b.x1, b.y1);
                ctx.lineTo(b.x2, b.y2);
                ctx.stroke();
            }
        }

        // --- NEW: Function to draw touch controls for visibility ---
        function drawTouchControls() {
            ctx.globalAlpha = 0.2; // Make controls semi-transparent
            ctx.fillStyle = 'white';
            ctx.font = '32px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Left
            ctx.fillRect(0, 0, canvas.width / 4, canvas.height);
            ctx.fillStyle = 'black';
            ctx.fillText('◀', canvas.width / 8, canvas.height / 2);
            
            // Right
            ctx.fillStyle = 'white';
            ctx.fillRect(canvas.width / 4, 0, canvas.width / 4, canvas.height);
            ctx.fillStyle = 'black';
            ctx.fillText('▶', (canvas.width * 3) / 8, canvas.height / 2);

            // Jump
            ctx.fillStyle = 'white';
            ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height / 2);
            ctx.fillStyle = 'black';
            ctx.fillText('JUMP', (canvas.width * 3) / 4, canvas.height / 4);

            // Shoot
            ctx.fillStyle = 'white';
            ctx.fillRect(canvas.width / 2, canvas.height / 2, canvas.width / 2, canvas.height / 2);
            ctx.fillStyle = 'black';
            ctx.fillText('SHOOT', (canvas.width * 3) / 4, (canvas.height * 3) / 4);
            
            ctx.globalAlpha = 1.0; // Reset alpha
        }

        // --- Main Game Loop ---
        function gameLoop() {
            updatePlayer();
            updateEnemy();
            updateBullets();
            updatePlatforms();
            draw();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon WebGL Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
<canvas id="glCanvas"></canvas>

<script type="x-shader/x-vertex" id="vs">
    attribute vec2 position;
    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>

<script type="x-shader/x-fragment" id="fs">
    precision highp float;
    uniform vec2 resolution;
    uniform float time;
    uniform vec4 rects[5]; // x, y, width, height
    uniform int rectCount;

    // Function to draw a glowing rounded rectangle
    float sdBox(vec2 p, vec2 b) {
        vec2 d = abs(p) - b;
        return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    }

    void main() {
        vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec2 aspect = vec2(resolution.x / resolution.y, 1.0);
        vec2 p = (uv * 2.0 - 1.0) * aspect;

        vec3 finalColor = vec3(0.01, 0.01, 0.02); // Deep dark background

        for (int i = 0; i < 5; i++) {
            if (i >= rectCount) break;
            
            // Convert rect coords to screen space p-coordinates
            vec2 rPos = (rects[i].xy * 2.0 - 1.0) * aspect;
            vec2 rSize = rects[i].zw * aspect;

            float d = sdBox(p - rPos, rSize);

            // Neon glow calculation
            float glow = 0.005 / (abs(d) + 0.01);
            vec3 neonColor = vec3(0.0, 0.8, 1.0); // Cyan glow
            
            if (d < 0.0) {
                finalColor += neonColor * 0.8; // Fill
            } else {
                finalColor += neonColor * glow * 1.5; // Outer glow
            }
        }

        gl_FragColor = vec4(finalColor, 1.0);
    }
</script>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

// Simple Shader Setup
function createShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    return s;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
gl.linkProgram(program);
gl.useProgram(program);

// Full-screen Quad
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Game State
const rects = [
    { x: 0.5, y: 0.1, w: 0.8, h: 0.05 }, // Ground
    { x: 0.3, y: 0.4, w: 0.15, h: 0.02 }, // Plat 1
    { x: 0.7, y: 0.5, w: 0.15, h: 0.02 }, // Plat 2
    { x: 0.5, y: 0.7, w: 0.15, h: 0.02 }, // Plat 3
    { x: 0.1, y: 0.2, w: 0.02, h: 0.02 }  // Player (index 4)
];

const player = { x: 0.1, y: 0.2, vx: 0, vy: 0, w: 0.02, h: 0.02 };
const keys = {};
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

function update() {
    // Movement
    if (keys['ArrowLeft']) player.vx -= 0.001;
    if (keys['ArrowRight']) player.vx += 0.001;
    if (keys['Space'] && player.onGround) {
        player.vy = 0.015;
        player.onGround = false;
    }

    player.vx *= 0.9;  // Friction
    player.vy -= 0.0006; // Gravity
    player.x += player.vx;
    player.y += player.vy;

    // Collision Logic (Simple AABB)
    player.onGround = false;
    for (let i = 0; i < 4; i++) {
        let r = rects[i];
        if (player.x + player.w > r.x - r.w && player.x - player.w < r.x + r.w &&
            player.y + player.h > r.y - r.h && player.y - player.h < r.y + r.h) {
            
            if (player.vy < 0) {
                player.y = r.y + r.h + player.h;
                player.vy = 0;
                player.onGround = true;
            }
        }
    }

    // Sync player to rects array for shader
    rects[4].x = player.x;
    rects[4].y = player.y;
}

function render(time) {
    update();

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);

    gl.uniform2f(gl.getUniformLocation(program, "resolution"), canvas.width, canvas.height);
    gl.uniform1f(gl.getUniformLocation(program, "time"), time * 0.001);
    
    // Pass rectangle data to shader
    const flatRects = new Float32Array(rects.flatMap(r => [r.x, r.y, r.w, r.h]));
    gl.uniform4fv(gl.getUniformLocation(program, "rects"), flatRects);
    gl.uniform1i(gl.getUniformLocation(program, "rectCount"), rects.length);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>

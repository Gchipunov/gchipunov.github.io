<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Lake Splash - https://gemini.google.com/app/32e012621a4ddc34</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">Click/Tap to drop a rock</div>
    <canvas id="glCanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fs-sim" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D u_texture;
        uniform vec2 u_texelSize;
        uniform vec3 u_mouse; // x, y, radius
        varying vec2 v_uv;

        void main() {
            float left = texture2D(u_texture, v_uv - vec2(u_texelSize.x, 0.0)).r;
            float right = texture2D(u_texture, v_uv + vec2(u_texelSize.x, 0.0)).r;
            float top = texture2D(u_texture, v_uv + vec2(0.0, u_texelSize.y)).r;
            float bottom = texture2D(u_texture, v_uv - vec2(0.0, u_texelSize.y)).r;
            
            vec2 data = texture2D(u_texture, v_uv).rg;
            float height = data.r;
            float velocity = data.g;

            // Wave equation
            float acceleration = (left + right + top + bottom) * 0.25 - height;
            velocity += acceleration;
            velocity *= 0.98; // Damping
            height += velocity;

            // Mouse interaction (The "Rock" Splash)
            float dist = distance(v_uv, u_mouse.xy);
            if (u_mouse.z > 0.0 && dist < u_mouse.z) {
                height += (u_mouse.z - dist) * 2.0;
            }

            gl_FragColor = vec4(height, velocity, 0.0, 1.0);
        }
    </script>

    <script id="fs-render" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D u_texture;
        uniform vec2 u_texelSize;
        varying vec2 v_uv;

        void main() {
            float h = texture2D(u_texture, v_uv).r;
            float dx = texture2D(u_texture, v_uv + vec2(u_texelSize.x, 0.0)).r - h;
            float dy = texture2D(u_texture, v_uv + vec2(0.0, u_texelSize.y)).r - h;
            
            vec3 normal = normalize(vec3(-dx, -dy, 0.05));
            vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));
            float spec = pow(max(dot(normal, lightDir), 0.0), 64.0);
            
            vec3 waterColor = vec3(0.1, 0.3, 0.5);
            vec3 color = mix(waterColor, vec3(1.0), spec + h * 0.5);
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const program = gl.createProgram();
            gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
            gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
            gl.linkProgram(program);
            return program;
        }

        const simProg = createProgram(gl, document.getElementById('vs').text, document.getElementById('fs-sim').text);
        const renderProg = createProgram(gl, document.getElementById('vs').text, document.getElementById('fs-render').text);

        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        function createTexture(width, height) {
            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            return tex;
        }

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let fbA = gl.createFramebuffer(), fbB = gl.createFramebuffer();
        let texA = createTexture(width, height), texB = createTexture(width, height);
        
        let mouse = { x: 0, y: 0, active: 0 };

        window.addEventListener('mousedown', e => { mouse.x = e.clientX/width; mouse.y = 1-e.clientY/height; mouse.active = 0.05; });
        window.addEventListener('mouseup', () => mouse.active = 0);

        function step() {
            // Simulation Pass
            gl.useProgram(simProg);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbB);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texB, 0);
            gl.bindTexture(gl.TEXTURE_2D, texA);
            
            gl.uniform2f(gl.getUniformLocation(simProg, "u_texelSize"), 1/width, 1/height);
            gl.uniform3f(gl.getUniformLocation(simProg, "u_mouse"), mouse.x, mouse.y, mouse.active);
            
            const posLocSim = gl.getAttribLocation(simProg, "a_position");
            gl.enableVertexAttribArray(posLocSim);
            gl.vertexAttribPointer(posLocSim, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Render Pass
            gl.useProgram(renderProg);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, texB);
            
            gl.uniform2f(gl.getUniformLocation(renderProg, "u_texelSize"), 1/width, 1/height);
            
            const posLocRend = gl.getAttribLocation(renderProg, "a_position");
            gl.enableVertexAttribArray(posLocRend);
            gl.vertexAttribPointer(posLocRend, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Swap textures
            [texA, texB] = [texB, texA];
            requestAnimationFrame(step);
        }

        step();
    </script>
</body>
</html>

Would this work if my cloud server is on Google and a mobile user connects to it with anouther user ?
Yes, this will absolutely work on Google Cloud (GCP) with mobile users connecting to each other, but you must add one critical component or it will fail 90% of the time on mobile networks.

Mobile phones use CGNAT (Carrier-Grade NAT). This means they don't have their own public IP address; they share one with thousands of other users. Because of this, a direct UDP connection (P2P) will be blocked by the mobile carrier's firewall.

To fix this, you need a TURN Server.

1. The Mobile Architecture

You need three pieces running on your Google Cloud Instance:

The C++ Game Server: (The logic we wrote above).

The Signaling Server: (A small WebSocket script to introduce players).

The TURN Server (Coturn): This acts as a relay. If a mobile phone cannot connect directly to your C++ server via UDP, it connects to the TURN server, which forwards the packets.
+1

2. Multi-User C++ Server Code

The previous code example I gave you was for a single connection. To handle "Another User" (multiplayer), you need to manage a list of players.

Here is the upgraded main.cpp that handles multiple players connecting at once and keeps their economies separate.

C++
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <rtc/rtc.hpp>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

// --- INDIVIDUAL PLAYER STATE ---
struct Player {
    std::string id;
    int gold = 200;
    int power = 0;
    int soldiers = 0;
    // Buildings
    int hq_count = 1;
    int barracks_count = 0;
    int power_plant_count = 0;
    int refinery_count = 0;
    
    // The connection to this specific user
    std::shared_ptr<rtc::PeerConnection> pc;
    std::shared_ptr<rtc::DataChannel> dc;
};

// --- GLOBAL GAME SERVER ---
class GameServer {
    std::map<std::string, std::shared_ptr<Player>> players;
    std::mutex server_mutex;

public:
    // Create a new player session
    void addPlayer(std::string id, std::shared_ptr<rtc::PeerConnection> pc) {
        auto player = std::make_shared<Player>();
        player->id = id;
        player->pc = pc;
        
        // Setup Data Channel Handler for this specific player
        pc->onDataChannel([this, player](std::shared_ptr<rtc::DataChannel> dc) {
            player->dc = dc;
            
            // Send initial state
            sendUpdate(player);

            dc->onMessage([this, player](auto data) {
                if (std::holds_alternative<std::string>(data)) {
                    std::string cmd = std::get<std::string>(data);
                    processCommand(player, cmd);
                }
            });
        });

        std::lock_guard<std::mutex> lock(server_mutex);
        players[id] = player;
        std::cout << "Player " << id << " connected.\n";
    }

    void processCommand(std::shared_ptr<Player> p, const std::string& cmd) {
        std::lock_guard<std::mutex> lock(server_mutex);
        
        if (cmd == "build_refinery" && p->gold >= 100) {
            p->gold -= 100;
            p->refinery_count++;
        }
        else if (cmd == "build_barracks" && p->gold >= 150) {
            p->gold -= 150;
            p->barracks_count++;
        }
        
        // Sync state back to THIS player immediately
        sendUpdate(p);
    }

    void sendUpdate(std::shared_ptr<Player> p) {
        if (!p->dc || p->dc->readyState() != rtc::DataChannel::State::Open) return;

        json j;
        j["gold"] = p->gold;
        j["refineries"] = p->refinery_count;
        j["barracks"] = p->barracks_count;
        
        p->dc->send(j.dump());
    }

    // Run this every 1 second
    void tickEconomy() {
        std::lock_guard<std::mutex> lock(server_mutex);
        for (auto& [id, player] : players) {
            if (player->refinery_count > 0) {
                player->gold += (player->refinery_count * 10);
                sendUpdate(player);
            }
        }
    }
};

int main() {
    GameServer game;

    // BACKGROUND THREAD: Economy Ticker
    std::thread([&game]() {
        while (true) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            game.tickEconomy();
        }
    }).detach();

    // --- SIGNALING & CONNECTION SETUP ---
    // In a real Google Cloud setup, you would have a WebSocket server here 
    // waiting for new connections. When a new user connects via WebSocket:
    
    // PSEUDO CODE for the connection loop:
    /*
    websocketServer.on("connection", [](ws) {
        rtc::Configuration config;
        
        // *** CRITICAL FOR GOOGLE CLOUD ***
        // You must add your Google Cloud Public IP as the STUN server
        config.iceServers.emplace_back("stun:stun.l.google.com:19302");
        
        auto pc = std::make_shared<rtc::PeerConnection>(config);
        
        // Add to our game engine
        std::string newPlayerID = generateUUID();
        game.addPlayer(newPlayerID, pc);
        
        // ... Perform SDP Handshake via WebSocket ...
    });
    */

    // Keep server alive
    while(true) std::this_thread::sleep_for(std::chrono::seconds(1));
}
3. Google Cloud Configuration (Crucial)

If you just run the code above on a Google Cloud VM, it will fail because Google blocks the ports by default. You must open the "Firewall" for UDP.

Step 1: Open Firewall Ports

Go to VPC Network > Firewall.

Click Create Firewall Rule.

Name: allow-webrtc-game.

Targets: All instances in the network.

Source filter: IPv4 ranges -> 0.0.0.0/0 (Allow anyone to connect).

Protocols and ports:

UDP: 10000-60000 (WebRTC needs a wide range of random ports).

TCP: 8080 (For your Signaling/WebSocket handshake).

Step 2: Install a TURN Server (Coturn) Since you are on Google Cloud, the easiest way to ensure mobile users (4G/5G) can connect is to install coturn on the same Linux instance.

Bash
sudo apt-get update
sudo apt-get install coturn
Edit /etc/turnserver.conf:

Ini, TOML
listening-port=3478
fingerprint
lt-cred-mech
user=myuser:mypassword
realm=mygame.com
external-ip=YOUR_GOOGLE_VM_PUBLIC_IP
Step 3: Update Client Config Now, in your HTML/JS index.html, you update the configuration to use your specific Google Cloud server:

JavaScript
const pc = new RTCPeerConnection({
    iceServers: [
        // Standard Google STUN (Free, tells you your public IP)
        { urls: "stun:stun.l.google.com:19302" },
        
        // YOUR Google Cloud TURN Server (Relays traffic for blocked mobile users)
        {
            urls: "turn:YOUR_GOOGLE_VM_PUBLIC_IP:3478",
            username: "myuser",
            credential: "mypassword"
        }
    ]
});
Summary of How It Flows

Mobile User opens the game.

JS Client connects to ws://YOUR_GOOGLE_IP:8080 (Signaling) to say "I want to play."

C++ Server creates a Player object and generates an SDP offer.

Exchange: They swap SDP info.

Connection:

If on WiFi: They likely connect directly (P2P) via the open UDP firewall ports.

If on 4G/Mobile: The connection fails, RTCPeerConnection sees the turn: config, and routes traffic through port 3478 on your server.

Game Start: The GameServer class starts adding gold to that specific player's account.

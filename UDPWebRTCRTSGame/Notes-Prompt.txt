Yes code in c++ a server for rts game and a client rts game where you can build 3 buildings with a headquarters and one building is barracks to make soldiers and one is power plant for powering buildings and one is refindary for collecting gold
To implement a secure, low-latency RTS where the server controls the economy and unit production, we will use WebRTC Data Channels (via libdatachannel for C++).

Below is the complete implementation including the C++ Server, the HTML/JS Client, and the Game Logic for the specific buildings you requested.

1. The C++ Server (main.cpp)

This server is the "Authority." It stores the gold/power, handles build requests, and runs the tick loop (generating gold from refineries).

Dependencies: You will need libdatachannel and nlohmann/json.

C++
#include <iostream>
#include <thread>
#include <chrono>
#include <string>
#include <mutex>
#include <vector>
#include <variant>

// Libraries: libdatachannel and nlohmann/json
#include <rtc/rtc.hpp> 
#include <nlohmann/json.hpp>

using json = nlohmann::json;
using namespace std::chrono_literals;

// --- GAME STATE ---
// The server holds the only valid copy of the game state.
struct GameState {
    int gold = 200;      // Starting gold
    int power = 0;       // Current power capacity
    int soldiers = 0;
    
    int hq_count = 1;
    int barracks_count = 0;
    int power_plant_count = 0;
    int refinery_count = 0;
};

GameState state;
std::mutex state_mutex; // Prevents data races between game loop and network thread

// --- SERIALIZATION ---
// Convert C++ struct to JSON to send to the browser
std::string serializeState() {
    std::lock_guard<std::mutex> lock(state_mutex);
    json j;
    j["resources"] = { {"gold", state.gold}, {"power", state.power}, {"soldiers", state.soldiers} };
    j["buildings"] = { 
        {"hq", state.hq_count}, 
        {"barracks", state.barracks_count}, 
        {"power_plant", state.power_plant_count}, 
        {"refinery", state.refinery_count} 
    };
    return j.dump();
}

// --- GAME LOGIC ---
// Process specific building commands securely
void handleCommand(const std::string& cmd) {
    std::lock_guard<std::mutex> lock(state_mutex);
    
    if (cmd == "build_power") {
        if (state.gold >= 50) {
            state.gold -= 50;
            state.power_plant_count++;
            state.power += 50; // Power plant adds 50 power
            std::cout << "Built: Power Plant. Power is now: " << state.power << "\n";
        }
    }
    else if (cmd == "build_refinery") {
        // Needs 100 Gold and 10 Power
        if (state.gold >= 100 && state.power >= 10) {
            state.gold -= 100;
            state.power -= 10; // Consumes power capacity
            state.refinery_count++;
            std::cout << "Built: Refinery.\n";
        }
    }
    else if (cmd == "build_barracks") {
        // Needs 150 Gold and 20 Power
        if (state.gold >= 150 && state.power >= 20) {
            state.gold -= 150;
            state.power -= 20;
            state.barracks_count++;
            std::cout << "Built: Barracks.\n";
        }
    }
    else if (cmd == "train_soldier") {
        // Needs Barracks, 20 Gold, 5 Power
        if (state.barracks_count > 0 && state.gold >= 20 && state.power >= 5) {
            state.gold -= 20;
            state.power -= 5;
            state.soldiers++;
            std::cout << "Trained: Soldier.\n";
        }
    }
}

int main() {
    rtc::Configuration config;
    rtc::PeerConnection pc(config);

    // 1. Data Channel Setup
    pc.onDataChannel([](std::shared_ptr<rtc::DataChannel> dc) {
        std::cout << "[New Client Connected]\n";

        // Send initial state immediately
        dc->send(serializeState());

        // Handle messages (e.g., "build_barracks")
        dc->onMessage([dc](auto data) {
            if (std::holds_alternative<std::string>(data)) {
                std::string msg = std::get<std::string>(data);
                handleCommand(msg);
                dc->send(serializeState()); // Send updated state back to client
            }
        });

        // 2. Game Loop Thread (The "Heartbeat")
        // This simulates the economy over time
        std::thread([dc]() {
            while (true) {
                std::this_thread::sleep_for(2s); // Every 2 seconds
                {
                    std::lock_guard<std::mutex> lock(state_mutex);
                    if (state.refinery_count > 0) {
                        // Refineries generate 10 gold per tick
                        state.gold += (state.refinery_count * 10);
                        
                        // Notify client of the passive gold increase
                        // (Use try/catch in case client disconnects)
                        try { dc->send(serializeState()); } catch(...) { break; }
                    }
                }
            }
        }).detach();
    });

    // NOTE: In a real app, you need a Signaling Server here to exchange the SDP Offer/Answer.
    // This allows the C++ server and Browser to find each other.
    std::cout << "Server Initialized. Waiting for Signaling..." << std::endl;

    while(true) std::this_thread::sleep_for(1s);
    return 0;
}
2. The WebGL/Browser Client (index.html)

The client calculates nothing. It only renders JSON data.

HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RTS WebRTC Client</title>
    <style>
        body { background-color: #1a1a1a; color: white; font-family: sans-serif; text-align: center; }
        .ui-panel { display: flex; justify-content: center; gap: 20px; padding: 20px; background: #333; margin-bottom: 20px; }
        .resource { font-size: 20px; font-weight: bold; color: gold; }
        .power { color: cyan; }
        .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; max-width: 800px; margin: auto; }
        button { padding: 15px; background: #444; color: white; border: 1px solid #666; cursor: pointer; }
        button:hover { background: #666; }
        .active { border-color: lime; }
    </style>
</head>
<body>

    <div class="ui-panel">
        <div class="resource">GOLD: <span id="gold">0</span></div>
        <div class="resource power">POWER: <span id="power">0</span></div>
        <div class="resource" style="color:red">SOLDIERS: <span id="soldiers">0</span></div>
    </div>

    <div class="grid">
        <button onclick="sendCommand('build_power')">
            Build Power Plant<br>
            <small>Cost: 50 Gold | +50 Power</small>
        </button>

        <button onclick="sendCommand('build_refinery')">
            Build Refinery<br>
            <small>Cost: 100 Gold | -10 Power</small><br>
            <em style="color:yellow">Generates Gold over time</em>
        </button>

        <button onclick="sendCommand('build_barracks')">
            Build Barracks<br>
            <small>Cost: 150 Gold | -20 Power</small>
        </button>
        
        <button onclick="sendCommand('train_soldier')" style="grid-column: span 3; background: #500;">
            Train Soldier<br>
            <small>Cost: 20 Gold | -5 Power | Req: Barracks</small>
        </button>
    </div>

    <h3>Building Inventory</h3>
    <div id="debug"></div>

    <script>
        const pc = new RTCPeerConnection({
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        });

        // Create the "socket"
        const dc = pc.createDataChannel("rts_game", { ordered: false, maxRetransmits: 0 });

        dc.onopen = () => console.log("Connected to C++ RTS Server");
        
        // RECEIVE UPDATES
        dc.onmessage = (event) => {
            const data = JSON.parse(event.data);
            updateUI(data);
        };

        // SEND COMMANDS
        function sendCommand(cmd) {
            if (dc.readyState === "open") {
                dc.send(cmd);
            }
        }

        function updateUI(data) {
            // Update Resources
            document.getElementById("gold").innerText = data.resources.gold;
            document.getElementById("power").innerText = data.resources.power;
            document.getElementById("soldiers").innerText = data.resources.soldiers;

            // Update Debug/Inventory
            document.getElementById("debug").innerText = 
                `HQ: ${data.buildings.hq} | Power Plants: ${data.buildings.power_plant} | Refineries: ${data.buildings.refinery} | Barracks: ${data.buildings.barracks}`;
        }

        // --- Signaling Placeholder ---
        // In a real implementation, you would use WebSocket to exchange SDP here.
        // pc.createOffer().then(offer => pc.setLocalDescription(offer))...
    </script>
</body>
</html>
Critical Concept: The Economy Loop

Notice the server has this block:

C++
if (state.refinery_count > 0) {
    state.gold += (state.refinery_count * 10);
}
This is the most important part of the RTS security. The client never says "I gathered gold." The client only says "I built a refinery." The Server is responsible for passively adding gold every 2 seconds.

Next Steps to Run This

Since WebRTC requires a "Signaling Server" (a small bridge to introduce the C++ program to the Browser) to start the connection:

Would you like me to provide the Python "Signaling Server" script? This will allow you to actually run these two pieces of code and have them connect on your localhost.

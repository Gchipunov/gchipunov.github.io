<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL RTS Prototype</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            pointer-events: none; /* Let clicks pass through to canvas */
            text-shadow: 1px 1px 0 #000;
        }
        h1 { margin: 0; font-size: 24px; text-transform: uppercase; }
        p { font-size: 14px; color: #aaa; }
        .instructions {
            background: rgba(0, 20, 0, 0.8);
            border: 1px solid #0f0;
            padding: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Open Alert: WebGL</h1>
        <div class="instructions">
            <strong>CONTROLS:</strong><br>
            [L-Click]: Select Unit<br>
            [Shift + L-Click]: Select Multiple<br>
            [R-Click]: Move / Order<br>
            [W, A, S, D]: Pan Camera
        </div>
        <p id="status">Systems Ready.</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, raycaster, mouse;
        let ground;
        
        // Game State
        const units = [];
        let selectedUnits = [];
        const enemies = [];
        
        // Camera Controls
        const camSpeed = 0.5;
        const keys = { w: false, a: false, s: false, d: false };

        // Constants
        const COLOR_FRIENDLY = 0x3399ff; // Blue
        const COLOR_SELECTED = 0x00ff00; // Bright Green
        const COLOR_ENEMY = 0xff3333;    // Red

        // --- INITIALIZATION ---
        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Fog of war style bg
            scene.fog = new THREE.FogExp2(0x1a1a1a, 0.008);

            // 2. Setup Camera (Orthographic for RTS look)
            const aspect = window.innerWidth / window.innerHeight;
            const d = 40;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            
            // Isometric Angle
            camera.position.set(50, 50, 50); 
            camera.lookAt(scene.position); 

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x666666);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 5. The Ground (Battlefield)
            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x2b4a2b }); // Dark grass
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = "ground";
            scene.add(ground);

            // 6. Grid Helper (for that retro feel)
            const gridHelper = new THREE.GridHelper(200, 50, 0x000000, 0x112211);
            scene.add(gridHelper);

            // 7. Input Handling Tools
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // --- SPAWN UNITS ---
            spawnUnit(0, 0, true);  // Commander
            spawnUnit(-5, 5, true); // Tank 1
            spawnUnit(5, 5, true);  // Tank 2

            spawnStructure(40, -40); // Enemy Base

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('keydown', (e) => toggleKey(e, true));
            window.addEventListener('keyup', (e) => toggleKey(e, false));
            // Prevent context menu on right click
            window.addEventListener('contextmenu', event => event.preventDefault());

            animate();
        }

        // --- GAME LOGIC FUNCTIONS ---

        function spawnUnit(x, z, isFriendly) {
            // Simple Tank Geometry: A Cube body with a Cylinder turret
            const group = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(2, 1, 3);
            const mat = new THREE.MeshStandardMaterial({ color: isFriendly ? COLOR_FRIENDLY : COLOR_ENEMY });
            const body = new THREE.Mesh(bodyGeo, mat);
            body.castShadow = true;
            body.position.y = 0.5;
            group.add(body);

            // Turret
            const turretGeo = new THREE.BoxGeometry(1.2, 0.8, 2);
            const turret = new THREE.Mesh(turretGeo, mat);
            turret.position.y = 1.2;
            turret.position.z = -0.2;
            turret.castShadow = true;
            group.add(turret);

            // Barrel
            const barrelGeo = new THREE.CylinderGeometry(0.2, 0.2, 2.5);
            const barrelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.y = 1.2;
            barrel.position.z = -1.5;
            group.add(barrel);

            // Positioning
            group.position.set(x, 0, z);

            // Logic Data
            group.userData = {
                id: Math.random(),
                isUnit: true,
                isSelected: false,
                isFriendly: isFriendly,
                targetPos: null,
                speed: 0.15,
                velocity: new THREE.Vector3()
            };

            scene.add(group);
            if(isFriendly) units.push(group);
            else enemies.push(group);
        }

        function spawnStructure(x, z) {
            const geo = new THREE.CylinderGeometry(4, 6, 5, 6);
            const mat = new THREE.MeshStandardMaterial({ color: COLOR_ENEMY });
            const building = new THREE.Mesh(geo, mat);
            building.position.set(x, 2.5, z);
            building.castShadow = true;
            scene.add(building);
        }

        function toggleKey(e, state) {
            const k = e.key.toLowerCase();
            if (keys.hasOwnProperty(k)) keys[k] = state;
        }

        // --- MOVEMENT & INTERACTION ---

        function onPointerDown(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Right Click = Move Order
            if (event.button === 2) {
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0 && selectedUnits.length > 0) {
                    const point = intersects[0].point;
                    
                    // Update status UI
                    document.getElementById('status').innerText = `Moving ${selectedUnits.length} unit(s) to coordinates.`;

                    // Basic formation logic (spread them out slightly)
                    selectedUnits.forEach((unit, index) => {
                        const offsetX = (index % 3) * 3; 
                        const offsetZ = Math.floor(index / 3) * 3;
                        
                        unit.userData.targetPos = new THREE.Vector3(
                            point.x + offsetX, 
                            0, 
                            point.z + offsetZ
                        );
                        
                        // Rotate to face target
                        unit.lookAt(unit.userData.targetPos);
                    });
                }
            } 
            // Left Click = Select
            else if (event.button === 0) {
                const intersects = raycaster.intersectObjects(units, true); // Recursive for groups
                
                if (!event.shiftKey) {
                    deselectAll();
                }

                if (intersects.length > 0) {
                    // Find the root group of the clicked mesh
                    let target = intersects[0].object;
                    while(target.parent && !target.userData.isUnit) {
                        target = target.parent;
                    }

                    if (target.userData.isUnit) {
                        selectUnit(target);
                        document.getElementById('status').innerText = "Unit Selected.";
                    }
                }
            }
        }

        function selectUnit(unit) {
            unit.userData.isSelected = true;
            // Highlight effect (change color of the body mesh)
            unit.children[0].material.color.setHex(COLOR_SELECTED); 
            
            if (!selectedUnits.includes(unit)) {
                selectedUnits.push(unit);
            }
        }

        function deselectAll() {
            selectedUnits.forEach(unit => {
                unit.userData.isSelected = false;
                unit.children[0].material.color.setHex(COLOR_FRIENDLY);
            });
            selectedUnits = [];
        }

        function updateUnits() {
            units.forEach(unit => {
                const data = unit.userData;
                
                // Movement Logic
                if (data.targetPos) {
                    const distance = unit.position.distanceTo(data.targetPos);
                    
                    if (distance > 0.5) {
                        // Create a direction vector
                        const direction = new THREE.Vector3()
                            .subVectors(data.targetPos, unit.position)
                            .normalize();
                        
                        // Move
                        unit.position.add(direction.multiplyScalar(data.speed));
                    } else {
                        // Stop
                        data.targetPos = null;
                    }
                }
            });
        }

        function updateCamera() {
            if (keys.w) camera.position.z -= camSpeed; // Note: Isometric axes are skewed
            if (keys.s) camera.position.z += camSpeed;
            if (keys.a) camera.position.x -= camSpeed;
            if (keys.d) camera.position.x += camSpeed;
            
            // simple boundary check
            // camera.position.x = Math.max(-50, Math.min(50, camera.position.x));
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 40;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            updateUnits();
            updateCamera();
            renderer.render(scene, camera);
        }

        // Start
        init();

    </script>
</body>
</html>

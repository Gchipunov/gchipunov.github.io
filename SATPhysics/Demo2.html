<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL SAT Collision Engine v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            color: #e2e8f0;
            touch-action: none; /* Prevents scrolling/zooming on touch devices */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 1rem;
            background-color: rgba(45, 55, 72, 0.8);
            border-radius: 0.5rem;
            font-family: 'Inter', sans-serif;
            border: 1px solid #4a5568;
            pointer-events: none; /* Make it so UI doesn't interfere with touch */
        }
        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2rem;
            background-color: #c53030;
            color: white;
            border-radius: 0.5rem;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">
    <div id="info">
        <h1 class="text-xl font-bold">WebGL Collision Engine</h1>
        <p><strong>Desktop:</strong> Move mouse to control.</p>
        <p><strong>Mobile:</strong> Drag any shape to apply force.</p>
        <p>Health: <span id="health-display">3</span></p>
    </div>
    <div id="error-message" class="hidden">
        <h2 class="text-lg font-bold">Error</h2>
        <p>WebGL is not supported by your browser.</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader-2d" type="notjs">
      attribute vec2 a_position;
      uniform vec2 u_resolution;
      uniform mat3 u_matrix;

      void main() {
        vec2 position = (u_matrix * vec3(a_position, 1)).xy;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      }
    </script>

    <script id="fragment-shader-2d" type="notjs">
      precision mediump float;
      uniform vec4 u_color;

      void main() {
         gl_FragColor = u_color;
      }
    </script>

    <script type="module">
        // --- Main WebGL and Application Setup ---
        function main() {
            const canvas = document.querySelector("#glcanvas");
            const gl = canvas.getContext("webgl");
            if (!gl) {
                document.getElementById('error-message').classList.remove('hidden');
                return;
            }

            // Shader program setup
            const vsSource = document.getElementById("vertex-shader-2d").text;
            const fsSource = document.getElementById("fragment-shader-2d").text;
            const program = createProgramFromSources(gl, [vsSource, fsSource]);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            const colorLocation = gl.getUniformLocation(program, "u_color");
            const matrixLocation = gl.getUniformLocation(program, "u_matrix");

            const positionBuffer = gl.createBuffer();
            const healthDisplay = document.getElementById('health-display');

            // --- Vector Math Utilities ---
            class Vec2 {
                constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
                sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
                mul(s) { return new Vec2(this.x * s, this.y * s); }
                div(s) { return new Vec2(this.x / s, this.y / s); }
                dot(v) { return this.x * v.x + this.y * v.y; }
                perp() { return new Vec2(-this.y, this.x); }
                normalize() {
                    const len = Math.sqrt(this.x * this.x + this.y * this.y);
                    if (len > 0) return this.div(len);
                    return new Vec2();
                }
            }

            // --- Shape Class ---
            class Shape {
                constructor(vertices, x, y, color) {
                    this.baseVertices = vertices.map(v => new Vec2(v.x, v.y));
                    this.position = new Vec2(x, y);
                    this.velocity = new Vec2(Math.random() * 2 - 1, Math.random() * 2 - 1);
                    this.color = color;
                    this.rotation = 0;
                    this.health = 3;
                    this.isPlayer = false;
                }

                getTransformedVertices() {
                    const matrix = m3.translate(m3.identity(), this.position.x, this.position.y);
                    const rotatedMatrix = m3.rotate(matrix, this.rotation);
                    
                    return this.baseVertices.map(v => {
                        const transformed = m3.transformPoint(rotatedMatrix, v);
                        return new Vec2(transformed[0], transformed[1]);
                    });
                }
                
                update(deltaTime, width, height) {
                    this.position = this.position.add(this.velocity.mul(deltaTime * 100));
                    this.rotation += 0.001 * deltaTime * 100;

                    const verts = this.getTransformedVertices();
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    verts.forEach(v => {
                        minX = Math.min(minX, v.x); maxX = Math.max(maxX, v.x);
                        minY = Math.min(minY, v.y); maxY = Math.max(maxY, v.y);
                    });

                    if (minX < 0 || maxX > width) {
                        this.velocity.x *= -1;
                        this.position.x = Math.max(minX < 0 ? -minX + this.position.x : this.position.x, Math.min(width - (maxX - this.position.x), this.position.x));
                    }
                    if (minY < 0 || maxY > height) {
                         this.velocity.y *= -1;
                         this.position.y = Math.max(minY < 0 ? -minY + this.position.y : this.position.y, Math.min(height - (maxY - this.position.y), this.position.y));
                    }
                }

                draw(gl, program) {
                    const positions = [];
                    this.baseVertices.forEach(v => positions.push(v.x, v.y));

                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                    
                    let matrix = m3.translate(m3.identity(), this.position.x, this.position.y);
                    matrix = m3.rotate(matrix, this.rotation);
                    
                    gl.uniformMatrix3fv(matrixLocation, false, matrix);
                    gl.uniform4fv(colorLocation, this.color);

                    gl.drawArrays(gl.TRIANGLE_FAN, 0, this.baseVertices.length);
                }
            }
            
            // --- Collision Detection (SAT) ---
            function getAxes(vertices) {
                const axes = [];
                for (let i = 0; i < vertices.length; i++) {
                    const p1 = vertices[i];
                    const p2 = vertices[i + 1 === vertices.length ? 0 : i + 1];
                    axes.push(p1.sub(p2).perp().normalize());
                }
                return axes;
            }

            function project(vertices, axis) {
                let min = Infinity, max = -Infinity;
                for (const v of vertices) {
                    const p = v.dot(axis);
                    min = Math.min(min, p);
                    max = Math.max(max, p);
                }
                return { min, max };
            }

            function checkCollision(shapeA, shapeB) {
                const axes = [...getAxes(shapeA.getTransformedVertices()), ...getAxes(shapeB.getTransformedVertices())];
                for (const axis of axes) {
                    const projA = project(shapeA.getTransformedVertices(), axis);
                    const projB = project(shapeB.getTransformedVertices(), axis);
                    if (projA.max < projB.min || projB.max < projA.min) return false;
                }
                return true;
            }

            // --- Object Creation ---
            const shapes = [];
            const playerTriangle = new Shape([{x: -25, y: 20}, {x: 25, y: 20}, {x: 0, y: -30}], 300, 300, [0.1, 0.8, 0.3, 1]);
            playerTriangle.isPlayer = true;
            playerTriangle.velocity = new Vec2(0,0);
            shapes.push(playerTriangle);

            for (let i = 0; i < 9; i++) {
                const sides = Math.floor(Math.random() * 3) + 4;
                const vertices = [];
                const radius = Math.random() * 20 + 30;
                for (let j = 0; j < sides; j++) {
                    const angle = (j / sides) * Math.PI * 2;
                    vertices.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
                }
                shapes.push(new Shape(vertices, Math.random() * canvas.width, Math.random() * canvas.height, [0.8, 0.2, 0.5, 1]));
            }
            
            // --- Controls (Mouse and Touch) ---
            let draggedShape = null;
            let dragStartPos = null;

            function getCanvasPos(event) {
                const rect = canvas.getBoundingClientRect();
                const clientX = event.clientX ?? event.touches[0].clientX;
                const clientY = event.clientY ?? event.touches[0].clientY;
                return new Vec2(clientX - rect.left, clientY - rect.top);
            }

            function pointInPolygon(point, vertices) {
                let isInside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x, yi = vertices[i].y;
                    const xj = vertices[j].x, yj = vertices[j].y;
                    const intersect = ((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                    if (intersect) isInside = !isInside;
                }
                return isInside;
            }

            function handleDragStart(event) {
                event.preventDefault();
                const pos = getCanvasPos(event);
                for (let i = shapes.length - 1; i >= 0; i--) {
                    if (pointInPolygon(pos, shapes[i].getTransformedVertices())) {
                        draggedShape = shapes[i];
                        dragStartPos = pos;
                        break;
                    }
                }
            }

            function handleDragEnd(event) {
                if (draggedShape && dragStartPos) {
                    const endPos = getCanvasPos(event.changedTouches ? event.changedTouches[0] : event);
                    const force = endPos.sub(dragStartPos).mul(0.1); // Apply force based on drag
                    draggedShape.velocity = draggedShape.velocity.add(force);
                }
                draggedShape = null;
                dragStartPos = null;
            }

            canvas.addEventListener('mousemove', (e) => {
                if (playerTriangle.health > 0 && !draggedShape) {
                    const pos = getCanvasPos(e);
                    playerTriangle.position.x = pos.x;
                    playerTriangle.position.y = pos.y;
                }
            });

            canvas.addEventListener('mousedown', handleDragStart);
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('touchstart', handleDragStart, { passive: false });
            canvas.addEventListener('touchend', handleDragEnd);

            // --- Render Loop ---
            let lastTime = 0;
            let collisionCooldown = 0;

            function render(time) {
                time *= 0.001;
                const deltaTime = time - lastTime;
                lastTime = time;

                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);
                gl.enableVertexAttribArray(positionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

                shapes.forEach(shape => {
                    if (!shape.isPlayer || draggedShape) { // Player doesn't auto-move unless dragged
                        shape.update(deltaTime, gl.canvas.width, gl.canvas.height);
                    }
                    shape.draw(gl, program);
                });
                
                if (collisionCooldown > 0) {
                    collisionCooldown -= deltaTime;
                } else if (playerTriangle.health > 0) {
                    for (let i = 0; i < shapes.length; i++) {
                         if (shapes[i] === playerTriangle) continue;
                        if (checkCollision(playerTriangle, shapes[i])) {
                            playerTriangle.health--;
                            healthDisplay.textContent = playerTriangle.health;
                            playerTriangle.color = [1, 0, 0, 1];
                            collisionCooldown = 0.5;
                            setTimeout(() => {
                                if (playerTriangle.health > 0) playerTriangle.color = [0.1, 0.8, 0.3, 1];
                            }, 200);
                            if (playerTriangle.health <= 0) {
                                splitPlayer();
                                break;
                            }
                        }
                    }
                }
                
                requestAnimationFrame(render);
            }
            
            function splitPlayer() {
                const playerIndex = shapes.indexOf(playerTriangle);
                if (playerIndex === -1) return;
                
                const originalVerts = playerTriangle.getTransformedVertices();
                const centroid = originalVerts.reduce((acc, v) => acc.add(v), new Vec2()).div(originalVerts.length);

                for (let i=0; i < originalVerts.length; i++) {
                    const p1 = originalVerts[i], p2 = originalVerts[(i + 1) % originalVerts.length];
                    const newVertsRaw = [p1, p2, centroid];
                    const newCentroid = newVertsRaw.reduce((acc, v) => acc.add(v), new Vec2()).div(3);
                    const newBaseVerts = newVertsRaw.map(v => ({ x: v.x - newCentroid.x, y: v.y - newCentroid.y }));

                    const debris = new Shape(newBaseVerts, newCentroid.x, newCentroid.y, [1, 0.5, 0, 1]);
                    debris.velocity = newCentroid.sub(centroid).normalize().mul(Math.random() * 2 + 3);
                    shapes.push(debris);

                    // Remove debris after 2 seconds
                    setTimeout(() => {
                        const debrisIndex = shapes.indexOf(debris);
                        if (debrisIndex > -1) shapes.splice(debrisIndex, 1);
                    }, 2000);
                }
                shapes.splice(playerIndex, 1);
            }

            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source); gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
            console.error(gl.getShaderInfoLog(shader)); gl.deleteShader(shader);
        }
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program);
            if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
            console.error(gl.getProgramInfoLog(program)); gl.deleteProgram(program);
        }
        function createProgramFromSources(gl, shaderSources) {
            return createProgram(gl, createShader(gl, gl.VERTEX_SHADER, shaderSources[0]), createShader(gl, gl.FRAGMENT_SHADER, shaderSources[1]));
        }
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth = canvas.clientWidth, displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth; canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // --- Matrix Math Helper ---
        const m3 = {
            identity: () => [1, 0, 0, 0, 1, 0, 0, 0, 1],
            translation: (tx, ty) => [1, 0, 0, 0, 1, 0, tx, ty, 1],
            rotation: (r) => { const c = Math.cos(r), s = Math.sin(r); return [c, -s, 0, s, c, 0, 0, 0, 1]; },
            multiply: (a, b) => {
                const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
                const b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
                return [
                    b00*a00+b01*a10+b02*a20, b00*a01+b01*a11+b02*a21, b00*a02+b01*a12+b02*a22,
                    b10*a00+b11*a10+b12*a20, b10*a01+b11*a11+b12*a21, b10*a02+b11*a12+b12*a22,
                    b20*a00+b21*a10+b22*a20, b20*a01+b21*a11+b22*a21, b20*a02+b21*a12+b22*a22,
                ];
            },
            translate: (m, tx, ty) => m3.multiply(m, m3.translation(tx, ty)),
            rotate: (m, r) => m3.multiply(m, m3.rotation(r)),
            transformPoint: (m, v) => {
                const v0 = v.x, v1 = v.y;
                const d = v0 * m[2] + v1 * m[5] + m[8];
                return [(v0 * m[0] + v1 * m[3] + m[6]) / d, (v0 * m[1] + v1 * m[4] + m[7]) / d];
            },
        };
        main();
    </script>
</body>
</html>


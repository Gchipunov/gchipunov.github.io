<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL SAT Collision Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 1rem;
            background-color: rgba(45, 55, 72, 0.8);
            border-radius: 0.5rem;
            font-family: 'Inter', sans-serif;
            border: 1px solid #4a5568;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">
    <div id="info">
        <h1 class="text-xl font-bold">WebGL Collision Engine</h1>
        <p>Move the mouse to control the green triangle.</p>
        <p>Collide 3 times with a polygon to split.</p>
        <p>Health: <span id="health-display">3</span></p>
    </div>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader-2d" type="notjs">
      attribute vec2 a_position;
      uniform vec2 u_resolution;
      uniform mat3 u_matrix;

      void main() {
        vec2 position = (u_matrix * vec3(a_position, 1)).xy;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
      }
    </script>

    <script id="fragment-shader-2d" type="notjs">
      precision mediump float;
      uniform vec4 u_color;

      void main() {
         gl_FragColor = u_color;
      }
    </script>

    <script type="module">
        // --- Main WebGL and Application Setup ---
        function main() {
            const canvas = document.querySelector("#glcanvas");
            const gl = canvas.getContext("webgl");
            if (!gl) {
                alert("WebGL isn't available");
                return;
            }

            // Shader program setup
            const vsSource = document.getElementById("vertex-shader-2d").text;
            const fsSource = document.getElementById("fragment-shader-2d").text;
            const program = createProgramFromSources(gl, [vsSource, fsSource]);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            const colorLocation = gl.getUniformLocation(program, "u_color");
            const matrixLocation = gl.getUniformLocation(program, "u_matrix");

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            const healthDisplay = document.getElementById('health-display');

            // --- Vector Math Utilities ---
            class Vec2 {
                constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
                sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
                mul(s) { return new Vec2(this.x * s, this.y * s); }
                div(s) { return new Vec2(this.x / s, this.y / s); }
                dot(v) { return this.x * v.x + this.y * v.y; }
                perp() { return new Vec2(-this.y, this.x); }
                normalize() {
                    const len = Math.sqrt(this.x * this.x + this.y * this.y);
                    if (len > 0) return this.div(len);
                    return new Vec2();
                }
            }

            // --- Shape Class ---
            class Shape {
                constructor(vertices, x, y, color) {
                    this.baseVertices = vertices.map(v => new Vec2(v.x, v.y));
                    this.position = new Vec2(x, y);
                    this.velocity = new Vec2(Math.random() * 2 - 1, Math.random() * 2 - 1);
                    this.color = color;
                    this.rotation = 0;
                    this.health = 3;
                    this.isDebris = false;
                    this.life = 1.0;
                }

                getTransformedVertices() {
                    const matrix = m3.identity();
                    matrix = m3.translate(matrix, this.position.x, this.position.y);
                    matrix = m3.rotate(matrix, this.rotation);
                    
                    return this.baseVertices.map(v => {
                        const transformed = m3.transformPoint(matrix, v);
                        return new Vec2(transformed[0], transformed[1]);
                    });
                }
                
                update(deltaTime, width, height) {
                    if (this.isDebris) {
                        this.life -= deltaTime * 0.5;
                    } else {
                        this.position = this.position.add(this.velocity.mul(deltaTime * 100));
                        this.rotation += 0.001 * deltaTime * 100;

                        // Wall bouncing
                        const verts = this.getTransformedVertices();
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        verts.forEach(v => {
                            minX = Math.min(minX, v.x);
                            maxX = Math.max(maxX, v.x);
                            minY = Math.min(minY, v.y);
                            maxY = Math.max(maxY, v.y);
                        });

                        if (minX < 0 || maxX > width) this.velocity.x *= -1;
                        if (minY < 0 || maxY > height) this.velocity.y *= -1;
                        
                        this.position.x = Math.max(0, Math.min(width, this.position.x));
                        this.position.y = Math.max(0, Math.min(height, this.position.y));
                    }
                }

                draw(gl, program) {
                    const positions = [];
                    this.baseVertices.forEach(v => positions.push(v.x, v.y));

                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                    
                    let matrix = m3.identity();
                    matrix = m3.translate(matrix, this.position.x, this.position.y);
                    matrix = m3.rotate(matrix, this.rotation);
                    
                    gl.uniformMatrix3fv(matrixLocation, false, matrix);

                    const color = [...this.color];
                    if (this.isDebris) {
                        color[3] = this.life; // Fade out
                    }
                    gl.uniform4fv(colorLocation, color);

                    gl.drawArrays(gl.TRIANGLE_FAN, 0, this.baseVertices.length);
                }
            }
            
            // --- Collision Detection (SAT) ---
            function getAxes(vertices) {
                const axes = [];
                for (let i = 0; i < vertices.length; i++) {
                    const p1 = vertices[i];
                    const p2 = vertices[i + 1 === vertices.length ? 0 : i + 1];
                    const edge = p1.sub(p2);
                    axes.push(edge.perp().normalize());
                }
                return axes;
            }

            function project(vertices, axis) {
                let min = Infinity;
                let max = -Infinity;
                for (let i = 0; i < vertices.length; i++) {
                    const p = vertices[i].dot(axis);
                    min = Math.min(min, p);
                    max = Math.max(max, p);
                }
                return { min, max };
            }

            function checkCollision(shapeA, shapeB) {
                const vertsA = shapeA.getTransformedVertices();
                const vertsB = shapeB.getTransformedVertices();
                const axes = [...getAxes(vertsA), ...getAxes(vertsB)];

                for (let i = 0; i < axes.length; i++) {
                    const axis = axes[i];
                    const projA = project(vertsA, axis);
                    const projB = project(vertsB, axis);

                    if (projA.max < projB.min || projB.max < projA.min) {
                        return false; // Found a separating axis
                    }
                }
                return true; // No separating axis found
            }

            // --- Object Creation ---
            const shapes = [];
            const playerTriangle = new Shape([
                {x: -25, y: 20}, {x: 25, y: 20}, {x: 0, y: -30}
            ], 300, 300, [0.1, 0.8, 0.3, 1]); // Green
            playerTriangle.velocity = new Vec2(0,0);
            shapes.push(playerTriangle);

            for (let i = 0; i < 9; i++) {
                const sides = Math.floor(Math.random() * 3) + 4; // Quads to hexagons
                const vertices = [];
                const radius = Math.random() * 20 + 30;
                for (let j = 0; j < sides; j++) {
                    const angle = (j / sides) * Math.PI * 2;
                    vertices.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
                const x = Math.random() * gl.canvas.width;
                const y = Math.random() * gl.canvas.height;
                shapes.push(new Shape(vertices, x, y, [0.8, 0.2, 0.5, 1])); // Magenta
            }
            
            // --- Mouse Control ---
            canvas.addEventListener('mousemove', (e) => {
                if(playerTriangle.health > 0){
                    const rect = canvas.getBoundingClientRect();
                    playerTriangle.position.x = e.clientX - rect.left;
                    playerTriangle.position.y = e.clientY - rect.top;
                }
            });

            // --- Render Loop ---
            let lastTime = 0;
            let collisionCooldown = 0;

            function render(time) {
                time *= 0.001;
                const deltaTime = time - lastTime;
                lastTime = time;

                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);
                gl.enableVertexAttribArray(positionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

                // Update and draw shapes
                shapes.forEach(shape => {
                    if (shape !== playerTriangle) {
                        shape.update(deltaTime, gl.canvas.width, gl.canvas.height);
                    }
                    shape.draw(gl, program);
                });

                // Collision logic
                if (collisionCooldown > 0) {
                    collisionCooldown -= deltaTime;
                } else if (playerTriangle.health > 0) {
                    for (let i = 1; i < shapes.length; i++) {
                        if (checkCollision(playerTriangle, shapes[i])) {
                            playerTriangle.health--;
                            healthDisplay.textContent = playerTriangle.health;
                            playerTriangle.color = [1, 0, 0, 1]; // Flash red
                            collisionCooldown = 0.5; // 0.5 second immunity

                            setTimeout(() => {
                                if(playerTriangle.health > 0)
                                    playerTriangle.color = [0.1, 0.8, 0.3, 1]; // Back to green
                            }, 200);

                            if (playerTriangle.health <= 0) {
                                splitPlayer();
                                break;
                            }
                        }
                    }
                }
                
                // Filter out dead debris
                for (let i = shapes.length - 1; i >= 0; i--) {
                    if (shapes[i].isDebris && shapes[i].life <= 0) {
                        shapes.splice(i, 1);
                    }
                }

                requestAnimationFrame(render);
            }
            
            function splitPlayer() {
                const playerIndex = shapes.indexOf(playerTriangle);
                if (playerIndex === -1) return;
                
                const originalVerts = playerTriangle.getTransformedVertices();
                
                // Calculate centroid
                const centroid = originalVerts.reduce((acc, v) => acc.add(v), new Vec2()).div(originalVerts.length);

                // Create 3 new triangles from original vertices and centroid
                for(let i=0; i<originalVerts.length; i++) {
                    const p1 = originalVerts[i];
                    const p2 = originalVerts[(i + 1) % originalVerts.length];
                    
                    const newVertsRaw = [p1, p2, centroid];
                    
                    // Center the new triangle's vertices around (0,0) for the Shape class
                    const newCentroid = newVertsRaw.reduce((acc, v) => acc.add(v), new Vec2()).div(3);
                    const newBaseVerts = newVertsRaw.map(v => ({ x: v.x - newCentroid.x, y: v.y - newCentroid.y }));

                    const debris = new Shape(newBaseVerts, newCentroid.x, newCentroid.y, [1, 0.5, 0, 1]); // Orange
                    debris.isDebris = true;
                    const direction = newCentroid.sub(centroid).normalize();
                    debris.velocity = direction.mul(Math.random() * 2 + 1);
                    shapes.push(debris);
                }

                shapes.splice(playerIndex, 1); // Remove original player
            }

            requestAnimationFrame(render);
        }

        // --- WebGL Helper Functions ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) return shader;
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            const success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) return program;
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        function createProgramFromSources(gl, shaderSources) {
            const vs = createShader(gl, gl.VERTEX_SHADER, shaderSources[0]);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, shaderSources[1]);
            return createProgram(gl, vs, fs);
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // --- Matrix Math Helper ---
        const m3 = {
            identity: function() {
                return [1, 0, 0, 0, 1, 0, 0, 0, 1];
            },
            translation: function(tx, ty) {
                return [1, 0, 0, 0, 1, 0, tx, ty, 1];
            },
            rotation: function(angleInRadians) {
                const c = Math.cos(angleInRadians);
                const s = Math.sin(angleInRadians);
                return [c, -s, 0, s, c, 0, 0, 0, 1];
            },
            scaling: function(sx, sy) {
                return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
            },
            multiply: function(a, b) {
                const a00 = a[0 * 3 + 0]; const a01 = a[0 * 3 + 1]; const a02 = a[0 * 3 + 2];
                const a10 = a[1 * 3 + 0]; const a11 = a[1 * 3 + 1]; const a12 = a[1 * 3 + 2];
                const a20 = a[2 * 3 + 0]; const a21 = a[2 * 3 + 1]; const a22 = a[2 * 3 + 2];
                const b00 = b[0 * 3 + 0]; const b01 = b[0 * 3 + 1]; const b02 = b[0 * 3 + 2];
                const b10 = b[1 * 3 + 0]; const b11 = b[1 * 3 + 1]; const b12 = b[1 * 3 + 2];
                const b20 = b[2 * 3 + 0]; const b21 = b[2 * 3 + 1]; const b22 = b[2 * 3 + 2];
                return [
                    b00 * a00 + b01 * a10 + b02 * a20,
                    b00 * a01 + b01 * a11 + b02 * a21,
                    b00 * a02 + b01 * a12 + b02 * a22,
                    b10 * a00 + b11 * a10 + b12 * a20,
                    b10 * a01 + b11 * a11 + b12 * a21,
                    b10 * a02 + b11 * a12 + b12 * a22,
                    b20 * a00 + b21 * a10 + b22 * a20,
                    b20 * a01 + b21 * a11 + b22 * a21,
                    b20 * a02 + b21 * a12 + b22 * a22,
                ];
            },
            translate: function(m, tx, ty) {
                return m3.multiply(m, m3.translation(tx, ty));
            },
            rotate: function(m, angleInRadians) {
                return m3.multiply(m, m3.rotation(angleInRadians));
            },
            scale: function(m, sx, sy) {
                return m3.multiply(m, m3.scaling(sx, sy));
            },
            transformPoint: function(m, v) {
                const v0 = v.x, v1 = v.y;
                const d = v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + m[2 * 3 + 2];
                return [
                    (v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + m[2 * 3 + 0]) / d,
                    (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + m[2 * 3 + 1]) / d,
                ];
            },
        };

        main();
    </script>
</body>
</html>

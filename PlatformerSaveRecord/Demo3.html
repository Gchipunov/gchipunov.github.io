<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Physics Island Concept Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; display: flex; flex-direction: column; align-items: center; }
        canvas { border: 2px solid #00f; }
        #ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 14px;
        }
        #info-box { margin-top: 10px; color: white; font-family: sans-serif; }
    </style>
</head>
<body>

    <canvas id="game-canvas" width="800" height="600"></canvas>
    
    <div id="ui-panel">
        <p>Active Islands: <span id="island-count">0</span></p>
        <p>Sleeping Bodies: <span id="sleeping-count">0</span></p>
        <button id="reset-btn">Reset Simulation</button>
    </div>
    
    <div id="info-box">
        Simulating the performance concept of **Islands** (Connected Components).
        Each unique color is an island. Gray bodies are "sleeping" (low energy).
    </div>

    <script>
        // --- WebGL Setup (Retained from previous example) ---
        const canvas = document.getElementById('game-canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) { alert('Your browser does not support WebGL.'); }

        // Minimal Shader Setup (using the previous simple shaders)
        const vsSource = `attribute vec4 a_position; uniform mat4 u_transform; void main() { gl_Position = u_transform * a_position; }`;
        const fsSource = `precision mediump float; uniform vec4 u_color; void main() { gl_FragColor = u_color; }`;
        
        function createShader(gl, type, source) { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); return shader; }
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); gl.linkProgram(program); gl.useProgram(program);

        const posAttrLoc = gl.getAttribLocation(program, 'a_position');
        const transUnifLoc = gl.getUniformLocation(program, 'u_transform');
        const colorUnifLoc = gl.getUniformLocation(program, 'u_color');

        const buffer = gl.createBuffer();
        const MAX_VERTICES = 10000;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(MAX_VERTICES * 2), gl.DYNAMIC_DRAW);
        
        gl.enableVertexAttribArray(posAttrLoc);
        gl.vertexAttribPointer(posAttrLoc, 2, gl.FLOAT, false, 0, 0);

        // --- Core Constants ---
        const BOX_SIZE = 0.04;
        const GRAVITY = -0.001;
        const SLEEP_THRESHOLD = 0.0001;
        const SLEEP_TIME_NEEDED = 180; // Frames

        // --- Utility Functions ---
        function createTranslationMatrix(tx, ty) { return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1]; }
        function createRectVertices(x, y, w, h) {
            return new Float32Array([ x, y + h, x, y, x + w, y + h, x + w, y ]);
        }
        function getRandomColor() {
            const r = Math.random() * 0.7 + 0.3; // Light colors
            const g = Math.random() * 0.7 + 0.3;
            const b = Math.random() * 0.7 + 0.3;
            return [r, g, b, 1.0];
        }

        // --- Body Structure and Initialization ---
        let bodies = [];
        const STATIC_PLATFORMS = [
            { x: -1.0, y: -1.0, w: 2.0, h: 0.1, color: [0.3, 0.3, 0.3, 1.0], isStatic: true } // Ground
        ];

        function createBody(x, y, w, h) {
            return {
                x: x, y: y, w: w, h: h,
                vx: 0, vy: 0,
                onGround: false,
                isAwake: true,
                sleepTimer: 0,
                color: getRandomColor(),
                islandId: -1, // Used for DFS/Union-Find
                marked: false, // Used for traversal
                constraints: [], // List of contact IDs
                isStatic: false
            };
        }

        // --- Pyramid Test Setup (10 pyramids, base of 5 boxes) ---
        function setupPyramids() {
            bodies = [];
            const PYRAMID_COUNT = 10;
            const BASE_SIZE = 5;
            const START_Y = -0.9 + 0.1 + BOX_SIZE / 2;
            const SPACING = (2.0 - PYRAMID_COUNT * BASE_SIZE * BOX_SIZE) / (PYRAMID_COUNT + 1);
            let startX = -1.0 + SPACING + BOX_SIZE / 2;

            for (let p = 0; p < PYRAMID_COUNT; p++) {
                let currentX = startX;
                for (let level = 0; level < BASE_SIZE; level++) {
                    const boxesInLevel = BASE_SIZE - level;
                    const levelY = START_Y + (level * BOX_SIZE);
                    const levelStartX = currentX + (level * BOX_SIZE / 2);

                    for (let i = 0; i < boxesInLevel; i++) {
                        bodies.push(createBody(levelStartX + i * BOX_SIZE, levelY, BOX_SIZE, BOX_SIZE));
                    }
                }
                startX += BASE_SIZE * BOX_SIZE + SPACING;
            }
        }
        setupPyramids();
        document.getElementById('reset-btn').onclick = setupPyramids;

        // --- Collision and Island Building Logic ---

        function isColliding(a, b) {
            const ax = a.x - a.w / 2, ay = a.y - a.h / 2;
            const bx = b.x - b.w / 2, by = b.y - b.h / 2;
            return ax < bx + b.w && ax + a.w > bx && ay < by + b.h && ay + a.h > by;
        }

        function resolveCollision(a, b) {
            // (Simplified resolution: only separate, no momentum transfer)
            const ax = a.x - a.w / 2, ay = a.y - a.h / 2;
            const bx = b.x - b.w / 2, by = b.y - b.h / 2;

            const dx = Math.min(ax + a.w - bx, bx + b.w - ax);
            const dy = Math.min(ay + a.h - by, by + b.h - ay);

            if (dx < dy) { // Horizontal
                if (ax < bx) a.x -= dx; else a.x += dx;
                a.vx = 0;
            } else { // Vertical
                if (ay < by) { a.y -= dy; a.vy = 0; } // Hit ceiling
                else { a.y += dy; a.vy = 0; a.onGround = true; } // Landed
            }

            // Waking Logic: If a collision occurs between a sleeping body and an active body, wake the sleeping one (and the whole island will propagate it).
            if (a.isAwake && !b.isStatic && !b.isAwake) { b.isAwake = true; } 
            else if (b.isAwake && !a.isStatic && !a.isAwake) { a.isAwake = true; }
        }

        // --- DFS Island Finder (The core graph traversal) ---
        function findIslands() {
            let islandIdCounter = 0;
            bodies.forEach(b => { b.islandId = -1; b.marked = false; b.constraints = []; });

            // 1. Broad Phase (Simplified to find potential contacts)
            const activeBodies = bodies.filter(b => b.isAwake);
            let constraints = [];
            
            // Dynamic-Dynamic Contacts
            for (let i = 0; i < activeBodies.length; i++) {
                for (let j = i + 1; j < activeBodies.length; j++) {
                    if (isColliding(activeBodies[i], activeBodies[j])) {
                        constraints.push([activeBodies[i], activeBodies[j]]);
                    }
                }
            }
            // Dynamic-Static Contacts
            for (const body of activeBodies) {
                for (const platform of STATIC_PLATFORMS) {
                    if (isColliding(body, platform)) {
                        // In a real engine, static bodies are NOT part of the island graph
                        // but are implicitly constraints. Here, we just use the contact
                        // to ensure the body is processed in the island, but don't add
                        // the static body to the graph.
                    }
                }
            }


            // 2. DFS Traversal to build islands
            for (let i = 0; i < bodies.length; i++) {
                const seed = bodies[i];
                if (seed.isStatic || seed.marked || !seed.isAwake) continue;

                // Found a new, awake, dynamic seed body
                const currentIslandId = islandIdCounter++;
                let stack = [seed];
                seed.marked = true;
                seed.islandId = currentIslandId;
                let islandBodies = [seed];

                while (stack.length > 0) {
                    const b = stack.pop();

                    // Check contacts with ALL other dynamic bodies (O(N^2) here, but O(N) in a real engine)
                    for (let j = 0; j < bodies.length; j++) {
                        const other = bodies[j];
                        if (other.isStatic || other.marked) continue;

                        if (isColliding(b, other)) {
                            // Found a connection (constraint/contact)
                            other.marked = true;
                            other.islandId = currentIslandId;
                            other.isAwake = true; // Waking Propagation
                            stack.push(other);
                            islandBodies.push(other);
                        }
                    }
                }

                // 3. Mark the island's color
                const islandColor = getRandomColor();
                islandBodies.forEach(b => b.color = islandColor);
            }

            // Return the count of active islands (for UI)
            return islandIdCounter;
        }


        // --- Main Simulation Loop ---

        function updateSimulation() {
            // Only update game state if not sleeping
            let totalVelocity = 0;
            let sleepingCount = 0;

            bodies.forEach(b => {
                if (b.isStatic) return;

                if (!b.isAwake) {
                    sleepingCount++;
                    // If sleeping, do nothing (Huge performance win)
                    return;
                }

                // Physics Step
                b.vy += GRAVITY;
                b.x += b.vx;
                b.y += b.vy;

                // Simple Boundary
                if (b.y < -0.9 + 0.1 + b.h / 2) { 
                    b.y = -0.9 + 0.1 + b.h / 2; 
                    b.vy = 0;
                    b.onGround = true;
                }

                totalVelocity += Math.abs(b.vx) + Math.abs(b.vy);
            });

            // Collision Resolution (Must be done for awake bodies)
            const awakeBodies = bodies.filter(b => b.isAwake);
            
            // Dynamic-Dynamic Resolution
            for (let i = 0; i < awakeBodies.length; i++) {
                for (let j = i + 1; j < awakeBodies.length; j++) {
                    if (isColliding(awakeBodies[i], awakeBodies[j])) {
                        resolveCollision(awakeBodies[i], awakeBodies[j]);
                    }
                }
            }
            // Dynamic-Static Resolution
            for (const body of awakeBodies) {
                for (const platform of STATIC_PLATFORMS) {
                    if (isColliding(body, platform)) {
                        resolveCollision(body, platform);
                    }
                }
            }

            // --- Island Management and Sleeping Logic ---
            let activeIslandsCount = 0;

            // 1. Find and color islands (Conceptually this happens before the solver)
            activeIslandsCount = findIslands();

            // 2. Island Sleep Check
            let islandSleepStates = {}; // { islandId: minSleepTimer }

            bodies.forEach(b => {
                if (b.isStatic || !b.isAwake) return;

                const velocityMag = Math.abs(b.vx) + Math.abs(b.vy);
                
                if (velocityMag > SLEEP_THRESHOLD) {
                    b.sleepTimer = 0; // Reset sleep timer if moving
                } else {
                    b.sleepTimer++; // Advance if stationary
                }
                
                // Track the minimum sleep time for the entire island
                if (islandSleepStates[b.islandId] === undefined || b.sleepTimer < islandSleepStates[b.islandId]) {
                    islandSleepStates[b.islandId] = b.sleepTimer;
                }
            });

            // 3. Apply Sleep Status to Islands
            bodies.forEach(b => {
                if (b.isStatic || !b.isAwake || b.islandId === -1) return;

                const minSleepTime = islandSleepStates[b.islandId];
                if (minSleepTime >= SLEEP_TIME_NEEDED) {
                    b.isAwake = false; // Island sleeps!
                }
            });
            
            // Update UI
            document.getElementById('island-count').textContent = activeIslandsCount;
            document.getElementById('sleeping-count').textContent = bodies.filter(b => !b.isStatic && !b.isAwake).length;
        }

        // --- WebGL Draw Function ---
        function drawScene() {
            gl.clearColor(0.1, 0.1, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            function drawRect(x, y, w, h, color) {
                const vertices = createRectVertices(x - w / 2, y - h / 2, w, h);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
                gl.uniformMatrix4fv(transUnifLoc, false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                gl.uniform4fv(colorUnifLoc, color);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            // Draw Static Platforms
            STATIC_PLATFORMS.forEach(p => drawRect(p.x + p.w / 2, p.y + p.h / 2, p.w, p.h, p.color));

            // Draw Dynamic Bodies
            bodies.forEach(b => {
                let colorToDraw;
                if (!b.isAwake) {
                    // Sleeping bodies are gray
                    colorToDraw = [0.5, 0.5, 0.5, 1.0];
                } else {
                    // Awake bodies get their island color
                    colorToDraw = b.color;
                }
                drawRect(b.x, b.y, b.w, b.h, colorToDraw);
            });
        }

        // --- Main Loop ---
        function gameLoop() {
            updateSimulation();
            drawScene();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL 2D Platformer with Replay & Touch Controls</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; display: flex; flex-direction: column; align-items: center; }
        canvas { border: 2px solid #00f; }
        #controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            pointer-events: none; /* Allows canvas clicks/touches to pass through unless on a button */
        }
        .touch-group { pointer-events: auto; }
        .touch-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            color: #000;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 10px;
            user-select: none;
            cursor: pointer;
            border: 3px solid rgba(0, 0, 0, 0.7);
        }
        #ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <canvas id="game-canvas" width="800" height="600"></canvas>

    <div id="ui-panel">
        <p>Frame: <span id="frame-counter">0</span></p>
        <p>State: <span id="game-state">Recording</span></p>
        <button id="save-btn">Stop & Save Replay</button>
        <input type="file" id="load-file" accept=".json" style="margin-top: 5px;">
        <button id="start-replay-btn" disabled>Start Replay</button>
    </div>

    <div id="controls">
        <div class="touch-group">
            <div class="touch-button" id="btn-a">A</div>
            <div class="touch-button" id="btn-d">D</div>
        </div>
        <div class="touch-group">
            <div class="touch-button" id="btn-space">JUMP</div>
        </div>
    </div>

    <script>
        // --- WebGL Setup (Simplified to 2D) ---
        const canvas = document.getElementById('game-canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) { alert('Your browser does not support WebGL.'); }

        const vsSource = `
            attribute vec4 a_position;
            uniform mat4 u_transform;
            void main() { gl_Position = u_transform * a_position; }
        `;
        const fsSource = `
            precision mediump float;
            uniform vec4 u_color;
            void main() { gl_FragColor = u_color; }
        `;

        // Shader helper functions (omitted for brevity, assume they work)
        function createShader(gl, type, source) { /* ... */ const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); return shader; } // Implementation simplified
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const posAttrLoc = gl.getAttribLocation(program, 'a_position');
        const transUnifLoc = gl.getUniformLocation(program, 'u_transform');
        const colorUnifLoc = gl.getUniformLocation(program, 'u_color');

        const buffer = gl.createBuffer();
        const MAX_VERTICES = 1000;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(MAX_VERTICES * 2), gl.DYNAMIC_DRAW);
        
        gl.enableVertexAttribArray(posAttrLoc);
        gl.vertexAttribPointer(posAttrLoc, 2, gl.FLOAT, false, 0, 0);

        // --- Core Game Constants and State ---
        const PLAYER_SIZE = 0.08; // Normalized size (0.0 to 1.0)
        const SCREEN_WIDTH = canvas.width;
        const SCREEN_HEIGHT = canvas.height;

        const GAME_CONFIG = {
            GRAVITY: -0.005,
            JUMP_VELOCITY: 0.06,
            MOVE_SPEED: 0.03
        };

        const INITIAL_STATE = {
            x: -0.5,
            y: 0.5,
            vx: 0,
            vy: 0,
            onGround: false,
        };

        let gameState = {
            ...INITIAL_STATE,
            keysPressed: {}, // Tracks currently pressed keys/buttons
            isRecording: true,
            isPlaying: false,
            replayData: [], // Stores [{ frame: N, input: 'A', type: 'down' }, ...]
            replayIndex: 0,
            frameCounter: 0,
        };

        // Normalized platform data: [x, y, width, height, color]
        const PLATFORMS = [
            // Ground
            [-1.0, -1.0, 2.0, 0.1, [0.4, 0.4, 0.4, 1.0]],
            // Mid Platform
            [-0.7, -0.4, 0.4, 0.05, [0.7, 0.5, 0.0, 1.0]],
            // High Platform
            [0.3, 0.1, 0.6, 0.05, [0.0, 0.7, 0.7, 1.0]],
        ];

        // --- Utility Functions ---

        // Matrix for translation (4x4 identity + tx/ty)
        function createTranslationMatrix(tx, ty) {
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1];
        }

        // Creates vertices for a normalized rectangle (x, y, width, height)
        function createRectVertices(x, y, w, h) {
            // (x,y) is bottom-left
            return new Float32Array([
                x,     y + h, // Top-left
                x,     y,     // Bottom-left
                x + w, y + h, // Top-right
                x + w, y      // Bottom-right
            ]);
        }

        // --- Collision Detection (AABB) ---

        // Tests for collision between two AABBs (x, y, w, h)
        function isColliding(boxA, boxB) {
            return boxA.x < boxB.x + boxB.w &&
                   boxA.x + boxA.w > boxB.x &&
                   boxA.y < boxB.y + boxB.h &&
                   boxA.y + boxA.h > boxB.y;
        }

        function resolveCollisions() {
            const playerBox = {
                x: gameState.x - PLAYER_SIZE / 2,
                y: gameState.y - PLAYER_SIZE / 2,
                w: PLAYER_SIZE,
                h: PLAYER_SIZE
            };

            gameState.onGround = false;

            PLATFORMS.forEach(p => {
                const [px, py, pw, ph] = p;
                const platformBox = { x: px, y: py, w: pw, h: ph };

                if (isColliding(playerBox, platformBox)) {
                    // Calculate penetration depth
                    const dx = Math.min(playerBox.x + playerBox.w - platformBox.x, platformBox.x + platformBox.w - playerBox.x);
                    const dy = Math.min(playerBox.y + playerBox.h - platformBox.y, platformBox.y + platformBox.h - playerBox.y);

                    if (dx < dy) { // Horizontal collision (resolve X)
                        if (playerBox.x < platformBox.x) { // Left side collision
                            gameState.x -= dx;
                        } else { // Right side collision
                            gameState.x += dx;
                        }
                        gameState.vx = 0;
                    } else { // Vertical collision (resolve Y)
                        if (playerBox.y < platformBox.y) { // Below platform, fall through/hit ceiling
                            gameState.y -= dy;
                            gameState.vy = 0;
                        } else { // Above platform, land
                            gameState.y += dy;
                            gameState.vy = 0;
                            gameState.onGround = true;
                        }
                    }
                }
            });
        }

        // --- Input and Replay Handlers ---
        
        const KEYS_MAP = { 'a': 'A', 'd': 'D', ' ': 'SPACE', 'A': 'A', 'D': 'D' };
        
        function recordInput(key, type) {
            if (gameState.isRecording) {
                gameState.replayData.push({ frame: gameState.frameCounter, input: key, type: type });
            }
        }
        
        // --- Keyboard Input ---
        document.addEventListener('keydown', (e) => {
            const key = KEYS_MAP[e.key];
            if (key && !gameState.keysPressed[key]) {
                gameState.keysPressed[key] = true;
                recordInput(key, 'down');
                if (key === 'SPACE' && gameState.onGround) {
                    gameState.vy = GAME_CONFIG.JUMP_VELOCITY;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = KEYS_MAP[e.key];
            if (key) {
                delete gameState.keysPressed[key];
                recordInput(key, 'up');
            }
        });

        // --- Touch/Button Input ---
        document.getElementById('btn-a').addEventListener('touchstart', (e) => { e.preventDefault(); gameState.keysPressed['A'] = true; recordInput('A', 'down'); });
        document.getElementById('btn-a').addEventListener('touchend', () => { delete gameState.keysPressed['A']; recordInput('A', 'up'); });

        document.getElementById('btn-d').addEventListener('touchstart', (e) => { e.preventDefault(); gameState.keysPressed['D'] = true; recordInput('D', 'down'); });
        document.getElementById('btn-d').addEventListener('touchend', () => { delete gameState.keysPressed['D']; recordInput('D', 'up'); });

        document.getElementById('btn-space').addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            if (!gameState.keysPressed['SPACE']) { // Only register the down event once per frame
                gameState.keysPressed['SPACE'] = true; 
                recordInput('SPACE', 'down'); 
            }
            if (gameState.onGround) {
                gameState.vy = GAME_CONFIG.JUMP_VELOCITY;
            }
        });
        document.getElementById('btn-space').addEventListener('touchend', () => { delete gameState.keysPressed['SPACE']; recordInput('SPACE', 'up'); });

        // --- Replay Logic ---
        const saveBtn = document.getElementById('save-btn');
        const loadFileInput = document.getElementById('load-file');
        const startReplayBtn = document.getElementById('start-replay-btn');

        saveBtn.onclick = () => {
            gameState.isRecording = false;
            gameState.isPlaying = false;
            saveBtn.disabled = true;

            const replayObject = {
                gameVersion: "v1.0-platformer",
                durationFrames: gameState.frameCounter,
                inputs: gameState.replayData,
                initialState: INITIAL_STATE // Save the clean initial state
            };
            const json = JSON.stringify(replayObject, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `platformer_replay_${new Date().toISOString().slice(0, 16).replace(/[:T]/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            document.getElementById('game-state').textContent = 'Saved & Halted';
            startReplayBtn.disabled = false;
        };

        loadFileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    gameState.loadedReplay = loadedData;
                    startReplayBtn.disabled = false;
                    document.getElementById('game-state').textContent = 'Replay Ready';
                } catch (error) {
                    console.error("Error loading replay file:", error);
                    alert("Invalid replay file.");
                }
            };
            reader.readAsText(file);
        };

        startReplayBtn.onclick = () => {
            if (!gameState.loadedReplay) return;
            
            // 1. Reset Game State to Initial
            gameState = {
                ...INITIAL_STATE,
                x: gameState.loadedReplay.initialState.x,
                y: gameState.loadedReplay.initialState.y,
                keysPressed: {},
                isRecording: false,
                isPlaying: true,
                replayData: gameState.loadedReplay.inputs,
                replayIndex: 0,
                frameCounter: 0,
            };
            document.getElementById('game-state').textContent = 'Playing Replay';
            saveBtn.disabled = true;
            startReplayBtn.disabled = true;
        };


        // --- Game Logic Update ---
        function updateGame() {
            // Apply physics
            gameState.vy += GAME_CONFIG.GRAVITY; // Gravity
            
            // Movement based on current input state
            gameState.vx = 0;
            if (gameState.keysPressed['A']) { gameState.vx -= GAME_CONFIG.MOVE_SPEED; }
            if (gameState.keysPressed['D']) { gameState.vx += GAME_CONFIG.MOVE_SPEED; }
            
            // Apply velocities
            gameState.x += gameState.vx;
            gameState.y += gameState.vy;
            
            // Handle Collisions
            resolveCollisions();
        }

        function updateReplay() {
            if (gameState.isPlaying) {
                // Check for input events at the current frame
                while (gameState.replayIndex < gameState.replayData.length) {
                    const event = gameState.replayData[gameState.replayIndex];
                    if (event.frame === gameState.frameCounter) {
                        // Apply the recorded input event
                        if (event.type === 'down') {
                            gameState.keysPressed[event.input] = true;
                            // Replay jump logic (must be re-run here as it's state-dependent)
                            if (event.input === 'SPACE' && gameState.onGround) {
                                gameState.vy = GAME_CONFIG.JUMP_VELOCITY;
                            }
                        } else if (event.type === 'up') {
                            delete gameState.keysPressed[event.input];
                        }
                        gameState.replayIndex++;
                    } else {
                        // Wait for the next frame
                        break; 
                    }
                }

                updateGame(); // Update physics and position based on new keysPressed state

                // Stop playback when done
                if (gameState.frameCounter >= gameState.loadedReplay.durationFrames) {
                    gameState.isPlaying = false;
                    document.getElementById('game-state').textContent = 'Replay Finished';
                    startReplayBtn.disabled = false;
                }
            } else if (gameState.isRecording) {
                updateGame();
            }
        }

        // --- WebGL Draw Function ---
        function drawScene() {
            gl.clearColor(0.1, 0.1, 0.2, 1.0); // Dark background
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Helper function to draw a single rect
            function drawRect(x, y, w, h, color) {
                const vertices = createRectVertices(x, y, w, h);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
                
                // Use identity matrix for platforms since they are already in world space
                gl.uniformMatrix4fv(transUnifLoc, false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                gl.uniform4fv(colorUnifLoc, color);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            // Draw Platforms
            PLATFORMS.forEach(p => drawRect(p[0], p[1], p[2], p[3], p[4]));

            // Draw Player
            const playerX = gameState.x - PLAYER_SIZE / 2;
            const playerY = gameState.y - PLAYER_SIZE / 2;
            drawRect(playerX, playerY, PLAYER_SIZE, PLAYER_SIZE, [0.0, 1.0, 0.0, 1.0]); // Green player
        }

        // --- Main Loop ---
        function gameLoop() {
            if (gameState.isRecording || gameState.isPlaying) {
                updateReplay(); // Central update function
                gameState.frameCounter++;
            }
            
            drawScene();
            
            // Update UI
            document.getElementById('frame-counter').textContent = gameState.frameCounter;

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>

</body>
</html>

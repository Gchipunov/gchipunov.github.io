<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Pie Microwave</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            pointer-events: none; text-shadow: 2px 2px 4px #000;
        }
        #msg { font-size: 24px; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Pie Microwave 3000</h1>
    <p>HOLD MOUSE to cook. Release when GOLDEN!</p>
    <div id="status">Status: Waiting...</div>
    <div id="msg"></div>
</div>

<canvas id="glCanvas"></canvas>

<script>
/**
 * SHADERS
 * We use a simple vertex shader and a fragment shader that 
 * changes color based on a "cookLevel" uniform.
 */
const vsSource = `
    attribute house vec4 aVertexPosition;
    attribute vec3 aNormal;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    varying highp vec3 vLighting;
    void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);
        highp vec3 directionalLightColor = vec3(1, 1, 1);
        highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));
        highp float directional = max(dot(aNormal, directionalVector), 0.0);
        vLighting = ambientLight + (directionalLightColor * directional);
    }
`;

const fsSource = `
    precision mediump float;
    varying highp vec3 vLighting;
    uniform vec3 uColor;
    void main(void) {
        gl_FragColor = vec4(uColor * vLighting, 1.0);
    }
`;

// --- Game Logic Variables ---
let cookLevel = 0.0; // 0.0 (Raw) -> 0.7 (Golden) -> 1.0 (Burnt)
let isCooking = false;
let gameOver = false;

const canvas = document.querySelector('#glCanvas');
const gl = canvas.getContext('webgl');

if (!gl) { alert('WebGL not supported'); }

// Initialize Shaders
function initShaderProgram(gl, vs, fs) {
    const vShader = loadShader(gl, gl.VERTEX_SHADER, vs);
    const fShader = loadShader(gl, gl.FRAGMENT_SHADER, fs);
    const prog = gl.createProgram();
    gl.attachShader(prog, vShader);
    gl.attachShader(prog, fShader);
    gl.linkProgram(prog);
    return prog;
}

function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
const programInfo = {
    program: shaderProgram,
    attribLocations: {
        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
        normal: gl.getAttribLocation(shaderProgram, 'aNormal'),
    },
    uniformLocations: {
        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
        uColor: gl.getUniformLocation(shaderProgram, 'uColor'),
    },
};

// Create a Cylinder (The Pie)
function createPie(gl) {
    const positions = [];
    const normals = [];
    const radius = 1.0;
    const height = 0.4;
    const segments = 30;

    for (let i = 0; i <= segments; i++) {
        let theta = i * 2 * Math.PI / segments;
        let x = Math.cos(theta) * radius;
        let z = Math.sin(theta) * radius;
        // Top and bottom vertices
        positions.push(x, height, z); normals.push(0, 1, 0);
        positions.push(x, -height, z); normals.push(0, -1, 0);
    }

    const posBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const normBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

    return { pos: posBuffer, norm: normBuffer, count: (segments + 1) * 2 };
}

const buffers = createPie(gl);

// --- Matrix Math Helpers ---
function perspective(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    return [f/aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far+near)*nf, -1, 0, 0, (2*far*near)*nf, 0];
}

function translate(m, v) {
    m[12] += v[0]; m[13] += v[1]; m[14] += v[2];
}

function rotateY(m, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const m0 = m[0], m2 = m[2], m8 = m[8], m10 = m[10];
    m[0] = m0 * c - m8 * s; m[2] = m2 * c - m10 * s;
    m[8] = m0 * s + m8 * c; m[10] = m2 * s + m10 * c;
}

// --- Render Loop ---
let rotation = 0;
function render(now) {
    if (isCooking && !gameOver) {
        cookLevel += 0.005;
        document.getElementById('status').innerText = "COOKING...";
        if (cookLevel > 1.2) endGame();
    }

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    const aspect = canvas.width / canvas.height;
    const projMatrix = perspective(45 * Math.PI / 180, aspect, 0.1, 100.0);
    const mvMatrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
    translate(mvMatrix, [0, 0, -5]);
    rotateY(mvMatrix, rotation);
    rotation += isCooking ? 0.08 : 0.01;

    // Calculate Color based on cook level
    // Raw (Light Beige) -> Golden (Orange/Brown) -> Burnt (Black)
    let r = 0.9 - cookLevel;
    let g = 0.8 - (cookLevel * 0.8);
    let b = 0.6 - (cookLevel * 0.6);
    if (cookLevel > 0.7) { // Start charring
        const char = (cookLevel - 0.7) * 2;
        r -= char; g -= char; b -= char;
    }

    gl.useProgram(programInfo.program);
    gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projMatrix);
    gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, mvMatrix);
    gl.uniform3fv(programInfo.uniformLocations.uColor, [Math.max(r,0), Math.max(g,0), Math.max(b,0)]);

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.pos);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.norm);
    gl.vertexAttribPointer(programInfo.attribLocations.normal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.normal);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffers.count);

    requestAnimationFrame(render);
}

// --- Interaction ---
window.addEventListener('mousedown', () => { if(!gameOver) isCooking = true; });
window.addEventListener('mouseup', () => { 
    if(isCooking && !gameOver) endGame(); 
    isCooking = false; 
});

function endGame() {
    gameOver = true;
    const msg = document.getElementById('msg');
    if (cookLevel < 0.5) {
        msg.innerText = "IT'S RAW! YOU DONKEY!";
        msg.style.color = "cyan";
    } else if (cookLevel >= 0.5 && cookLevel <= 0.8) {
        msg.innerText = "PERFECTLY GOLDEN! 5 STARS!";
        msg.style.color = "gold";
    } else {
        msg.innerText = "YOU BURNT IT! FIRE ALARM!";
        msg.style.color = "red";
    }
    document.getElementById('status').innerText = "Finished.";
}

// Resize handling
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

requestAnimationFrame(render);
</script>
</body>
</html>

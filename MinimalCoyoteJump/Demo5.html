<!DOCTYPE html>
<html>
<head>
    <title>WebGL Coyote Jump - Fixed Parallax</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; font-family: sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px;
            box-sizing: border-box; pointer-events: none;
        }
        .btn {
            width: 80px; height: 80px; background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; color: white;
            font-size: 24px; font-weight: bold; user-select: none; pointer-events: auto;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); }
        .group { display: flex; gap: 20px; }
        
        #ability-ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 12px;
            border-radius: 8px; color: white; pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="ability-ui">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="coyoteToggle" checked> Coyote Jump
        </label>
    </div>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div class="group">
            <div class="btn" id="btnLeft">←</div>
            <div class="btn" id="btnRight">→</div>
        </div>
        <div class="btn" id="btnJump">↑</div>
    </div>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 pos;
    uniform vec2 offset;
    uniform vec2 scale;
    uniform vec2 camera;
    uniform float aspect;
    void main() {
        // Adjust x-scale by aspect ratio to keep squares square
        vec2 position = (pos * scale + offset - camera);
        gl_Position = vec4(position.x / aspect, position.y, 0, 1);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 color;
    void main() {
        gl_FragColor = color;
    }
</script>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    const coyoteToggle = document.getElementById('coyoteToggle');

    function createShader(gl, type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(s));
        }
        return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
    gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(prog, 'pos');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const offsetLoc = gl.getUniformLocation(prog, 'offset');
    const scaleLoc = gl.getUniformLocation(prog, 'scale');
    const colorLoc = gl.getUniformLocation(prog, 'color');
    const cameraLoc = gl.getUniformLocation(prog, 'camera');
    const aspectLoc = gl.getUniformLocation(prog, 'aspect');

    // Game State
    let player = { x: 0, y: 0.5, vx: 0, vy: 0, w: 0.05, h: 0.07 };
    let camera = { x: 0, y: 0 };
    
    const platforms = [
        { x: 0,    y: -0.8, w: 5.0, h: 0.1 }, 
        { x: -0.8, y: -0.4, w: 0.3, h: 0.04 },
        { x: 0.6,  y: -0.1, w: 0.3, h: 0.04 },
        { x: 1.8,  y: 0.3,  w: 0.3, h: 0.04 }
    ];

    const mountains = [
        { x: -1.5, y: -0.2, w: 1.5, h: 0.8, col: [0.2, 0.2, 0.35, 1] },
        { x: 0.5,  y: -0.3, w: 2.0, h: 1.0, col: [0.15, 0.15, 0.3, 1] },
        { x: 2.5,  y: -0.2, w: 1.5, h: 0.7, col: [0.2, 0.2, 0.35, 1] }
    ];

    const trees = [
        { x: -1.2, y: -0.5, w: 0.08, h: 0.25, col: [0.1, 0.3, 0.2, 1] },
        { x: -0.4, y: -0.5, w: 0.08, h: 0.35, col: [0.1, 0.4, 0.2, 1] },
        { x: 1.0,  y: -0.5, w: 0.08, h: 0.3,  col: [0.1, 0.35, 0.2, 1] },
        { x: 2.2,  y: -0.5, w: 0.08, h: 0.4,  col: [0.1, 0.4, 0.2, 1] }
    ];

    let keys = {};
    let coyoteFrames = 0;
    const COYOTE_MAX = 12;

    window.onkeydown = e => keys[e.code] = true;
    window.onkeyup = e => keys[e.code] = false;

    const bindTouch = (id, keyName) => {
        const el = document.getElementById(id);
        const handle = (e, val) => { e.preventDefault(); keys[keyName] = val; };
        el.addEventListener('touchstart', (e) => handle(e, true), {passive: false});
        el.addEventListener('touchend', (e) => handle(e, false), {passive: false});
    };
    bindTouch('btnLeft', 'ArrowLeft'); 
    bindTouch('btnRight', 'ArrowRight'); 
    bindTouch('btnJump', 'Space');

    function update() {
        if (keys['ArrowLeft']) player.vx = -0.015;
        else if (keys['ArrowRight']) player.vx = 0.015;
        else player.vx *= 0.85;

        player.vy -= 0.0015; 
        player.x += player.vx;
        player.y += player.vy;

        let onGround = false;
        platforms.forEach(p => {
            if (player.x + player.w > p.x - p.w && player.x - player.w < p.x + p.w &&
                player.y - player.h < p.y + p.h && player.y + player.h > p.y - p.h && player.vy < 0) {
                player.y = p.y + p.h + player.h;
                player.vy = 0;
                onGround = true;
            }
        });

        coyoteFrames = onGround ? COYOTE_MAX : coyoteFrames - 1;
        const canJump = coyoteToggle.checked ? (coyoteFrames > 0) : onGround;

        if (keys['Space'] && canJump) {
            player.vy = 0.035;
            coyoteFrames = 0;
        }

        camera.x += (player.x - camera.x) * 0.1;
        camera.y += (player.y - camera.y) * 0.1;

        if (player.y < -2.0) { player.x = 0; player.y = 0.5; player.vy = 0; }
    }

    function drawRect(x, y, w, h, color, camX, camY) {
        gl.uniform2f(offsetLoc, x, y);
        gl.uniform2f(scaleLoc, w, h);
        gl.uniform2f(cameraLoc, camX, camY);
        gl.uniform4fv(colorLoc, color);
        gl.uniform1f(aspectLoc, canvas.width / canvas.height);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function loop() {
        // Handle window resizing
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        update();
        gl.clearColor(0.1, 0.1, 0.18, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // 1. Distant Mountains (Slow Parallax)
        mountains.forEach(m => drawRect(m.x, m.y, m.w, m.h, m.col, camera.x * 0.2, camera.y * 0.1));

        // 2. Trees (Medium Parallax)
        trees.forEach(t => drawRect(t.x, t.y, t.w, t.h, t.col, camera.x * 0.5, camera.y * 0.3));

        // 3. Gameplay Layer (Full Speed)
        platforms.forEach((p, i) => {
            const col = i === 0 ? [0.2, 0.2, 0.25, 1] : [0.3, 0.6, 0.3, 1];
            drawRect(p.x, p.y, p.w, p.h, col, camera.x, camera.y);
        });
        
        // Player
        drawRect(player.x, player.y, player.w, player.h, [0.9, 0.3, 0.3, 1], camera.x, camera.y);

        requestAnimationFrame(loop);
    }
    
    loop();
</script>
</body>
</html>

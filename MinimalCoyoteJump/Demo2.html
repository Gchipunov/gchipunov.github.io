<!DOCTYPE html>
<html>
<head>
    <title>WebGL Coyote Jump - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* Mobile UI Overlay */
        #ui {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
        }
        .btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            user-select: none;
            pointer-events: auto;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); }
        .group { display: flex; gap: 10px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui">
        <div class="group">
            <div class="btn" id="btnLeft">←</div>
            <div class="btn" id="btnRight">→</div>
        </div>
        <div class="btn" id="btnJump">JUMP</div>
    </div>

<script id="vs" type="f">
    attribute vec2 pos;
    uniform vec2 offset;
    uniform vec2 scale;
    void main() {
        gl_Position = vec4((pos * scale + offset), 0, 1);
    }
</script>

<script id="fs" type="f">
    precision mediump float;
    uniform vec4 color;
    void main() {
        gl_FragColor = color;
    }
</script>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    function createShader(gl, type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        return s;
    }

    const prog = gl.createProgram();
    gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
    gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(prog, 'pos');
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const offsetLoc = gl.getUniformLocation(prog, 'offset');
    const scaleLoc = gl.getUniformLocation(prog, 'scale');
    const colorLoc = gl.getUniformLocation(prog, 'color');

    // Game State
    let player = { x: -0.8, y: 0, vx: 0, vy: 0, w: 0.05, h: 0.08 };
    const platforms = [
        { x: -0.8, y: -0.5, w: 0.3, h: 0.05 },
        { x: 0,    y: -0.2, w: 0.3, h: 0.05 },
        { x: 0.7,  y: 0.2,  w: 0.3, h: 0.05 }
    ];

    let keys = {};
    let coyoteFrames = 0;
    const COYOTE_MAX = 10;

    // Keyboard Listeners
    window.onkeydown = e => keys[e.code] = true;
    window.onkeyup = e => keys[e.code] = false;

    // Mobile Touch Listeners
    const bindTouch = (id, keyName) => {
        const el = document.getElementById(id);
        const start = (e) => { e.preventDefault(); keys[keyName] = true; };
        const end = (e) => { e.preventDefault(); keys[keyName] = false; };
        el.addEventListener('touchstart', start);
        el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start); // Support mouse testing
        el.addEventListener('mouseup', end);
    };

    bindTouch('btnLeft', 'ArrowLeft');
    bindTouch('btnRight', 'ArrowRight');
    bindTouch('btnJump', 'Space');

    function update() {
        if (keys['ArrowLeft']) player.vx = -0.01;
        else if (keys['ArrowRight']) player.vx = 0.01;
        else player.vx *= 0.8;

        player.vy -= 0.001; 
        player.x += player.vx;
        player.y += player.vy;

        let onGround = false;
        platforms.forEach(p => {
            if (player.x + player.w > p.x - p.w && player.x - player.w < p.x + p.w &&
                player.y - player.h < p.y + p.h && player.y + player.h > p.y - p.h && player.vy < 0) {
                player.y = p.y + p.h + player.h;
                player.vy = 0;
                onGround = true;
            }
        });

        if (onGround) coyoteFrames = COYOTE_MAX;
        else coyoteFrames--;

        if (keys['Space'] && coyoteFrames > 0) {
            player.vy = 0.025;
            coyoteFrames = 0; 
        }

        if (player.y < -1.1) { player.x = -0.8; player.y = 0; player.vy = 0; }
        
        // Horizontal Screen Wrap
        if (player.x > 1.1) player.x = -1.1;
        if (player.x < -1.1) player.x = 1.1;
    }

    function drawRect(x, y, w, h, color) {
        gl.uniform2f(offsetLoc, x, y);
        gl.uniform2f(scaleLoc, w, h);
        gl.uniform4fv(colorLoc, color);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function loop() {
        update();
        gl.clearColor(0.1, 0.1, 0.1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        platforms.forEach(p => drawRect(p.x, p.y, p.w, p.h, [0.3, 0.7, 0.3, 1]));
        drawRect(player.x, player.y, player.w, player.h, [0.9, 0.3, 0.3, 1]);

        requestAnimationFrame(loop);
    }

    loop();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poop Aura Game 6 WebGL 2D Platformer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 12px;
            font-size: 16px;
            text-align: center;
        }
        #touch-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none; /* Hidden by default */
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }
        .control-group {
            display: flex;
            gap: 10px;
        }
        .touch-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.4);
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-button:active {
            background-color: rgba(255, 255, 255, 0.4);
        }
        @media (pointer: coarse) {
            #controls-overlay {
                display: none;
            }
            #touch-controls {
                display: flex;
            }
        }
        #end-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            text-align: center;
            gap: 20px;
        }
        #end-screen h2, #game-over-screen h2 {
            font-size: 48px;
            margin-bottom: 10px;
        }
        #end-screen p, #game-over-screen p {
            margin: 5px 0;
        }
        #restart-button, #game-over-button {
            padding: 10px 20px;
            font-size: 20px;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            margin-top: 20px;
        }
        #restart-button:hover, #game-over-button:hover {
            background-color: #45a049;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            display: flex;
            gap: 5px;
        }
        .heart {
            color: red;
            font-size: 30px;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls-overlay">
        Use Arrow Keys to Move & Spacebar to Jump
    </div>
    <div id="touch-controls">
        <div class="control-group">
            <div class="touch-button" id="left-button">&lt;</div>
            <div class="touch-button" id="right-button">&gt;</div>
        </div>
        <div class="control-group">
            <div class="touch-button" id="jump-button">↑</div>
        </div>
    </div>
    <div id="hud">
        <span id="heart1" class="heart">❤</span>
        <span id="heart2" class="heart">❤</span>
        <span id="heart3" class="heart">❤</span>
    </div>
    <div id="end-screen">
        <h2>Level Complete!</h2>
        <p>Time: <span id="time-stat">0s</span></p>
        <p>Max Jump Height: <span id="height-stat">0</span></p>
        <p>Platforms Landed On: <span id="blocks-stat">0</span></p>
        <button id="restart-button">Restart</button>
    </div>
    <div id="game-over-screen">
        <h2>Game Over!</h2>
        <p>Time: <span id="game-over-time-stat">0s</span></p>
        <p>Platforms Landed On: <span id="game-over-blocks-stat">0</span></p>
        <button id="game-over-button">Try Again</button>
    </div>

    <script>
        // Main entry point
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('WebGL is not supported by your browser.');
                return;
            }

            // --- Game State and Configuration ---
            const game = {
                levelComplete: false,
                gameOver: false,
                startTime: null,
                endTime: null,
                maxJumpHeight: 0,
                blocksJumpedOn: 0
            };
            
            const world = {
                width: 4000,
                height: 900,
                gravity: 0.8
            };

            const player = {
                x: 100,
                y: 500,
                width: 40,
                height: 60,
                velocityX: 0,
                velocityY: 0,
                speed: 6,
                jumpForce: 18,
                onGround: false,
                jumps: 0,
                health: 3,
                color: [0.9, 0.3, 0.3], // Reddish color
                invincible: false,
                invincibleTimer: 0
            };

            // Added lastPlatform variable to track what the player is on
            let lastPlatform = null;

            const camera = {
                x: 0,
                y: 0,
                width: 1600,
                height: 900
            };

            const platforms = [
                // Ground
                { x: 0, y: 0, width: world.width, height: 40, color: [0.4, 0.5, 0.4] },
                // Floating platforms - Original
                { x: 250, y: 150, width: 200, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 550, y: 300, width: 200, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 800, y: 450, width: 250, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 500, y: 600, width: 150, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 1200, y: 200, width: 300, height: 30, color: [0.4, 0.5, 0.4] },
                { x: 1300, y: 550, width: 100, height: 30, color: [0.4, 0.5, 0.4] },
                // New Platforms for an extended level
                { x: 1800, y: 350, width: 200, height: 30, color: [0.5, 0.6, 0.5] },
                { x: 2100, y: 500, width: 150, height: 30, color: [0.5, 0.6, 0.5] },
                { x: 2400, y: 250, width: 250, height: 30, color: [0.5, 0.6, 0.5] },
                { x: 2800, y: 400, width: 200, height: 30, color: [0.5, 0.6, 0.5] },
                { x: 3100, y: 600, width: 100, height: 30, color: [0.5, 0.6, 0.5] },
                { x: 3400, y: 700, width: 300, height: 30, color: [0.5, 0.6, 0.5] },
                // End Platform
                { x: 3800, y: 500, width: 200, height: 30, color: [0.9, 0.9, 0.2], isEndPlatform: true },
            ];

            const enemies = [
                { x: 700, y: 550, width: 50, height: 50, color: [0.2, 0.8, 0.8], patrol: { start: 700, end: 900, direction: 1 }, lastShot: 0, shootInterval: 1.5 },
                { x: 2000, y: 550, width: 50, height: 50, color: [0.2, 0.8, 0.8], patrol: { start: 2000, end: 2300, direction: 1 }, lastShot: 0, shootInterval: 2 },
                { x: 3000, y: 650, width: 50, height: 50, color: [0.2, 0.8, 0.8], patrol: { start: 3000, end: 3200, direction: 1 }, lastShot: 0, shootInterval: 1 },
            ];
            
            let bullets = [];

            const keys = {};

            // --- GLSL Shaders ---
            const vsSource = `
                attribute vec2 aVertexPosition;
                uniform mat4 uProjectionMatrix;
                uniform mat4 uModelViewMatrix;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition, 0.0, 1.0);
                }
            `;

            const fsSource = `
                precision mediump float;
                uniform vec3 uColor;
                void main() {
                    gl_FragColor = vec4(uColor, 1.0);
                }
            `;

            // --- WebGL Setup ---
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    color: gl.getUniformLocation(shaderProgram, 'uColor'),
                },
            };

            const rectBuffer = initBuffers(gl);

            // --- Event Listeners ---
            window.addEventListener('keydown', (e) => { keys[e.code] = true; });
            window.addEventListener('keyup', (e) => { keys[e.code] = false; });
            
            // --- Mobile Touch Event Listeners ---
            const leftButton = document.getElementById('left-button');
            const rightButton = document.getElementById('right-button');
            const jumpButton = document.getElementById('jump-button');
            
            // Map touch buttons to keys object
            leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; }, false);
            leftButton.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; }, false);
            leftButton.addEventListener('touchcancel', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; }, false);
            
            rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; }, false);
            rightButton.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowRight'] = false; }, false);
            rightButton.addEventListener('touchcancel', (e) => { e.preventDefault(); keys['ArrowRight'] = false; }, false);
            
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; }, false);
            jumpButton.addEventListener('touchend', (e) => { e.preventDefault(); keys['Space'] = false; }, false);
            jumpButton.addEventListener('touchcancel', (e) => { e.preventDefault(); keys['Space'] = false; }, false);
            
            document.getElementById('restart-button').addEventListener('click', () => {
                resetGame();
            });
            document.getElementById('game-over-button').addEventListener('click', () => {
                resetGame();
            });

            // Hide/show the correct controls based on device
            function setupControls() {
                const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
                const controlsOverlay = document.getElementById('controls-overlay');
                const touchControls = document.getElementById('touch-controls');
                if (isTouchDevice) {
                    controlsOverlay.style.display = 'none';
                    touchControls.style.display = 'flex';
                } else {
                    controlsOverlay.style.display = 'block';
                    touchControls.style.display = 'none';
                }
            }
            setupControls();
            window.addEventListener('resize', setupControls);

            function updateHUD() {
                for (let i = 1; i <= 3; i++) {
                    const heart = document.getElementById(`heart${i}`);
                    if (heart) {
                        heart.style.color = (i <= player.health) ? 'red' : 'gray';
                    }
                }
            }

            function takeDamage() {
                if (player.invincible) return;
                player.health--;
                player.invincible = true;
                player.invincibleTimer = 1.5; // 1.5 seconds of invincibility
                updateHUD();
                if (player.health <= 0) {
                    game.gameOver = true;
                    showGameOverScreen();
                }
            }

            function resetGame() {
                player.x = 100;
                player.y = 500;
                player.velocityX = 0;
                player.velocityY = 0;
                player.onGround = false;
                player.jumps = 0;
                player.health = 3;
                player.invincible = false;
                player.invincibleTimer = 0;
                lastPlatform = null; // Reset last platform on game reset

                game.levelComplete = false;
                game.gameOver = false;
                game.startTime = Date.now();
                game.endTime = null;
                game.maxJumpHeight = player.y;
                game.blocksJumpedOn = 0;

                // Reset enemies and bullets
                enemies.forEach(e => {
                    e.x = e.patrol.start;
                    e.direction = 1;
                    e.lastShot = 0;
                });
                bullets = [];

                document.getElementById('end-screen').style.display = 'none';
                document.getElementById('game-over-screen').style.display = 'none';
                document.getElementById('controls-overlay').style.display = 'block';
                document.getElementById('hud').style.display = 'flex';
                updateHUD();
            }

            // --- Game Loop ---
            let lastTime = 0;
            function gameLoop(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000; // time in seconds
                lastTime = currentTime;

                if (!game.levelComplete && !game.gameOver) {
                    update(deltaTime);
                    drawScene(gl, programInfo, rectBuffer);
                }
                
                requestAnimationFrame(gameLoop);
            }

            // --- Update Logic ---
            function update(deltaTime) {
                // Horizontal movement
                player.velocityX = 0;
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    player.velocityX = -player.speed;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    player.velocityX = player.speed;
                }

                // Jumping (now with double jump)
                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.jumps > 0) {
                    player.velocityY = player.jumpForce;
                    player.jumps--;
                    lastPlatform = null; // Player is no longer on a platform
                    keys['Space'] = false; // Prevent holding jump button
                    keys['ArrowUp'] = false;
                    keys['KeyW'] = false;
                }

                // Apply physics
                player.x += player.velocityX;
                player.y += player.velocityY;

                // Apply gravity
                player.velocityY -= world.gravity;
                player.onGround = false;
                
                // Track max jump height
                if (player.y > game.maxJumpHeight) {
                    game.maxJumpHeight = player.y;
                }

                // Invincibility timer
                if (player.invincible) {
                    player.invincibleTimer -= deltaTime;
                    if (player.invincibleTimer <= 0) {
                        player.invincible = false;
                    }
                }

                // Collision detection with platforms
                let onAplatform = false;
                for (const platform of platforms) {
                    // Check for AABB collision
                    if (player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x &&
                        player.y < platform.y + platform.height &&
                        player.y + player.height > platform.y) {
                        
                        // Collision occurred, determine direction
                        const playerBottom = player.y;
                        const playerPrevBottom = player.y - player.velocityY;
                        const platformTop = platform.y + platform.height;

                        // Check if player was above the platform in the previous frame
                        if (playerPrevBottom >= platformTop) {
                            player.y = platformTop;
                            player.velocityY = 0;
                            onAplatform = true;
                            // Check if this is a new platform to count
                            if (lastPlatform !== platform) {
                                // Reset jumps when landing on a NEW platform
                                player.jumps = 2;
                                // Count blocks jumped on, but not the ground
                                if (platform.y > 0) {
                                    game.blocksJumpedOn++;
                                }
                                lastPlatform = platform;
                            }
                            
                            // Check for end platform
                            if (platform.isEndPlatform && !game.levelComplete) {
                                game.levelComplete = true;
                                game.endTime = Date.now();
                                showEndScreen();
                            }
                        }
                    }
                }
                if (!onAplatform) {
                    lastPlatform = null; // Player is no longer on a platform
                }

                // Enemy logic
                for (const enemy of enemies) {
                    // Patrol movement
                    enemy.x += 1.5 * enemy.patrol.direction;
                    if (enemy.x > enemy.patrol.end || enemy.x < enemy.patrol.start) {
                        enemy.direction *= -1;
                    }

                    // Shooting
                    enemy.lastShot += deltaTime;
                    if (enemy.lastShot > enemy.shootInterval) {
                        // Check if player is on the same height or lower
                        if (player.y < enemy.y && player.y + player.height > enemy.y - 100) {
                            const bulletSpeed = 5;
                            const bulletVelocityX = (player.x + player.width / 2 - enemy.x + enemy.width / 2 > 0) ? bulletSpeed : -bulletSpeed;
                            const bulletVelocityY = (player.y + player.height / 2 - enemy.y + enemy.height / 2 > 0) ? bulletSpeed : -bulletSpeed;
                            bullets.push({ 
                                x: enemy.x + enemy.width / 2, 
                                y: enemy.y + enemy.height / 2, 
                                velocityX: bulletVelocityX,
                                velocityY: bulletVelocityY,
                                width: 10, 
                                height: 10, 
                                color: [1.0, 0.0, 0.0] 
                            });
                            enemy.lastShot = 0;
                        }
                    }

                    // Collision with player
                    if (player.x < enemy.x + enemy.width &&
                        player.x + player.width > enemy.x &&
                        player.y < enemy.y + enemy.height &&
                        player.y + player.height > enemy.y) {
                        takeDamage();
                    }
                }

                // Bullet logic
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    bullet.x += bullet.velocityX;
                    bullet.y += bullet.velocityY;

                    // Bullet collision with player
                    if (player.x < bullet.x + bullet.width &&
                        player.x + player.width > bullet.x &&
                        player.y < bullet.y + bullet.height &&
                        player.y + player.height > bullet.y) {
                        takeDamage();
                        bullets.splice(i, 1); // Remove bullet
                    } else if (bullet.x < camera.x - 50 || bullet.x > camera.x + camera.width + 50 || bullet.y < -100 || bullet.y > world.height + 100) {
                        bullets.splice(i, 1); // Remove bullet if off-screen
                    }
                }

                // World boundaries
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > world.width) player.x = world.width - player.width;

                // Respawn if falls off
                if (player.y < -100) {
                    takeDamage();
                }

                // Update camera position to follow the player
                camera.x = player.x - camera.width / 2;

                // Clamp camera to world boundaries
                if (camera.x < 0) {
                    camera.x = 0;
                }
                if (camera.x + camera.width > world.width) {
                    camera.x = world.width - camera.width;
                }
            }

            // --- Drawing Logic ---
            function drawScene(gl, programInfo, buffer) {
                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.clearColor(0.1, 0.15, 0.2, 1.0); // Dark blue background
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Create a projection matrix that includes the camera's position
                const projectionMatrix = createOrthographic(camera.x, camera.x + camera.width, 0, camera.height, -1, 1);

                gl.useProgram(programInfo.program);
                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

                // Draw platforms
                for (const platform of platforms) {
                    drawRect(gl, programInfo, buffer, platform.x, platform.y, platform.width, platform.height, platform.color);
                }

                // Draw enemies
                for (const enemy of enemies) {
                    drawRect(gl, programInfo, buffer, enemy.x, enemy.y, enemy.width, enemy.height, enemy.color);
                }

                // Draw bullets
                for (const bullet of bullets) {
                    drawRect(gl, programInfo, buffer, bullet.x, bullet.y, bullet.width, bullet.height, bullet.color);
                }

                // Draw player (flicker if invincible)
                if (!player.invincible || (Math.floor(Date.now() / 100) % 2 === 0)) {
                    drawRect(gl, programInfo, buffer, player.x, player.y, player.width, player.height, player.color);
                }
            }

            function drawRect(gl, programInfo, buffer, x, y, width, height, color) {
                let modelViewMatrix = identity();
                modelViewMatrix = translate(modelViewMatrix, x, y, 0);
                modelViewMatrix = scale(modelViewMatrix, width, height, 1);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer.position);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
                gl.uniform3fv(programInfo.uniformLocations.color, color);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            function showEndScreen() {
                const totalTime = ((game.endTime - game.startTime) / 1000).toFixed(2);
                document.getElementById('time-stat').textContent = `${totalTime}s`;
                document.getElementById('height-stat').textContent = `${game.maxJumpHeight.toFixed(2)}`;
                document.getElementById('blocks-stat').textContent = game.blocksJumpedOn;
                
                document.getElementById('controls-overlay').style.display = 'none';
                document.getElementById('touch-controls').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('end-screen').style.display = 'flex';
            }

            function showGameOverScreen() {
                const totalTime = ((Date.now() - game.startTime) / 1000).toFixed(2);
                document.getElementById('game-over-time-stat').textContent = `${totalTime}s`;
                document.getElementById('game-over-blocks-stat').textContent = game.blocksJumpedOn;
                
                document.getElementById('controls-overlay').style.display = 'none';
                document.getElementById('touch-controls').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('game-over-screen').style.display = 'flex';
            }

            // Start the game
            resetGame();
            requestAnimationFrame(gameLoop);
        };


        // --- WebGL Helper Functions ---

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            // A simple unit square (1x1)
            const positions = [
                1.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                0.0, 0.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return { position: positionBuffer };
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // --- Matrix Math Functions ---

        function createOrthographic(left, right, bottom, top, near, far) {
            const out = new Float32Array(16);
            const lr = 1 / (left - right);
            const bt = 1 / (bottom - top);
            const nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
        }

        function identity() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function translate(matrix, x, y, z) {
            const out = new Float32Array(matrix);
            out[12] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
            out[13] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
            out[14] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
            return out;
        }

        function scale(matrix, x, y, z) {
            const out = new Float32Array(matrix);
            out[0] *= x;
            out[1] *= x;
            out[2] *= x;
            out[4] *= y;
            out[5] *= y;
            out[6] *= y;
            out[8] *= z;
            out[9] *= z;
            out[10] *= z;
            return out;
        }
    </script>
</body>
</html>

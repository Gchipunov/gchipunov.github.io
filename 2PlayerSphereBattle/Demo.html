<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Split-Screen Terrain Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #split-line {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.5);
            transform: translateX(-50%);
            pointer-events: none; /* Allows clicks/touches to go through */
        }
        .controls {
            position: absolute;
            bottom: 20px;
            width: 150px;
            height: 150px;
            user-select: none;
            -webkit-user-select: none; /* For Safari */
        }
        #player1-controls {
            left: 20px;
        }
        #player2-controls {
            right: 20px;
        }
        .d-pad {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .control-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        .control-btn:active {
            background-color: rgba(255, 255, 255, 0.6);
        }
        .up { top: 0; left: 50px; }
        .down { bottom: 0; left: 50px; }
        .left { top: 50px; left: 0; }
        .right { top: 50px; right: 0; }
        .fire-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: rgba(255, 80, 80, 0.5);
            border: 2px solid rgba(255, 80, 80, 0.8);
            bottom: 40px;
        }
        #player1-fire {
            right: -90px;
        }
        #player2-fire {
            left: -90px;
        }
    </style>
</head>
<body>
    <canvas id="gl-canvas"></canvas>
    <div id="split-line"></div>

    <!-- Player 1 Controls -->
    <div id="player1-controls" class="controls">
        <div class="d-pad">
            <div class="control-btn up" data-player="1" data-action="up">▲</div>
            <div class="control-btn down" data-player="1" data-action="down">▼</div>
            <div class="control-btn left" data-player="1" data-action="left">◀</div>
            <div class="control-btn right" data-player="1" data-action="right">▶</div>
        </div>
        <div id="player1-fire" class="control-btn fire-btn" data-player="1" data-action="fire">F</div>
    </div>

    <!-- Player 2 Controls -->
    <div id="player2-controls" class="controls">
        <div class="d-pad">
            <div class="control-btn up" data-player="2" data-action="up">▲</div>
            <div class="control-btn down" data-player="2" data-action="down">▼</div>
            <div class="control-btn left" data-player="2" data-action="left">◀</div>
            <div class="control-btn right" data-player="2" data-action="right">▶</div>
        </div>
        <div id="player2-fire" class="control-btn fire-btn" data-player="2" data-action="fire">F</div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 a_position;
        attribute vec3 a_normal;

        uniform mat4 u_modelMatrix;
        uniform mat4 u_viewMatrix;
        uniform mat4 u_projectionMatrix;
        uniform mat4 u_normalMatrix;

        varying vec3 v_normal;
        varying vec3 v_worldPosition;

        void main() {
            gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * vec4(a_position, 1.0);
            v_normal = mat3(u_normalMatrix) * a_normal;
            v_worldPosition = (u_modelMatrix * vec4(a_position, 1.0)).xyz;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        uniform vec3 u_color;
        uniform vec3 u_lightDirection;
        uniform vec3 u_lightColor;
        uniform vec3 u_ambientLight;

        varying vec3 v_normal;
        varying vec3 v_worldPosition;

        void main() {
            vec3 normal = normalize(v_normal);
            float light = max(dot(normal, normalize(u_lightDirection)), 0.0);
            vec3 diffuse = light * u_lightColor;
            vec3 finalColor = u_color * (diffuse + u_ambientLight);
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // --- Main Game Logic ---
        window.onload = function() {
            const canvas = document.getElementById('gl-canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                console.error("WebGL not supported!");
                return;
            }

            // --- Shader Setup ---
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vertexShader, fragmentShader) {
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            const program = createProgram(gl, vertexShader, fragmentShader);

            const programInfo = {
                program: program,
                attribLocations: {
                    position: gl.getAttribLocation(program, 'a_position'),
                    normal: gl.getAttribLocation(program, 'a_normal'),
                },
                uniformLocations: {
                    modelMatrix: gl.getUniformLocation(program, 'u_modelMatrix'),
                    viewMatrix: gl.getUniformLocation(program, 'u_viewMatrix'),
                    projectionMatrix: gl.getUniformLocation(program, 'u_projectionMatrix'),
                    normalMatrix: gl.getUniformLocation(program, 'u_normalMatrix'),
                    color: gl.getUniformLocation(program, 'u_color'),
                    lightDirection: gl.getUniformLocation(program, 'u_lightDirection'),
                    lightColor: gl.getUniformLocation(program, 'u_lightColor'),
                    ambientLight: gl.getUniformLocation(program, 'u_ambientLight'),
                },
            };

            // --- Matrix Math Library (No external libs) ---
            const mat4 = {
                create: () => new Float32Array(16),
                identity: (out) => {
                    out.fill(0);
                    out[0] = out[5] = out[10] = out[15] = 1;
                    return out;
                },
                multiply: (out, a, b) => {
                    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                    let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    return out;
                },
                translate: (out, a, v) => {
                    let x = v[0], y = v[1], z = v[2];
                    if (a === out) {
                        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                    } else {
                        // Copy a to out and then translate
                        out.set(a);
                        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                    }
                    return out;
                },
                rotateY: (out, a, rad) => {
                    let s = Math.sin(rad);
                    let c = Math.cos(rad);
                    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    if (a !== out) {
                        out.set(a);
                    }
                    out[0] = a00 * c - a20 * s;
                    out[1] = a01 * c - a21 * s;
                    out[2] = a02 * c - a22 * s;
                    out[3] = a03 * c - a23 * s;
                    out[8] = a00 * s + a20 * c;
                    out[9] = a01 * s + a21 * c;
                    out[10] = a02 * s + a22 * c;
                    out[11] = a03 * s + a23 * c;
                    return out;
                },
                perspective: (out, fovy, aspect, near, far) => {
                    const f = 1.0 / Math.tan(fovy / 2);
                    out[0] = f / aspect;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = f;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[11] = -1;
                    out[12] = 0;
                    out[13] = 0;
                    out[15] = 0;
                    if (far != null && far !== Infinity) {
                        const nf = 1 / (near - far);
                        out[10] = (far + near) * nf;
                        out[14] = 2 * far * near * nf;
                    } else {
                        out[10] = -1;
                        out[14] = -2 * near;
                    }
                    return out;
                },
                lookAt: (out, eye, center, up) => {
                    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                    let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                    let upx = up[0], upy = up[1], upz = up[2];
                    let centerx = center[0], centery = center[1], centerz = center[2];

                    z0 = eyex - centerx;
                    z1 = eyey - centery;
                    z2 = eyez - centerz;
                    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                    z0 *= len; z1 *= len; z2 *= len;

                    x0 = upy * z2 - upz * z1;
                    x1 = upz * z0 - upx * z2;
                    x2 = upx * z1 - upy * z0;
                    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                    if (!len) { x0 = 0; x1 = 0; x2 = 0; }
                    else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }

                    y0 = z1 * x2 - z2 * x1;
                    y1 = z2 * x0 - z0 * x2;
                    y2 = z0 * x1 - z1 * x0;
                    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                    if (!len) { y0 = 0; y1 = 0; y2 = 0; }
                    else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }

                    out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                    out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                    out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                    out[14] = -(z0 * eyex + z1 * eyez + z2 * eyez);
                    out[15] = 1;

                    return out;
                },
                invert: (out, a) => {
                    // Simplified inversion, assumes affine transformation
                    let b = mat4.create();
                    mat4.transpose(b, a);
                    let c = mat4.create();
                    mat4.identity(c);
                    c[12] = -a[12];
                    c[13] = -a[13];
                    c[14] = -a[14];
                    mat4.multiply(out, b, c);
                    return out;
                },
                transpose: (out, a) => {
                    if (out === a) {
                        let a01 = a[1], a02 = a[2], a03 = a[3];
                        let a12 = a[6], a13 = a[7];
                        let a23 = a[11];
                        out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
                        out[4] = a01; out[6] = a[9]; out[7] = a[13];
                        out[8] = a02; out[9] = a12; out[11] = a[14];
                        out[12] = a03; out[13] = a13; out[14] = a23;
                    } else {
                        out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
                        out[4] = a[1]; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
                        out[8] = a[2]; out[9] = a[6]; out[10] = a[10]; out[11] = a[14];
                        out[12] = a[3]; out[13] = a[7]; out[14] = a[11]; out[15] = a[15];
                    }
                    return out;
                },
                normalFromModel: (out, modelMatrix) => {
                    mat4.invert(out, modelMatrix);
                    mat4.transpose(out, out);
                    return out;
                }
            };

            const vec3 = {
                subtract: (out, a, b) => {
                    out[0] = a[0] - b[0];
                    out[1] = a[1] - b[1];
                    out[2] = a[2] - b[2];
                    return out;
                },
                normalize: (out, a) => {
                    let x = a[0], y = a[1], z = a[2];
                    let len = x * x + y * y + z * z;
                    if (len > 0) {
                        len = 1 / Math.sqrt(len);
                    }
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                    out[2] = a[2] * len;
                    return out;
                },
                cross: (out, a, b) => {
                    let ax = a[0], ay = a[1], az = a[2];
                    let bx = b[0], by = b[1], bz = b[2];
                    out[0] = ay * bz - az * by;
                    out[1] = az * bx - ax * bz;
                    out[2] = ax * by - ay * bx;
                    return out;
                }
            };

            // --- Geometry Creation ---
            function createSphere(radius, latitudeBands, longitudeBands) {
                const positions = [];
                const normals = [];
                const indices = [];

                for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                    const theta = latNumber * Math.PI / latitudeBands;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);

                    for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                        const phi = longNumber * 2 * Math.PI / longitudeBands;
                        const sinPhi = Math.sin(phi);
                        const cosPhi = Math.cos(phi);

                        const x = cosPhi * sinTheta;
                        const y = cosTheta;
                        const z = sinPhi * sinTheta;

                        normals.push(x, y, z);
                        positions.push(radius * x, radius * y, radius * z);
                    }
                }

                for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
                    for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                        const first = (latNumber * (longitudeBands + 1)) + longNumber;
                        const second = first + longitudeBands + 1;
                        indices.push(first, second, first + 1);
                        indices.push(second, second + 1, first + 1);
                    }
                }
                return { positions, normals, indices };
            }

            // --- Terrain ---
            const terrainSize = 100;
            const terrainSegments = 50;
            let terrainData = {
                positions: [],
                normals: [],
                indices: [],
                heightMap: []
            };

            function generateTerrain() {
                const segmentSize = terrainSize / terrainSegments;
                terrainData.heightMap = new Array((terrainSegments + 1) * (terrainSegments + 1));

                for (let i = 0; i <= terrainSegments; i++) {
                    for (let j = 0; j <= terrainSegments; j++) {
                        const x = (j - terrainSegments / 2) * segmentSize;
                        const z = (i - terrainSegments / 2) * segmentSize;
                        // Simple initial height, e.g., flat
                        const y = 0;
                        terrainData.positions.push(x, y, z);
                        terrainData.heightMap[i * (terrainSegments + 1) + j] = y;
                    }
                }

                for (let i = 0; i < terrainSegments; i++) {
                    for (let j = 0; j < terrainSegments; j++) {
                        const row1 = i * (terrainSegments + 1);
                        const row2 = (i + 1) * (terrainSegments + 1);
                        terrainData.indices.push(row1 + j, row1 + j + 1, row2 + j + 1);
                        terrainData.indices.push(row1 + j, row2 + j + 1, row2 + j);
                    }
                }
                calculateTerrainNormals();
            }

            function calculateTerrainNormals() {
                terrainData.normals = new Array(terrainData.positions.length).fill(0);
                for (let i = 0; i < terrainSegments; i++) {
                    for (let j = 0; j < terrainSegments; j++) {
                        const i1 = i * (terrainSegments + 1) + j;
                        const i2 = i * (terrainSegments + 1) + j + 1;
                        const i3 = (i + 1) * (terrainSegments + 1) + j + 1;
                        const i4 = (i + 1) * (terrainSegments + 1) + j;

                        const v1 = [terrainData.positions[i1*3], terrainData.positions[i1*3+1], terrainData.positions[i1*3+2]];
                        const v2 = [terrainData.positions[i2*3], terrainData.positions[i2*3+1], terrainData.positions[i2*3+2]];
                        const v3 = [terrainData.positions[i3*3], terrainData.positions[i3*3+1], terrainData.positions[i3*3+2]];
                        const v4 = [terrainData.positions[i4*3], terrainData.positions[i4*3+1], terrainData.positions[i4*3+2]];

                        const n1 = [], n2 = [];
                        const e1 = vec3.subtract([], v2, v1);
                        const e2 = vec3.subtract([], v3, v1);
                        vec3.cross(n1, e1, e2);

                        const e3 = vec3.subtract([], v3, v1);
                        const e4 = vec3.subtract([], v4, v1);
                        vec3.cross(n2, e3, e4);

                        // Add normals to vertices
                        [i1, i2, i3, i4].forEach(index => {
                            terrainData.normals[index*3] += n1[0] + n2[0];
                            terrainData.normals[index*3+1] += n1[1] + n2[1];
                            terrainData.normals[index*3+2] += n1[2] + n2[2];
                        });
                    }
                }
                // Normalize all normals
                for (let i = 0; i < terrainData.normals.length; i+=3) {
                    const n = vec3.normalize([], [terrainData.normals[i], terrainData.normals[i+1], terrainData.normals[i+2]]);
                    terrainData.normals[i] = n[0];
                    terrainData.normals[i+1] = n[1];
                    terrainData.normals[i+2] = n[2];
                }
            }
            
            function deformTerrain(cx, cz, radius, depth) {
                const segmentSize = terrainSize / terrainSegments;
                for (let i = 0; i <= terrainSegments; i++) {
                    for (let j = 0; j <= terrainSegments; j++) {
                        const x = (j - terrainSegments / 2) * segmentSize;
                        const z = (i - terrainSegments / 2) * segmentSize;
                        const dx = x - cx;
                        const dz = z - cz;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        if (dist < radius) {
                            const deformation = depth * (1 - dist / radius);
                            const index = (i * (terrainSegments + 1) + j);
                            terrainData.positions[index * 3 + 1] -= deformation;
                            terrainData.heightMap[index] = terrainData.positions[index * 3 + 1];
                        }
                    }
                }
                calculateTerrainNormals();
                // Update VBO
                gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffers.position);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(terrainData.positions));
                gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffers.normal);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(terrainData.normals));
            }
            
            function getTerrainHeight(x, z) {
                const segmentSize = terrainSize / terrainSegments;
                const gridX = Math.floor(x / segmentSize + terrainSegments / 2);
                const gridZ = Math.floor(z / segmentSize + terrainSegments / 2);

                if (gridX < 0 || gridX >= terrainSegments || gridZ < 0 || gridZ >= terrainSegments) {
                    return 0; // Outside terrain
                }
                
                const index = gridZ * (terrainSegments + 1) + gridX;
                return terrainData.heightMap[index] || 0;
            }


            generateTerrain();
            const sphereGeometry = createSphere(1, 16, 16);
            const grenadeGeometry = createSphere(0.3, 8, 8);


            // --- Buffer Setup ---
            function createBuffers(geometry) {
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.positions), gl.STATIC_DRAW);

                const normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometry.normals), gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geometry.indices), gl.STATIC_DRAW);

                return {
                    position: positionBuffer,
                    normal: normalBuffer,
                    indices: indexBuffer,
                    count: geometry.indices.length,
                };
            }
            
            const terrainBuffers = {
                position: gl.createBuffer(),
                normal: gl.createBuffer(),
                indices: gl.createBuffer(),
                count: terrainData.indices.length,
            };
            gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainData.positions), gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffers.normal);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainData.normals), gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, terrainBuffers.indices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(terrainData.indices), gl.STATIC_DRAW);


            const sphereBuffers = createBuffers(sphereGeometry);
            const grenadeBuffers = createBuffers(grenadeGeometry);

            // --- Game State ---
            const players = [
                { pos: [-10, 5, 0], angle: 0, color: [0.2, 0.5, 1.0], speed: 0.2, turnSpeed: 0.03 },
                { pos: [10, 5, 0], angle: Math.PI, color: [1.0, 0.5, 0.2], speed: 0.2, turnSpeed: 0.03 }
            ];
            const grenades = [];
            const inputState = {
                1: { up: false, down: false, left: false, right: false, fire: false },
                2: { up: false, down: false, left: false, right: false, fire: false }
            };

            // --- Input Handling ---
            function handleInput(event, isDown) {
                const keyMap = {
                    'w': { player: 1, action: 'up' }, 's': { player: 1, action: 'down' },
                    'a': { player: 1, action: 'left' }, 'd': { player: 1, action: 'right' },
                    ' ': { player: 1, action: 'fire' },
                    'ArrowUp': { player: 2, action: 'up' }, 'ArrowDown': { player: 2, action: 'down' },
                    'ArrowLeft': { player: 2, action: 'left' }, 'ArrowRight': { player: 2, action: 'right' },
                    'Enter': { player: 2, action: 'fire' },
                };
                const mapping = keyMap[event.key];
                if (mapping) {
                    event.preventDefault();
                    if (inputState[mapping.player][mapping.action] !== isDown) {
                         inputState[mapping.player][mapping.action] = isDown;
                    }
                }
            }
            
            function handleTouch(event, isDown) {
                event.preventDefault();
                for (const touch of event.changedTouches) {
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && element.classList.contains('control-btn')) {
                        const player = element.dataset.player;
                        const action = element.dataset.action;
                        if (player && action) {
                             if (inputState[player][action] !== isDown) {
                                inputState[player][action] = isDown;
                            }
                        }
                    }
                }
            }

            document.addEventListener('keydown', e => handleInput(e, true));
            document.addEventListener('keyup', e => handleInput(e, false));
            document.addEventListener('touchstart', e => handleTouch(e, true));
            document.addEventListener('touchend', e => handleTouch(e, false));
            document.addEventListener('touchcancel', e => handleTouch(e, false));

            // --- Game Loop ---
            let lastTime = 0;
            function gameLoop(time) {
                time *= 0.001; // convert to seconds
                const deltaTime = time - lastTime;
                lastTime = time;

                update(deltaTime);
                draw();

                requestAnimationFrame(gameLoop);
            }

            function update(deltaTime) {
                // Update players
                players.forEach((player, index) => {
                    const input = inputState[index + 1];
                    if (input.left) player.angle += player.turnSpeed;
                    if (input.right) player.angle -= player.turnSpeed;

                    if (input.up) {
                        player.pos[0] += Math.sin(player.angle) * player.speed;
                        player.pos[2] += Math.cos(player.angle) * player.speed;
                    }
                    if (input.down) {
                        player.pos[0] -= Math.sin(player.angle) * player.speed;
                        player.pos[2] -= Math.cos(player.angle) * player.speed;
                    }
                    
                    // Clamp to terrain
                    const terrainHeight = getTerrainHeight(player.pos[0], player.pos[2]);
                    player.pos[1] = terrainHeight + 1.0; // 1.0 is player radius

                    // Fire grenade
                    if (input.fire) {
                        grenades.push({
                            pos: [...player.pos],
                            vel: [Math.sin(player.angle) * 5, 5, Math.cos(player.angle) * 5],
                            life: 3, // 3 seconds
                        });
                        input.fire = false; // Prevent continuous fire
                    }
                });

                // Update grenades
                for (let i = grenades.length - 1; i >= 0; i--) {
                    const grenade = grenades[i];
                    grenade.life -= deltaTime;
                    
                    // Physics
                    grenade.vel[1] -= 9.8 * deltaTime; // Gravity
                    grenade.pos[0] += grenade.vel[0] * deltaTime;
                    grenade.pos[1] += grenade.vel[1] * deltaTime;
                    grenade.pos[2] += grenade.vel[2] * deltaTime;

                    const terrainHeight = getTerrainHeight(grenade.pos[0], grenade.pos[2]);

                    // Explode on timer or impact
                    if (grenade.life <= 0 || grenade.pos[1] < terrainHeight) {
                        deformTerrain(grenade.pos[0], grenade.pos[2], 8, 3);
                        grenades.splice(i, 1);
                    }
                }
            }

            function draw() {
                // Resize canvas to display size
                const width = gl.canvas.clientWidth;
                const height = gl.canvas.clientHeight;
                if (gl.canvas.width !== width || gl.canvas.height !== height) {
                    gl.canvas.width = width;
                    gl.canvas.height = height;
                }
                
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
                gl.clearColor(0.5, 0.7, 0.9, 1.0); // Sky color
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                gl.useProgram(programInfo.program);
                
                // --- Global uniforms (lighting) ---
                gl.uniform3fv(programInfo.uniformLocations.lightDirection, vec3.normalize([], [0.5, -1, -0.5]));
                gl.uniform3fv(programInfo.uniformLocations.lightColor, [1.0, 1.0, 1.0]);
                gl.uniform3fv(programInfo.uniformLocations.ambientLight, [0.3, 0.3, 0.3]);

                // --- Render for each player ---
                for (let i = 0; i < 2; i++) {
                    const player = players[i];
                    const viewportX = i * width / 2;
                    gl.viewport(viewportX, 0, width / 2, height);
                    
                    // --- Camera Setup ---
                    const projectionMatrix = mat4.create();
                    mat4.perspective(projectionMatrix, 45 * Math.PI / 180, (width / 2) / height, 0.1, 200.0);

                    const viewMatrix = mat4.create();
                    const cameraPos = [
                        player.pos[0] - Math.sin(player.angle) * 10,
                        player.pos[1] + 5,
                        player.pos[2] - Math.cos(player.angle) * 10
                    ];
                    mat4.lookAt(viewMatrix, cameraPos, player.pos, [0, 1, 0]);

                    gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
                    gl.uniformMatrix4fv(programInfo.uniformLocations.viewMatrix, false, viewMatrix);

                    // --- Draw Scene Objects ---
                    drawObject(terrainBuffers, [0, 0, 0], 0, [0.4, 0.7, 0.2]); // Terrain
                    players.forEach(p => {
                        drawObject(sphereBuffers, p.pos, 0, p.color);
                    });
                    grenades.forEach(g => {
                        drawObject(grenadeBuffers, g.pos, 0, [0.2, 0.2, 0.2]);
                    });
                }
            }

            function drawObject(buffers, position, angleY, color) {
                // Model Matrix
                const modelMatrix = mat4.create();
                mat4.identity(modelMatrix);
                mat4.translate(modelMatrix, modelMatrix, position);
                mat4.rotateY(modelMatrix, modelMatrix, angleY);
                gl.uniformMatrix4fv(programInfo.uniformLocations.modelMatrix, false, modelMatrix);

                // Normal Matrix
                const normalMatrix = mat4.create();
                mat4.normalFromModel(normalMatrix, modelMatrix);
                gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);

                // Color
                gl.uniform3fv(programInfo.uniformLocations.color, color);

                // Bind buffers and draw
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(programInfo.attribLocations.position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.position);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                gl.vertexAttribPointer(programInfo.attribLocations.normal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.normal);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
                gl.drawElements(gl.TRIANGLES, buffers.count, gl.UNSIGNED_SHORT, 0);
            }

            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenGL ES 2.0 Texture Instancing</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            border: 2px solid #555;
            background-color: #222;
        }
    </style>
</head>
<body>
    <canvas id="gl-canvas" width="800" height="600"></canvas>
    
    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        precision mediump float;

        // Position attribute for the quad
        attribute vec2 aPosition;

        // Per-instance attributes for the model matrix
        attribute vec4 aModelMatrixCol0;
        attribute vec4 aModelMatrixCol1;
        attribute vec4 aModelMatrixCol2;
        attribute vec4 aModelMatrixCol3;

        // Per-instance attributes for texture coordinates from the atlas
        attribute vec2 aTextureCoord;

        // Varying to pass texture coordinates to the fragment shader
        varying vec2 vTextureCoord;

        void main() {
            // Reconstruct the model matrix from the four attributes
            mat4 model = mat4(
                aModelMatrixCol0,
                aModelMatrixCol1,
                aModelMatrixCol2,
                aModelMatrixCol3
            );

            // Calculate the final position
            gl_Position = model * vec4(aPosition, 0.0, 1.0);
            
            // Pass the per-instance texture coordinates to the fragment shader
            vTextureCoord = aTextureCoord;
        }
    </script>
    
    <!-- Fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        // The texture atlas sampler
        uniform sampler2D uSampler;

        // The texture coordinates from the vertex shader
        varying vec2 vTextureCoord;

        void main() {
            // Sample the texture atlas using the per-instance coordinates
            gl_FragColor = texture2D(uSampler, vTextureCoord);
        }
    </script>
    
    <script>
        const canvas = document.getElementById('gl-canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            console.error("WebGL not supported. Please use a different browser.");
        }

        let program, vao, vbo, ebo;
        let modelMatrixes = [];
        let textureCoords = [];
        let modelMatrixVBOs = [];
        let textureCoordVBO;
        let positions = [];
        let indices = [];

        // --- Utility Functions ---

        // Function to create and compile a shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Function to create a shader program
        function createProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            if (!vertexShader || !fragmentShader) return null;

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Function to create a texture from an image and set it up.
        function createTexture(gl, image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Set texture parameters for non-power-of-two images
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            // Flip the image's Y axis
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            return texture;
        }

        // Creates a texture atlas from a list of images.
        async function createTextureAtlas(images) {
            const atlasCanvas = document.createElement('canvas');
            const atlasCtx = atlasCanvas.getContext('2d');
            let totalWidth = 0;
            const maxHeight = images.reduce((max, img) => Math.max(max, img.height), 0);

            // Calculate total width and set canvas dimensions
            images.forEach(img => totalWidth += img.width);
            atlasCanvas.width = totalWidth;
            atlasCanvas.height = maxHeight;

            let xOffset = 0;
            const textureData = [];
            // Draw each image onto the atlas and store its UV coordinates
            for (const img of images) {
                atlasCtx.drawImage(img, xOffset, 0);
                const u0 = xOffset / totalWidth;
                const v0 = 0;
                const u1 = (xOffset + img.width) / totalWidth;
                const v1 = img.height / maxHeight;
                textureData.push({ u0, v0, u1, v1 });
                xOffset += img.width;
            }
            
            return {
                texture: createTexture(gl, atlasCanvas),
                coords: textureData
            };
        }

        // Load images asynchronously
        function loadImage(src, width, height, color) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, width, height);
                resolve(canvas);
            });
        }

        // --- Initialization ---

        async function init() {
            // Load shader sources
            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;

            program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
            gl.useProgram(program);

            // Create a quad
            const quadWidth = 0.4, quadHeight = 0.4;
            positions = [
                // X, Y
                -quadWidth / 2, -quadHeight / 2, // bottom-left
                 quadWidth / 2, -quadHeight / 2, // bottom-right
                 quadWidth / 2,  quadHeight / 2, // top-right
                -quadWidth / 2,  quadHeight / 2  // top-left
            ];
            indices = [0, 1, 2, 0, 2, 3];

            // Create and bind VAO (WebGL 1 doesn't have it, so we simulate it)
            vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            ebo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            // Set up position attribute
            const positionAttribLocation = gl.getAttribLocation(program, 'aPosition');
            gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 2 * 4, 0);
            gl.enableVertexAttribArray(positionAttribLocation);

            // Load images and create texture atlas
            const imageSize = 64;
            const images = [
                await loadImage(null, imageSize, imageSize, 'red'),
                await loadImage(null, imageSize, imageSize, 'green'),
                await loadImage(null, imageSize, imageSize, 'blue')
            ];
            const atlas = await createTextureAtlas(images);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, atlas.texture);
            gl.uniform1i(gl.getUniformLocation(program, 'uSampler'), 0);

            // Create per-instance data
            const numInstances = 3;
            const xPositions = [-0.6, 0.0, 0.6];
            
            const modelCol0 = [], modelCol1 = [], modelCol2 = [], modelCol3 = [];
            const instanceTexCoords = [];

            for (let i = 0; i < numInstances; ++i) {
                // Create the model matrix
                const model = new Float32Array(16);
                glMatrix.mat4.identity(model);
                glMatrix.mat4.translate(model, model, [xPositions[i], 0.0, 0.0]);

                // Duplicate the matrix columns for each vertex (Heavy Tanker)
                for (let j = 0; j < 4; ++j) {
                    modelCol0.push(model[0], model[1], model[2], model[3]);
                    modelCol1.push(model[4], model[5], model[6], model[7]);
                    modelCol2.push(model[8], model[9], model[10], model[11]);
                    modelCol3.push(model[12], model[13], model[14], model[15]);
                }

                // Get texture coordinates for this instance from the atlas
                const coords = atlas.coords[i];
                // Duplicate the per-instance texture coordinates for each vertex (Heavy Tanker)
                instanceTexCoords.push(
                    coords.u0, coords.v0, // bottom-left
                    coords.u1, coords.v0, // bottom-right
                    coords.u1, coords.v1, // top-right
                    coords.u0, coords.v1  // top-left
                );
            }

            // Create and fill VBOs for the per-instance attributes
            modelMatrixVBOs[0] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, modelMatrixVBOs[0]);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(modelCol0), gl.STATIC_DRAW);
            const matrixAttrib0 = gl.getAttribLocation(program, 'aModelMatrixCol0');
            gl.vertexAttribPointer(matrixAttrib0, 4, gl.FLOAT, false, 4 * 4, 0);
            gl.enableVertexAttribArray(matrixAttrib0);

            modelMatrixVBOs[1] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, modelMatrixVBOs[1]);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(modelCol1), gl.STATIC_DRAW);
            const matrixAttrib1 = gl.getAttribLocation(program, 'aModelMatrixCol1');
            gl.vertexAttribPointer(matrixAttrib1, 4, gl.FLOAT, false, 4 * 4, 0);
            gl.enableVertexAttribArray(matrixAttrib1);

            modelMatrixVBOs[2] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, modelMatrixVBOs[2]);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(modelCol2), gl.STATIC_DRAW);
            const matrixAttrib2 = gl.getAttribLocation(program, 'aModelMatrixCol2');
            gl.vertexAttribPointer(matrixAttrib2, 4, gl.FLOAT, false, 4 * 4, 0);
            gl.enableVertexAttribArray(matrixAttrib2);

            modelMatrixVBOs[3] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, modelMatrixVBOs[3]);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(modelCol3), gl.STATIC_DRAW);
            const matrixAttrib3 = gl.getAttribLocation(program, 'aModelMatrixCol3');
            gl.vertexAttribPointer(matrixAttrib3, 4, gl.FLOAT, false, 4 * 4, 0);
            gl.enableVertexAttribArray(matrixAttrib3);

            // Create and fill VBO for texture coordinates
            textureCoordVBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordVBO);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(instanceTexCoords), gl.STATIC_DRAW);
            const texCoordAttrib = gl.getAttribLocation(program, 'aTextureCoord');
            gl.vertexAttribPointer(texCoordAttrib, 2, gl.FLOAT, false, 2 * 4, 0);
            gl.enableVertexAttribArray(texCoordAttrib);

            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            // Render loop
            function render() {
                gl.clearColor(0.2, 0.2, 0.2, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Draw the single quad with the duplicated instance data
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
                
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        // Include GL-Matrix library for matrix operations
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js';
        script.onload = init;
        document.head.appendChild(script);
    </script>
</body>
</html>

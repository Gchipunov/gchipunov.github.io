<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Platformer: Wall Jump & Scroll</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h1>WebGL Platformer</h1>
        <p>Arrows/WASD to Move & Jump</p>
        <p>Jump against a wall to Wall Jump. Press into a wall to Wall Slide.</p>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * ------------------------------------------------------------------
 * SECTION 1: WEBGL BOILERPLATE & SHADERS
 * ------------------------------------------------------------------
 */
const canvas = document.getElementById('gameCanvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    alert("WebGL not supported");
}

// Vertex Shader: Handles position, scaling (size), camera translation
const vsSource = `
    attribute vec2 a_position;
    
    uniform vec2 u_resolution;
    uniform vec2 u_translation; // Camera position
    uniform vec2 u_objPos;      // Object position world space
    uniform vec2 u_objScale;    // Object size
    
    void main() {
        // Scale the unit quad to object size and move to position
        vec2 position = (a_position * u_objScale) + u_objPos;
        
        // Apply camera translation
        position = position - u_translation;
        
        // Convert from pixels to 0.0->1.0
        vec2 zeroToOne = position / u_resolution;
        
        // Convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;
        
        // Convert from 0->2 to -1->+1 (clip space)
        vec2 clipSpace = zeroToTwo - 1.0;
        
        // Flip Y axis because WebGL 0,0 is bottom-left, but we want top-left
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;

// Fragment Shader: Handles color
const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    
    void main() {
        gl_FragColor = u_color;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
}

// Look up locations
const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");
const translationLocation = gl.getUniformLocation(program, "u_translation");
const objPosLocation = gl.getUniformLocation(program, "u_objPos");
const objScaleLocation = gl.getUniformLocation(program, "u_objScale");

// Create a buffer for a unit rectangle
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,
]), gl.STATIC_DRAW);

/**
 * ------------------------------------------------------------------
 * SECTION 2: GAME ENGINE & PHYSICS
 * ------------------------------------------------------------------
 */

// Input Handling
const keys = {};
window.addEventListener('keydown', (e) => keys[e.code] = true);
window.addEventListener('keyup', (e) => keys[e.code] = false);

// Game Constants
const GRAVITY = 0.6;
const FRICTION = 0.8;
const MOVE_SPEED = 0.8;
const JUMP_FORCE = -14;
const WALL_SLIDE_SPEED = 2;
const WALL_JUMP_FORCE_X = 10;
const WALL_JUMP_FORCE_Y = -12;
const MAX_SPEED = 10;

// Camera
let camera = { x: 0, y: 0 };

// Player Object
const player = {
    x: 100,
    y: 300,
    w: 30, // Width
    h: 50, // Height
    vx: 0,
    vy: 0,
    color: [0.2, 0.8, 0.2, 1], // Green
    isGrounded: false,
    isWallSliding: false,
    wallDir: 0 // -1 left, 1 right
};

// Level Data (Walls/Platforms)
const platforms = [
    { x: 0, y: 500, w: 2000, h: 50, color: [0.5, 0.5, 0.5, 1] }, // Floor
    { x: 400, y: 350, w: 100, h: 150, color: [0.7, 0.3, 0.3, 1] }, // Block
    { x: 700, y: 200, w: 50, h: 300, color: [0.7, 0.3, 0.3, 1] }, // Tall Wall for climbing
    { x: 900, y: 400, w: 200, h: 20, color: [0.3, 0.3, 0.8, 1] }, // Platform
    { x: 1200, y: 300, w: 50, h: 200, color: [0.7, 0.3, 0.3, 1] }, // Another wall
    { x: -50, y: 0, w: 50, h: 1000, color: [0.5, 0.5, 0.5, 1] }  // Left boundary
];

// Generate more procedural platforms for scrolling demo
for(let i = 0; i < 20; i++) {
    platforms.push({
        x: 1500 + (i * 300),
        y: 200 + Math.random() * 200,
        w: 100 + Math.random() * 100,
        h: 30,
        color: [0.4, 0.4, 0.4, 1]
    });
    // Occasional walls
    if (i % 3 === 0) {
        platforms.push({
            x: 1500 + (i * 300) + 200,
            y: 100,
            w: 40,
            h: 300,
            color: [0.6, 0.2, 0.2, 1]
        });
    }
}

// AABB Collision Detection
function checkCollision(rect1, rect2) {
    return (rect1.x < rect2.x + rect2.w &&
            rect1.x + rect1.w > rect2.x &&
            rect1.y < rect2.y + rect2.h &&
            rect1.y + rect1.h > rect2.y);
}

function updatePhysics() {
    // 1. Apply Forces
    if (keys['ArrowRight'] || keys['KeyD']) player.vx += MOVE_SPEED;
    if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= MOVE_SPEED;

    player.vx *= FRICTION;
    player.vy += GRAVITY;

    // Cap velocity
    if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
    if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

    // 2. X Movement & Collision
    player.x += player.vx;
    player.wallDir = 0; // Reset wall contact

    for (let p of platforms) {
        if (checkCollision(player, p)) {
            // Collision occurred on X axis
            if (player.vx > 0) {
                player.x = p.x - player.w;
                player.wallDir = 1; // Wall on right
            } else if (player.vx < 0) {
                player.x = p.x + p.w;
                player.wallDir = -1; // Wall on left
            }
            player.vx = 0;
        }
    }

    // 3. Wall Sliding Logic
    // We are wall sliding if: Not on ground, touching a wall, and falling (vy > 0)
    // Optional: Only slide if pressing TOWARDS the wall
    let inputDir = (keys['ArrowRight'] || keys['KeyD']) ? 1 : (keys['ArrowLeft'] || keys['KeyA']) ? -1 : 0;
    
    player.isWallSliding = false;
    if (!player.isGrounded && player.wallDir !== 0 && player.vy > 0) {
        // Only slide if pressing into wall or just generically sticky (sticking feels better)
        player.isWallSliding = true;
        if (player.vy > WALL_SLIDE_SPEED) {
            player.vy = WALL_SLIDE_SPEED;
        }
    }

    // 4. Y Movement & Collision
    player.y += player.vy;
    player.isGrounded = false;

    for (let p of platforms) {
        if (checkCollision(player, p)) {
            // Collision on Y axis
            if (player.vy > 0) { // Falling
                player.y = p.y - player.h;
                player.isGrounded = true;
                player.isWallSliding = false; // Can't slide if on ground
            } else if (player.vy < 0) { // Jumping up
                player.y = p.y + p.h;
            }
            player.vy = 0;
        }
    }

    // 5. Jump Handling
    if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
        if (!keys.jumpPressed) { // Just pressed
            if (player.isGrounded) {
                // Normal Jump
                player.vy = JUMP_FORCE;
            } else if (player.isWallSliding || player.wallDir !== 0) {
                // Wall Jump
                player.vy = WALL_JUMP_FORCE_Y;
                // Kick off the wall
                player.vx = -player.wallDir * WALL_JUMP_FORCE_X;
            }
            keys.jumpPressed = true;
        }
    } else {
        keys.jumpPressed = false;
    }

    // 6. Camera Follow
    // Simple lerp for smooth camera, or hard lock
    let targetCamX = player.x - (gl.canvas.width / 2) + (player.w / 2);
    let targetCamY = player.y - (gl.canvas.height / 2);
    
    // Clamp camera Y so we don't see too much below floor
    if(targetCamY > 100) targetCamY = 100; 

    // Smooth camera
    camera.x += (targetCamX - camera.x) * 0.1;
    camera.y += (targetCamY - camera.y) * 0.1;
}

/**
 * ------------------------------------------------------------------
 * SECTION 3: RENDERING
 * ------------------------------------------------------------------
 */

function drawRect(x, y, w, h, color) {
    gl.uniform4fv(colorLocation, color);
    gl.uniform2f(objPosLocation, x, y);
    gl.uniform2f(objScaleLocation, w, h);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function render() {
    // Resize canvas to display size
    const displayWidth = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }

    gl.clearColor(0.13, 0.13, 0.13, 1.0); // Background color
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);

    // Update Global Uniforms
    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
    gl.uniform2f(translationLocation, camera.x, camera.y);

    gl.enableVertexAttribArray(positionLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    // Draw Platforms
    for (let p of platforms) {
        drawRect(p.x, p.y, p.w, p.h, p.color);
    }

    // Draw Player
    // Change color if wall sliding to give visual feedback
    let pColor = player.isWallSliding ? [0.8, 0.8, 0.2, 1] : player.color;
    drawRect(player.x, player.y, player.w, player.h, pColor);

    requestAnimationFrame(gameLoop);
}

function gameLoop() {
    updatePhysics();
    render();
}

// Start
requestAnimationFrame(gameLoop);

</script>
</body>
</html>

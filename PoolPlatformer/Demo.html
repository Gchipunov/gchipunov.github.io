<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Swimming Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #202020; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 20px; }
        p { margin: 5px 0; font-size: 14px; color: #ccc; }
        .key { color: #4ff; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>WebGL Platformer</h1>
        <p>Move: <span class="key">Arrow Keys</span> or <span class="key">WASD</span></p>
        <p>Jump/Swim Up: <span class="key">Space</span> or <span class="key">Up</span></p>
        <p>Status: <span id="status">On Land</span></p>
    </div>
    <canvas id="glcanvas"></canvas>

<script>
/** * SHADERS 
 * Simple 2D shader that converts pixel coordinates to Clip Space (-1 to +1)
 */
const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;

    void main() {
        // Convert the position from pixels to 0.0 to 1.0
        vec2 zeroToOne = a_position / u_resolution;
        // Convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;
        // Convert from 0->2 to -1->+1 (clip space)
        vec2 clipSpace = zeroToTwo - 1.0;

        // Flip Y axis so 0 is at top
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

// --- WEBGL SETUP BOILERPLATE ---
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
const statusEl = document.getElementById("status");

if (!gl) { alert("WebGL not supported"); }

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

// Look up locations
const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");

// Create a buffer for positions
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// --- RENDERING HELPER ---
function drawRect(x, y, width, height, color) {
    // Set color
    gl.uniform4f(colorLocation, color[0], color[1], color[2], color[3]);
    
    // Create two triangles defining the rectangle
    const x1 = x;
    const x2 = x + width;
    const y1 = y;
    const y2 = y + height;
    
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        x1, y1,
        x2, y1,
        x1, y2,
        x1, y2,
        x2, y1,
        x2, y2,
    ]), gl.STATIC_DRAW);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

// --- GAME LOGIC ---

// Inputs
const keys = {};
window.addEventListener("keydown", (e) => keys[e.code] = true);
window.addEventListener("keyup", (e) => keys[e.code] = false);

// Game Objects
const player = {
    x: 100,
    y: 100,
    w: 30,
    h: 30,
    vx: 0,
    vy: 0,
    speed: 5,
    jump: 12,
    color: [1.0, 0.3, 0.3, 1.0], // Red
    inWater: false
};

// Physics Constants
const GRAVITY = 0.6;
const FRICTION = 0.8; 
// Water physics
const WATER_GRAVITY = 0.1; // Buoyancy counteracts gravity
const WATER_DRAG = 0.9;    // High resistance
const WATER_SPEED = 3;

// Level Data
// Format: {x, y, w, h, type}
const platforms = [
    {x: 0, y: 500, w: 800, h: 50, type: 'solid'},   // Ground Left
    {x: 300, y: 350, w: 200, h: 20, type: 'solid'}, // Floating Plat
    {x: 600, y: 200, w: 200, h: 20, type: 'solid'}, // High Plat
    {x: 950, y: 500, w: 500, h: 50, type: 'solid'}, // Ground Right
    {x: 800, y: 600, w: 150, h: 50, type: 'solid'}, // Pool floor
    {x: 800, y: 500, w: 10, h: 100, type: 'solid'}, // Pool Left Wall
    {x: 940, y: 500, w: 10, h: 100, type: 'solid'}, // Pool Right Wall
];

const waterZones = [
    {x: 810, y: 510, w: 130, h: 80, color: [0.0, 0.5, 1.0, 0.5]} // The Pool
];

// Collision Detection (AABB)
function rectIntersect(r1, r2) {
    return (r1.x < r2.x + r2.w &&
            r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h &&
            r1.y + r1.h > r2.y);
}

function update() {
    // 1. Check if inside water
    let wasInWater = player.inWater;
    player.inWater = false;
    for(let w of waterZones) {
        if(rectIntersect(player, w)) {
            player.inWater = true;
            break;
        }
    }
    
    // UI Update
    if(player.inWater !== wasInWater) {
        statusEl.innerText = player.inWater ? "Swimming üèä" : "On Land üèÉ";
    }

    // 2. Apply Forces based on State
    if (player.inWater) {
        // --- SWIMMING PHYSICS ---
        // Movement is omni-directional but slower
        if (keys['ArrowRight'] || keys['KeyD']) player.vx += 0.5;
        if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= 0.5;
        
        // Buoyancy/Swimming Up
        if (keys['ArrowUp'] || keys['KeyW'] || keys['Space']) player.vy -= 0.8;
        if (keys['ArrowDown'] || keys['KeyS']) player.vy += 0.5;

        // Apply Water Physics
        player.vy += WATER_GRAVITY; // Very low gravity (sinking slowly)
        player.vx *= WATER_DRAG;    // High friction
        player.vy *= WATER_DRAG;
    } else {
        // --- LAND PHYSICS ---
        if (keys['ArrowRight'] || keys['KeyD']) {
            if (player.vx < player.speed) player.vx++;
        }
        if (keys['ArrowLeft'] || keys['KeyA']) {
            if (player.vx > -player.speed) player.vx--;
        }

        // Apply Land Physics
        player.vy += GRAVITY;
        player.vx *= FRICTION;
    }

    // 3. Move X & Resolve Collisions
    player.x += player.vx;
    for (let p of platforms) {
        if (rectIntersect(player, p)) {
            // Determine side of collision
            if (player.vx > 0) { // Moving Right
                player.x = p.x - player.w;
            } else if (player.vx < 0) { // Moving Left
                player.x = p.x + p.w;
            }
            player.vx = 0;
        }
    }

    // 4. Move Y & Resolve Collisions
    player.y += player.vy;
    let grounded = false;
    for (let p of platforms) {
        if (rectIntersect(player, p)) {
            if (player.vy > 0) { // Falling
                player.y = p.y - player.h;
                grounded = true;
            } else if (player.vy < 0) { // Jumping up
                player.y = p.y + p.h;
            }
            player.vy = 0;
        }
    }

    // 5. Land Jumping
    if (!player.inWater && grounded && (keys['ArrowUp'] || keys['Space'] || keys['KeyW'])) {
        player.vy = -player.jump;
    }
    
    // Screen boundaries
    if (player.y > canvas.height + 100) { // Reset if fallen
        player.x = 100;
        player.y = 100;
        player.vx = 0;
        player.vy = 0;
    }
}

function render() {
    // Resize canvas to full screen
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // Clear Screen
    gl.clearColor(0.12, 0.12, 0.12, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Enable transparency for water
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.useProgram(program);
    gl.enableVertexAttribArray(positionLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

    // Pass resolution to shader
    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

    // 1. Draw Level
    platforms.forEach(p => {
        drawRect(p.x, p.y, p.w, p.h, [0.4, 0.8, 0.4, 1.0]); // Green platforms
    });

    // 2. Draw Player
    drawRect(player.x, player.y, player.w, player.h, player.color);

    // 3. Draw Water (Draw last for transparency)
    waterZones.forEach(w => {
        drawRect(w.x, w.y, w.w, w.h, w.color);
    });

    // Simple Camera Follow (Shift everything left based on player pos)
    // *Note: In a complex engine, we would use a View Matrix in the shader.
    // Here, for simplicity, we just keep the player drawing relative to screen.*
}

function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

// Start
gameLoop();

</script>
</body>
</html>

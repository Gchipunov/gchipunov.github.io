<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Swimming Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background: #202020; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 20px; }
        p { margin: 5px 0; font-size: 14px; color: #ccc; }
        .key { color: #4ff; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>WebGL Platformer</h1>
        <p>Move: <span class="key">WASD / Arrows</span></p>
        <p>Jump: <span class="key">Space</span></p>
        <p>Status: <span id="status">On Land</span></p>
    </div>
    <canvas id="glcanvas"></canvas>

<script>
const vsSource = `
    attribute vec2 a_position;
    uniform vec2 u_resolution;
    uniform vec2 u_camera;

    void main() {
        // Apply camera offset
        vec2 pos = a_position - u_camera;
        // Convert the position from pixels to 0.0 to 1.0
        vec2 zeroToOne = pos / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        // Flip Y axis
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

// --- SETUP ---
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
const statusEl = document.getElementById("status");

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const cameraLocation = gl.getUniformLocation(program, "u_camera");
const colorLocation = gl.getUniformLocation(program, "u_color");

const positionBuffer = gl.createBuffer();

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// --- GAME OBJECTS ---
const keys = {};
window.addEventListener("keydown", (e) => keys[e.code] = true);
window.addEventListener("keyup", (e) => keys[e.code] = false);

const player = {
    x: 100, y: 100, w: 30, h: 30,
    vx: 0, vy: 0,
    speed: 6, jump: 14,
    color: [1.0, 0.3, 0.3, 1.0],
    inWater: false
};

const camera = { x: 0, y: 0 };

const platforms = [
    {x: 0, y: 500, w: 800, h: 50},
    {x: 300, y: 350, w: 200, h: 20},
    {x: 600, y: 200, w: 200, h: 20},
    {x: 950, y: 500, w: 800, h: 50},
    {x: 800, y: 650, w: 150, h: 50},
    {x: 800, y: 500, w: 10, h: 150},
    {x: 940, y: 500, w: 10, h: 150},
];

const waterZones = [
    {x: 810, y: 510, w: 130, h: 140, color: [0.0, 0.6, 1.0, 0.5]}
];

// --- LOGIC ---
function rectIntersect(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

function update() {
    player.inWater = waterZones.some(w => rectIntersect(player, w));
    statusEl.innerText = player.inWater ? "Swimming ðŸŠ" : "On Land ðŸƒ";

    if (player.inWater) {
        if (keys['ArrowRight'] || keys['KeyD']) player.vx += 0.5;
        if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= 0.5;
        if (keys['ArrowUp'] || keys['KeyW'] || keys['Space']) player.vy -= 0.7;
        if (keys['ArrowDown'] || keys['KeyS']) player.vy += 0.5;
        player.vx *= 0.9;
        player.vy *= 0.9;
        player.vy += 0.1; // Sinking
    } else {
        if (keys['ArrowRight'] || keys['KeyD']) player.vx += 0.8;
        if (keys['ArrowLeft'] || keys['KeyA']) player.vx -= 0.8;
        player.vx *= 0.85; // Friction
        player.vy += 0.7;  // Gravity
    }

    // X Collision
    player.x += player.vx;
    platforms.forEach(p => {
        if (rectIntersect(player, p)) {
            if (player.vx > 0) player.x = p.x - player.w;
            else if (player.vx < 0) player.x = p.x + p.w;
            player.vx = 0;
        }
    });

    // Y Collision
    let grounded = false;
    player.y += player.vy;
    platforms.forEach(p => {
        if (rectIntersect(player, p)) {
            if (player.vy > 0) {
                player.y = p.y - player.h;
                grounded = true;
            } else if (player.vy < 0) {
                player.y = p.y + p.h;
            }
            player.vy = 0;
        }
    });

    if (grounded && !player.inWater && (keys['Space'] || keys['ArrowUp'] || keys['KeyW'])) {
        player.vy = -player.jump;
    }

    // Camera Follow
    camera.x += (player.x - canvas.width/2 - camera.x) * 0.1;
    camera.y += (player.y - canvas.height/2 - camera.y) * 0.1;

    // Reset if fall
    if (player.y > 1500) { player.x = 100; player.y = 100; player.vx = 0; player.vy = 0; }
}

// --- RENDERING ---
function drawRect(x, y, width, height, color) {
    gl.uniform4fv(colorLocation, color);
    const x1 = x, x2 = x + width, y1 = y, y2 = y + height;
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        x1, y1, x2, y1, x1, y2,
        x1, y2, x2, y1, x2, y2
    ]), gl.STATIC_DRAW);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function render() {
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.useProgram(program);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
    gl.uniform2f(cameraLocation, camera.x, camera.y);

    platforms.forEach(p => drawRect(p.x, p.y, p.w, p.h, [0.3, 0.7, 0.3, 1.0]));
    drawRect(player.x, player.y, player.w, player.h, player.color);
    waterZones.forEach(w => drawRect(w.x, w.y, w.w, w.h, w.color));

    requestAnimationFrame(() => {
        update();
        render();
    });
}

render();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 2D Gravity Platformer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #a0aec0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #game-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Allow the game container to fill available space */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0; /* Fix for flexbox overflow issue */
        }
        canvas {
            background-color: #2d3748;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            /* Let JS handle the size */
            max-width: 100%;
            max-height: 100%;
        }
        .key {
            background-color: #4a5568;
            border-radius: 0.25rem;
            padding: 2px 6px;
            border-bottom: 2px solid #2d3748;
            font-size: 0.8rem;
        }
        #touch-controls {
            position: absolute;
            bottom: 5%;
            width: 100%;
            padding: 0 5%;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none; /* Let clicks pass through the container */
        }
        .touch-btn {
            width: 70px;
            height: 70px;
            background-color: rgba(74, 85, 104, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            pointer-events: auto; /* Buttons are clickable */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }
        .touch-btn:active {
            background-color: rgba(74, 85, 104, 0.8);
        }
        .d-pad {
            display: flex;
            gap: 15px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center m-0 p-4">

    <div class="text-center mb-4 flex-shrink-0">
        <h1 class="text-2xl md:text-3xl text-white font-bold mb-2">Gravity Shift</h1>
        <p class="text-xs md:text-base">Land on the <span class="text-green-400">green</span> platform to flip gravity!</p>
        <p class="mt-2 text-sm hidden md:block">
            Controls: <span class="key">A</span>/<span class="key">D</span> or <span class="key">←</span>/<span class="key">→</span>, <span class="key">W</span>/<span class="key">↑</span> or <span class="key">Space</span> to Jump
        </p>
    </div>

    <div id="game-container">
        <canvas id="glCanvas"></canvas>
        <div id="touch-controls">
            <div class="d-pad">
                <button id="btn-left" class="touch-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/></svg>
                </button>
                <button id="btn-right" class="touch-btn">
                     <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 8a.5.5 0 0 1 .5-.5h5.793l-2.147-2.146a.5.5 0 0 1 .708-.708l3 3a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708-.708L10.293 8.5H4.5A.5.5 0 0 1 4 8z"/></svg>
                </button>
            </div>
            <button id="btn-jump" class="touch-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-arrow-up" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"/></svg>
            </button>
        </div>
    </div>


    <!-- Vertex Shader -->
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec4 aVertexPosition;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;

        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 uColor;

        void main(void) {
            gl_FragColor = uColor;
        }
    </script>

    <script>
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                return;
            }

            // --- Resize Logic ---
            const gameWidth = 800;
            const gameHeight = 600;

            function resizeCanvas() {
                const container = document.getElementById('game-container');
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                const aspect = gameWidth / gameHeight;
                
                let newWidth = containerWidth;
                let newHeight = newWidth / aspect;

                if (newHeight > containerHeight) {
                    newHeight = containerHeight;
                    newWidth = newHeight * aspect;
                }
                
                canvas.width = gameWidth;
                canvas.height = gameHeight;
                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';

                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();


            // --- Shader Programs ---
            const vsSource = document.getElementById('shader-vs').text;
            const fsSource = document.getElementById('shader-fs').text;
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    color: gl.getUniformLocation(shaderProgram, 'uColor'),
                },
            };

            const buffers = initBuffers(gl);

            // --- Game State ---
            let player = {
                x: 50,
                y: 500,
                prevY: 500,
                width: 30,
                height: 30,
                vx: 0,
                vy: 0,
                color: [0.9, 0.2, 0.2, 1.0], // Red
                onGround: false
            };

            const platforms = [
                { x: 20, y: 50, width: 200, height: 20, color: [0.6, 0.6, 0.8, 1.0] }, // Normal platform
                { x: 300, y: 250, width: 200, height: 20, color: [0.4, 0.8, 0.4, 1.0], isGravityChanger: true }, // Gravity platform
                { x: 580, y: 450, width: 200, height: 20, color: [0.6, 0.6, 0.8, 1.0] }  // Normal platform
            ];
            
            // --- Physics constants ---
            let gravity = -0.5;
            const jumpStrength = 12;
            const moveSpeed = 5;
            const friction = 0.8;

            // --- Input handling ---
            const keys = {};
            window.addEventListener('keydown', (e) => { keys[e.code] = true; });
            window.addEventListener('keyup', (e) => { keys[e.code] = false; });
            
            // Touch Controls
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnJump = document.getElementById('btn-jump');
            
            btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; });
            btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; });
            btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; });
            btnRight.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowRight'] = false; });
            btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; });
            btnJump.addEventListener('touchend', (e) => { e.preventDefault(); keys['Space'] = false; });

            let lastTime = 0;
            function gameLoop(currentTime) {
                currentTime *= 0.001; 
                lastTime = currentTime;

                update();
                drawScene(gl, programInfo, buffers, player, platforms);

                requestAnimationFrame(gameLoop);
            }
            requestAnimationFrame(gameLoop);


            function update() {
                // --- Handle Input ---
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    player.vx = -moveSpeed;
                } else if (keys['KeyD'] || keys['ArrowRight']) {
                    player.vx = moveSpeed;
                }

                const jumpPressed = keys['KeyW'] || keys['ArrowUp'] || keys['Space'];
                if (jumpPressed && player.onGround) {
                    player.vy = gravity > 0 ? -jumpStrength : jumpStrength;
                    player.onGround = false;
                }
                
                player.prevY = player.y;

                // --- Apply Physics ---
                player.vx *= friction;
                player.vy += gravity;

                player.x += player.vx;
                player.y += player.vy;

                player.onGround = false;

                // --- Collision Detection & Resolution ---

                // Floor and Ceiling collision
                if (player.y < 0) {
                    player.y = 0;
                    player.vy = 0;
                    player.onGround = true;
                }
                 if (player.y + player.height > gl.canvas.height) {
                    player.y = gl.canvas.height - player.height;
                    player.vy = 0;
                    player.onGround = true;
                }

                // Wall collision
                if (player.x < 0) {
                    player.x = 0;
                    player.vx = 0;
                }
                if (player.x + player.width > gl.canvas.width) {
                    player.x = gl.canvas.width - player.width;
                    player.vx = 0;
                }


                // Platform collision
                platforms.forEach(p => {
                    if (player.x < p.x + p.width && player.x + player.width > p.x &&
                        player.y < p.y + p.height && player.y + player.height > p.y) {
                        
                        if (gravity < 0 && player.prevY >= p.y + p.height) { // Landed on top
                            player.y = p.y + p.height;
                            player.vy = 0;
                            player.onGround = true;
                             if (p.isGravityChanger) {
                                gravity *= -1;
                            }
                        } else if (gravity > 0 && player.prevY + player.height <= p.y) { // Landed on bottom
                            player.y = p.y - player.height;
                            player.vy = 0;
                            player.onGround = true;
                            if (p.isGravityChanger) {
                                gravity *= -1;
                            }
                        }
                    }
                });
            }
        }

        // --- WebGL Drawing Functions ---

        function drawScene(gl, programInfo, buffers, player, platforms) {
            gl.clearColor(0.1, 0.15, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const projectionMatrix = mat4.create();
            mat4.ortho(projectionMatrix, 0, gl.canvas.width, 0, gl.canvas.height, -1, 1);

            gl.useProgram(programInfo.program);
            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

            drawObject(gl, programInfo, player);

            platforms.forEach(p => drawObject(gl, programInfo, p));
        }

        function drawObject(gl, programInfo, obj) {
            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [obj.x, obj.y, 0]);
            mat4.scale(modelViewMatrix, modelViewMatrix, [obj.width, obj.height, 1]);

            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
            gl.uniform4fv(programInfo.uniformLocations.color, obj.color);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [ 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return { position: positionBuffer };
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

    </script>
    <!-- Simple matrix library for transformations -->
    <script>
        const mat4 = {
            create: function() { return new Float32Array(16); },
            ortho: function(out, left, right, bottom, top, near, far) {
                let lr = 1 / (left - right);
                let bt = 1 / (bottom - top);
                let nf = 1 / (near - far);
                out[0] = -2 * lr; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = -2 * bt; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 2 * nf; out[11] = 0;
                out[12] = (left + right) * lr;
                out[13] = (top + bottom) * bt;
                out[14] = (far + near) * nf;
                out[15] = 1;
                return out;
            },
            translate: function(out, a, v) {
                let x = v[0], y = v[1];
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[0] * x + a[4] * y + a[8] * v[2] + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * v[2] + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * v[2] + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * v[2] + a[15];
                return out;
            },
            scale: function(out, a, v) {
                let x = v[0], y = v[1];
                out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
                out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
                out[8] = a[8] * v[2]; out[9] = a[9] * v[2]; out[10] = a[10] * v[2]; out[11] = a[11] * v[2];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            }
        };
    </script>

</body>
</html>

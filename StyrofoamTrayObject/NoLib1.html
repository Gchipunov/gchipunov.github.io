<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Raw WebGL Styrofoam Tray</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { width: 80vw; height: 80vh; background: #333; border: 2px solid #555; }
    </style>
</head>
<body>

<canvas id="glCanvas"></canvas>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

if (!gl) {
    alert('WebGL not supported');
}

// --- Shaders ---
const vsSource = `
    attribute vec4 aVertexPosition;
    attribute vec3 aNormal;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    varying lowp vec4 vColor;
    varying lowp vec3 vLighting;

    void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        
        // Simple lighting
        highp vec3 ambientLight = vec3(0.5, 0.5, 0.5);
        highp vec3 directionalLightColor = vec3(0.5, 0.5, 0.5);
        highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));
        highp float directional = max(dot(aNormal, directionalVector), 0.0);
        vLighting = ambientLight + (directionalLightColor * directional);
    }
`;

const fsSource = `
    varying lowp vec3 vLighting;
    void main(void) {
        // Styrofoam off-white color
        highp vec3 color = vec3(0.95, 0.95, 0.92); 
        gl_FragColor = vec4(color * vLighting, 1.0);
    }
`;

// Initialize Shaders
function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    return shaderProgram;
}

function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
const programInfo = {
    program: shaderProgram,
    attribLocations: {
        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
        normal: gl.getAttribLocation(shaderProgram, 'aNormal'),
    },
    uniformLocations: {
        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
    },
};

// --- Geometry (The Tray) ---
// We define a flat box with raised edges and two dividers
function initBuffers(gl) {
    const positions = [
        // Base plate
        -1.0, -0.1, -0.7,   1.0, -0.1, -0.7,   1.0, -0.1,  0.7,  -1.0, -0.1,  0.7,
        // Outer Edges (simplification: 4 walls)
        -1.0, -0.1, -0.7,  -1.0,  0.1, -0.7,   1.0,  0.1, -0.7,   1.0, -0.1, -0.7, // back
        -1.0, -0.1,  0.7,  -1.0,  0.1,  0.7,   1.0,  0.1,  0.7,   1.0, -0.1,  0.7, // front
        -1.0, -0.1, -0.7,  -1.0,  0.1, -0.7,  -1.0,  0.1,  0.7,  -1.0, -0.1,  0.7, // left
         1.0, -0.1, -0.7,   1.0,  0.1, -0.7,   1.0,  0.1,  0.7,   1.0, -0.1,  0.7, // right
        // Big Section Divider (vertical)
         0.0, -0.1, -0.7,   0.0,  0.1, -0.7,   0.0,  0.1,  0.7,   0.0, -0.1,  0.7,
        // Small Section Divider (horizontal, on the left side)
        -1.0, -0.1,  0.0,   0.0, -0.1,  0.0,   0.0,  0.1,  0.0,  -1.0,  0.1,  0.0
    ];

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    // Basic normals for lighting (facing up/out)
    const normals = new Float32Array(positions.length).fill(0.7); // simplified

    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

    const indices = [
        0, 1, 2,    0, 2, 3,    // base
        4, 5, 6,    4, 6, 7,    // back
        8, 9, 10,   8, 10, 11,  // front
        12, 13, 14, 12, 14, 15, // left
        16, 17, 18, 16, 18, 19, // right
        20, 21, 22, 20, 22, 23, // divider 1
        24, 25, 26, 24, 26, 27  // divider 2
    ];
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    return { position: positionBuffer, normal: normalBuffer, indices: indexBuffer, count: indices.length };
}

const buffers = initBuffers(gl);

// --- Math Helpers (Simplified Matrix math since no libraries) ---
function getPerspectiveMatrix(fieldOfView, aspect, zNear, zFar) {
    const f = 1.0 / Math.tan(fieldOfView / 2);
    const rangeInv = 1 / (zNear - zFar);
    return [
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (zNear + zFar) * rangeInv, -1,
        0, 0, zNear * zFar * rangeInv * 2, 0
    ];
}

function drawScene() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0.2, 0.2, 0.2, 1.0);
    gl.clearDepth(1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const projectionMatrix = getPerspectiveMatrix(45 * Math.PI / 180, gl.canvas.width / gl.canvas.height, 0.1, 100.0);
    
    // Create a ModelView matrix (Rotate it slightly to see the sections)
    let t = Date.now() * 0.001;
    let c = Math.cos(t * 0.5), s = Math.sin(t * 0.5);
    const modelViewMatrix = [
        c, 0.3*s, -s, 0,
        0, 0.8, 0.4, 0,
        s, -0.3*c, c, 0,
        0, 0, -3.5, 1
    ];

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
    gl.vertexAttribPointer(programInfo.attribLocations.normal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.normal);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
    gl.useProgram(programInfo.program);

    gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, new Float32Array(projectionMatrix));
    gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, new Float32Array(modelViewMatrix));

    gl.drawElements(gl.TRIANGLES, buffers.count, gl.UNSIGNED_SHORT, 0);
    requestAnimationFrame(drawScene);
}

drawScene();
</script>
</body>
</html>

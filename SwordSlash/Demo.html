<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Sword Slash Effect</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script id="vs" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        attribute float aAlpha;
        varying float vAlpha;
        void main() {
            vAlpha = aAlpha;
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        precision mediump float;
        varying float vAlpha;
        uniform vec3 uColor;
        void main() {
            // High intensity glow based on alpha
            gl_FragColor = vec4(uColor * vAlpha, vAlpha);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');

        // --- Shader Setup ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
        gl.linkProgram(program);
        gl.useProgram(program);

        // --- State ---
        let points = []; 
        const maxPoints = 60; // Length of the trail
        const slashColor = [0.2, 0.8, 1.0]; // Cyan glow
        let mouse = { x: 0, y: 0, lastX: 0, lastY: 0 };

        // Buffers
        const posBuffer = gl.createBuffer();
        const alphaBuffer = gl.createBuffer();

        // Resize handler
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Mouse tracking
        window.addEventListener('mousemove', e => {
            mouse.lastX = mouse.x;
            mouse.lastY = mouse.y;
            // Convert to Clip Space (-1 to 1)
            mouse.x = (e.clientX / canvas.width) * 2 - 1;
            mouse.y = (e.clientY / canvas.height) * -2 + 1;

            // Create a "segment" representing the width of the blade
            // We use the movement vector to determine the perpendicular "width"
            const dx = mouse.x - mouse.lastX;
            const dy = mouse.y - mouse.lastY;
            const mag = Math.sqrt(dx*dx + dy*dy) || 1;
            const nx = -dy / mag * 0.05; // Perpendicular X (blade width)
            const ny = dx / mag * 0.05;  // Perpendicular Y

            points.push({
                p1: [mouse.x + nx, mouse.y + ny],
                p2: [mouse.x - nx, mouse.y - ny],
                age: 1.0
            });
        });

        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending for glow

            if (points.length > 1) {
                const vertices = [];
                const alphas = [];

                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    vertices.push(...p.p1, ...p.p2);
                    alphas.push(p.age, p.age);
                    
                    // Fade out
                    p.age *= 0.92; 
                }

                // Clean up dead segments
                points = points.filter(p => p.age > 0.01);
                if (points.length > maxPoints) points.shift();

                // Bind Positions
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
                const aPos = gl.getAttribLocation(program, "aPosition");
                gl.enableVertexAttribArray(aPos);
                gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

                // Bind Alphas
                gl.bindBuffer(gl.ARRAY_BUFFER, alphaBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(alphas), gl.DYNAMIC_DRAW);
                const aAlpha = gl.getAttribLocation(program, "aAlpha");
                gl.enableVertexAttribArray(aAlpha);
                gl.vertexAttribPointer(aAlpha, 1, gl.FLOAT, false, 0, 0);

                // Uniforms
                const uCol = gl.getUniformLocation(program, "uColor");
                gl.uniform3fv(uCol, slashColor);

                // Draw the trail as a Triangle Strip
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / 2);
            }

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>

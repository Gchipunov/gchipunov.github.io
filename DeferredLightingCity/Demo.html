<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL 2 - Deferred City Lights</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <div id="info">WebGL 2.0 Deferred Shading: 100+ Dynamic Lights</div>
    <canvas id="glCanvas"></canvas>

    <script id="geo-vs" type="x-shader/x-vertex">#version 300 es
        layout(location=0) in vec3 a_position;
        layout(location=1) in vec3 a_normal;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_model;

        out vec3 v_position;
        out vec3 v_normal;

        void main() {
            vec4 worldPos = u_model * vec4(a_position, 1.0);
            v_position = worldPos.xyz;
            v_normal = mat3(u_model) * a_normal;
            gl_Position = u_projection * u_view * worldPos;
        }
    </script>

    <script id="geo-fs" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        
        in vec3 v_position;
        in vec3 v_normal;

        layout(location=0) out vec4 outPosition;
        layout(location=1) out vec4 outNormal;
        layout(location=2) out vec4 outAlbedo;

        void main() {
            outPosition = vec4(v_position, 1.0);
            outNormal = vec4(normalize(v_normal), 1.0);
            outAlbedo = vec4(0.2, 0.2, 0.25, 1.0); // Dark grey city buildings
        }
    </script>

    <script id="light-vs" type="x-shader/x-vertex">#version 300 es
        layout(location=0) in vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="light-fs" type="x-shader/x-fragment">#version 300 es
        precision highp float;

        uniform sampler2D u_posTex;
        uniform sampler2D u_normTex;
        uniform sampler2D u_albedoTex;

        struct Light {
            vec3 position;
            vec3 color;
            float radius;
        };
        const int MAX_LIGHTS = 64;
        uniform Light u_lights[MAX_LIGHTS];
        uniform vec3 u_viewPos;
        uniform vec2 u_resolution;

        out vec4 fragColor;

        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution;
            
            vec3 fragPos = texture(u_posTex, uv).xyz;
            vec3 normal = texture(u_normTex, uv).xyz;
            vec3 albedo = texture(u_albedoTex, uv).rgb;

            vec3 lighting = albedo * 0.05; // Ambient

            for(int i = 0; i < MAX_LIGHTS; i++) {
                // Diffuse
                vec3 lightDir = u_lights[i].position - fragPos;
                float dist = length(lightDir);
                if(dist < u_lights[i].radius) {
                    lightDir = normalize(lightDir);
                    float diff = max(dot(normal, lightDir), 0.0);
                    
                    // Attenuation
                    float atten = 1.0 - (dist / u_lights[i].radius);
                    atten = pow(atten, 2.0);
                    
                    lighting += albedo * u_lights[i].color * diff * atten * 2.0;
                }
            }

            fragColor = vec4(lighting, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) { alert("WebGL 2 not supported"); }

        // --- UTILS ---
        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
            return s;
        }

        function createProgram(gl, vsSource, fsSource) {
            const p = gl.createProgram();
            gl.attachShader(p, createShader(gl, gl.VERTEX_SHADER, vsSource));
            gl.attachShader(p, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
            gl.linkProgram(p);
            return p;
        }

        // --- SETUP G-BUFFER ---
        const gBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, gBuffer);

        const depthRGB = [gl.RGBA32F, gl.RGBA32F, gl.RGBA8];
        const gTextures = [];
        for (let i = 0; i < 3; i++) {
            gTextures[i] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, gTextures[i]);
            gl.texImage2D(gl.TEXTURE_2D, 0, depthRGB[i], window.innerWidth, window.innerHeight, 0, gl.RGBA, (i === 2 ? gl.UNSIGNED_BYTE : gl.FLOAT), null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, gTextures[i], 0);
        }

        const depthTarget = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthTarget);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, window.innerWidth, window.innerHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthTarget);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // --- GEOMETRY: CUBE ---
        const cubeData = new Float32Array([
            -1,-1,-1, 0,0,-1, 1,-1,-1, 0,0,-1, 1, 1,-1, 0,0,-1, -1, 1,-1, 0,0,-1,
            -1,-1, 1, 0,0, 1, 1,-1, 1, 0,0, 1, 1, 1, 1, 0,0, 1, -1, 1, 1, 0,0, 1,
            -1,-1,-1, -1,0,0, -1, 1,-1, -1,0,0, -1, 1, 1, -1,0,0, -1,-1, 1, -1,0,0,
             1,-1,-1, 1,0,0,  1, 1,-1, 1,0,0,  1, 1, 1, 1,0,0,  1,-1, 1, 1,0,0,
            -1,-1,-1, 0,-1,0, 1,-1,-1, 0,-1,0, 1,-1, 1, 0,-1,0, -1,-1, 1, 0,-1,0,
            -1, 1,-1, 0, 1,0, 1, 1,-1, 0, 1,0, 1, 1, 1, 0, 1,0, -1, 1, 1, 0, 1,0
        ]);
        const cubeIndices = new Uint16Array([
            0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23
        ]);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, cubeData, gl.STATIC_DRAW);
        const ebo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);

        // --- FULLSCREEN QUAD ---
        const quadVAO = gl.createVertexArray();
        gl.bindVertexArray(quadVAO);
        const quadVBO = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // --- SHADERS ---
        const geoProg = createProgram(gl, document.getElementById('geo-vs').text, document.getElementById('geo-fs').text);
        const lightProg = createProgram(gl, document.getElementById('light-vs').text, document.getElementById('light-fs').text);

        // --- LIGHT DATA ---
        const numLights = 64;
        const lights = [];
        for(let i=0; i<numLights; i++) {
            lights.push({
                pos: [(Math.random()-0.5)*40, 1, (Math.random()-0.5)*40],
                color: [Math.random(), Math.random(), Math.random()],
                radius: 5 + Math.random() * 10,
                speed: 0.02 + Math.random() * 0.05
            });
        }

        // --- RENDER LOOP ---
        function render(time) {
            time *= 0.001;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // 1. Geometry Pass
            gl.bindFramebuffer(gl.FRAMEBUFFER, gBuffer);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(geoProg);
            const proj = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); 
            // Manual simple perspective
            const aspect = canvas.width / canvas.height;
            const f = 1.0 / Math.tan(45 * Math.PI / 360);
            proj[0] = f / aspect; proj[5] = f; proj[10] = -1.01; proj[11] = -1; proj[14] = -0.2;

            gl.uniformMatrix4fv(gl.getUniformLocation(geoProg, "u_projection"), false, proj);
            
            // View matrix (camera circling)
            const camX = Math.sin(time * 0.2) * 30;
            const camZ = Math.cos(time * 0.2) * 30;
            const view = lookAt([camX, 20, camZ], [0, 0, 0], [0, 1, 0]);
            gl.uniformMatrix4fv(gl.getUniformLocation(geoProg, "u_view"), false, view);

            gl.bindVertexArray(vao);
            // Draw City Grid
            for(let x = -5; x <= 5; x++) {
                for(let z = -5; z <= 5; z++) {
                    const h = Math.abs(Math.sin(x * 0.5 + z * 0.3)) * 10 + 2;
                    const model = translateScale(x*6, h/2, z*6, 1.5, h, 1.5);
                    gl.uniformMatrix4fv(gl.getUniformLocation(geoProg, "u_model"), false, model);
                    gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
                }
            }
            // Floor
            gl.uniformMatrix4fv(gl.getUniformLocation(geoProg, "u_model"), false, translateScale(0, -0.1, 0, 50, 0.1, 50));
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

            // 2. Lighting Pass
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            gl.useProgram(lightProg);
            gl.uniform2f(gl.getUniformLocation(lightProg, "u_resolution"), canvas.width, canvas.height);

            // Pass G-Buffer textures
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, gTextures[0]);
            gl.uniform1i(gl.getUniformLocation(lightProg, "u_posTex"), 0);
            gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, gTextures[1]);
            gl.uniform1i(gl.getUniformLocation(lightProg, "u_normTex"), 1);
            gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, gTextures[2]);
            gl.uniform1i(gl.getUniformLocation(lightProg, "u_albedoTex"), 2);

            // Update and pass lights
            lights.forEach((l, i) => {
                const x = l.pos[0] + Math.sin(time * l.speed + i) * 5;
                const z = l.pos[2] + Math.cos(time * l.speed + i) * 5;
                gl.uniform3f(gl.getUniformLocation(lightProg, `u_lights[${i}].position`), x, l.pos[1], z);
                gl.uniform3fv(gl.getUniformLocation(lightProg, `u_lights[${i}].color`), l.color);
                gl.uniform1f(gl.getUniformLocation(lightProg, `u_lights[${i}].radius`), l.radius);
            });

            gl.bindVertexArray(quadVAO);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // --- MATH HELPERS ---
        function translateScale(tx, ty, tz, sx, sy, sz) {
            return new Float32Array([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, tx,ty,tz,1]);
        }

        function lookAt(eye, center, up) {
            let z = normalize([eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]]);
            let x = normalize(cross(up, z));
            let y = normalize(cross(z, x));
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x,eye), -dot(y,eye), -dot(z,eye), 1
            ]);
        }
        function normalize(v) { let d = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/d, v[1]/d, v[2]/d]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

        // Start
        gl.getExtension('EXT_color_buffer_float'); // Essential for storing positions in textures
        requestAnimationFrame(render);
    </script>
</body>
</html>

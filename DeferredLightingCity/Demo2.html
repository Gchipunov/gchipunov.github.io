<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL 2 - Deferred City & Holograms</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #info { position: absolute; top: 10px; left: 10px; color: cyan; font-family: 'Courier New', Courier, monospace; pointer-events: none; text-shadow: 0 0 5px cyan; }
    </style>
</head>
<body>
    <div id="info">DEFERRED CITY // HOLOGRAM OVERLAY ACTIVE</div>
    <canvas id="glCanvas"></canvas>

    <script id="geo-vs" type="x-shader/x-vertex">#version 300 es
        layout(location=0) in vec3 a_position;
        layout(location=1) in vec3 a_normal;
        uniform mat4 u_projection, u_view, u_model;
        out vec3 v_position;
        out vec3 v_normal;
        void main() {
            vec4 worldPos = u_model * vec4(a_position, 1.0);
            v_position = worldPos.xyz;
            v_normal = mat3(u_model) * a_normal;
            gl_Position = u_projection * u_view * worldPos;
        }
    </script>

    <script id="geo-fs" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec3 v_position, v_normal;
        layout(location=0) out vec4 outPosition;
        layout(location=1) out vec4 outNormal;
        layout(location=2) out vec4 outAlbedo;
        void main() {
            outPosition = vec4(v_position, 1.0);
            outNormal = vec4(normalize(v_normal), 1.0);
            outAlbedo = vec4(0.1, 0.1, 0.15, 1.0);
        }
    </script>

    <script id="holo-fs" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        in vec3 v_position, v_normal;
        uniform vec3 u_viewPos;
        uniform float u_time;
        out vec4 fragColor;
        void main() {
            vec3 viewDir = normalize(u_viewPos - v_position);
            float fresnel = pow(1.0 - dot(viewDir, normalize(v_normal)), 3.0);
            
            // Scanline effect
            float scanline = sin(v_position.y * 10.0 - u_time * 5.0) * 0.5 + 0.5;
            vec3 holoColor = vec3(0.0, 0.8, 1.0); // Cyber blue
            
            float alpha = (fresnel + 0.2) * scanline * 0.6;
            fragColor = vec4(holoColor * (fresnel + 0.5), alpha);
        }
    </script>

    <script id="light-vs" type="x-shader/x-vertex">#version 300 es
        layout(location=0) in vec2 a_position;
        void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    </script>

    <script id="light-fs" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        uniform sampler2D u_posTex, u_normTex, u_albedoTex;
        struct Light { vec3 position, color; float radius; };
        const int MAX_LIGHTS = 64;
        uniform Light u_lights[MAX_LIGHTS];
        uniform vec2 u_resolution;
        out vec4 fragColor;
        void main() {
            vec2 uv = gl_FragCoord.xy / u_resolution;
            vec3 fragPos = texture(u_posTex, uv).xyz;
            vec3 normal = texture(u_normTex, uv).xyz;
            vec3 albedo = texture(u_albedoTex, uv).rgb;
            vec3 lighting = albedo * 0.1;
            for(int i = 0; i < MAX_LIGHTS; i++) {
                vec3 lightDir = u_lights[i].position - fragPos;
                float dist = length(lightDir);
                if(dist < u_lights[i].radius) {
                    float diff = max(dot(normal, normalize(lightDir)), 0.0);
                    float atten = pow(1.0 - (dist / u_lights[i].radius), 2.0);
                    lighting += albedo * u_lights[i].color * diff * atten * 3.0;
                }
            }
            fragColor = vec4(lighting, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');
        gl.getExtension('EXT_color_buffer_float');

        // --- SETUP SHADERS ---
        const geoProg = createProgram(gl, 'geo-vs', 'geo-fs');
        const holoProg = createProgram(gl, 'geo-vs', 'holo-fs');
        const lightProg = createProgram(gl, 'light-vs', 'light-fs');

        function createProgram(gl, vsId, fsId) {
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, document.getElementById(vsId).text);
            gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, document.getElementById(fsId).text);
            gl.compileShader(fs);
            const p = gl.createProgram();
            gl.attachShader(p, vs); gl.attachShader(p, fs);
            gl.linkProgram(p);
            return p;
        }

        // --- SETUP G-BUFFER ---
        const gBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, gBuffer);
        const gTextures = [];
        const formats = [gl.RGBA32F, gl.RGBA32F, gl.RGBA8];
        for (let i = 0; i < 3; i++) {
            gTextures[i] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, gTextures[i]);
            gl.texImage2D(gl.TEXTURE_2D, 0, formats[i], window.innerWidth, window.innerHeight, 0, gl.RGBA, (i===2?gl.UNSIGNED_BYTE:gl.FLOAT), null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, gTextures[i], 0);
        }
        const depthTarget = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthTarget);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, window.innerWidth, window.innerHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthTarget);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2]);

        // --- GEOMETRY DATA ---
        const cubeData = new Float32Array([-1,-1,-1,0,0,-1,1,-1,-1,0,0,-1,1,1,-1,0,0,-1,-1,1,-1,0,0,-1,-1,-1,1,0,0,1,1,-1,1,0,0,1,1,1,1,0,0,1,-1,1,1,0,0,1,-1,-1,-1,-1,0,0,-1,1,-1,-1,0,0,-1,1,1,-1,0,0,-1,-1,1,-1,0,0,1,-1,-1,1,0,0,1,1,-1,1,0,0,1,1,1,1,0,0,1,-1,1,1,0,0,-1,-1,-1,0,-1,0,1,-1,-1,0,-1,0,1,-1,1,0,-1,0,-1,-1,1,0,-1,0,-1,1,-1,0,1,0,1,1,-1,0,1,0,1,1,1,0,1,0,-1,1,1,0,1,0]);
        const cubeIndices = new Uint16Array([0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11, 12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23]);
        
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, cubeData, gl.STATIC_DRAW);
        const ebo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 24, 0);
        gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 24, 12);

        const quadVAO = gl.createVertexArray();
        gl.bindVertexArray(quadVAO);
        const quadVBO = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        const lights = Array.from({length:64}, () => ({
            pos: [(Math.random()-0.5)*50, 1, (Math.random()-0.5)*50],
            color: [Math.random(), Math.random(), Math.random()],
            radius: 8 + Math.random()*12,
            speed: 0.02 + Math.random()*0.05
        }));

        function render(time) {
            time *= 0.001;
            gl.viewport(0, 0, canvas.width = window.innerWidth, canvas.height = window.innerHeight);

            const camPos = [Math.sin(time*0.2)*35, 15, Math.cos(time*0.2)*35];
            const view = lookAt(camPos, [0,0,0], [0,1,0]);
            const proj = perspective(45, canvas.width/canvas.height, 0.1, 100);

            // 1. GEOMETRY PASS
            gl.bindFramebuffer(gl.FRAMEBUFFER, gBuffer);
            gl.clearColor(0,0,0,1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.useProgram(geoProg);
            gl.uniformMatrix4fv(gl.getUniformLocation(geoProg, "u_projection"), false, proj);
            gl.uniformMatrix4fv(gl.getUniformLocation(geoProg, "u_view"), false, view);

            gl.bindVertexArray(vao);
            drawCity(gl, geoProg);

            // 2. LIGHTING PASS
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);
            gl.useProgram(lightProg);
            gl.uniform2f(gl.getUniformLocation(lightProg, "u_resolution"), canvas.width, canvas.height);
            gTextures.forEach((t, i) => { gl.activeTexture(gl.TEXTURE0+i); gl.bindTexture(gl.TEXTURE_2D, t); gl.uniform1i(gl.getUniformLocation(lightProg, i===0?"u_posTex":i===1?"u_normTex":"u_albedoTex"), i); });
            lights.forEach((l, i) => {
                const x = l.pos[0] + Math.sin(time*l.speed+i)*5;
                gl.uniform3f(gl.getUniformLocation(lightProg, `u_lights[${i}].position`), x, l.pos[1], l.pos[2]);
                gl.uniform3fv(gl.getUniformLocation(lightProg, `u_lights[${i}].color`), l.color);
                gl.uniform1f(gl.getUniformLocation(lightProg, `u_lights[${i}].radius`), l.radius);
            });
            gl.bindVertexArray(quadVAO);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // 3. HOLOGRAM PASS (Forward rendering with transparency)
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending
            gl.useProgram(holoProg);
            gl.uniformMatrix4fv(gl.getUniformLocation(holoProg, "u_projection"), false, proj);
            gl.uniformMatrix4fv(gl.getUniformLocation(holoProg, "u_view"), false, view);
            gl.uniform3fv(gl.getUniformLocation(holoProg, "u_viewPos"), camPos);
            gl.uniform1f(gl.getUniformLocation(holoProg, "u_time"), time);

            gl.bindVertexArray(vao);
            // Draw duplicate city shifted and scaled
            drawCity(gl, holoProg, true); 
            gl.disable(gl.BLEND);

            requestAnimationFrame(render);
        }

        function drawCity(gl, prog, isHolo = false) {
            const uModel = gl.getUniformLocation(prog, "u_model");
            for(let x = -5; x <= 5; x++) {
                for(let z = -5; z <= 5; z++) {
                    const h = Math.abs(Math.sin(x*0.5+z*0.3))*10 + 2;
                    // If hologram, offset slightly and make them "flicker" height
                    const off = isHolo ? Math.sin(performance.now()*0.005 + x)*0.5 : 0;
                    const model = translateScale(x*7, (h+off)/2, z*7, 1.2, h+off, 1.2);
                    gl.uniformMatrix4fv(uModel, false, model);
                    gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
                }
            }
        }

        // --- MATH ---
        function translateScale(tx, ty, tz, sx, sy, sz) { return new Float32Array([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, tx,ty,tz,1]); }
        function perspective(fovy, aspect, near, far) {
            let f = 1.0 / Math.tan(fovy * Math.PI / 360);
            return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)/(near-far),-1, 0,0,(2*far*near)/(near-far),0]);
        }
        function lookAt(eye, center, up) {
            let z = normalize([eye[0]-center[0], eye[1]-center[1], eye[2]-center[2]]);
            let x = normalize(cross(up, z));
            let y = normalize(cross(z, x));
            return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
        }
        function normalize(v) { let d=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/d,v[1]/d,v[2]/d]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

        requestAnimationFrame(render);
    </script>
</body>
</html>

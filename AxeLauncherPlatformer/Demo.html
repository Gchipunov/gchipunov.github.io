<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Axe Launcher Platformer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; }
        #gameCanvas { display: block; background-color: #555; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
        }
        .control-button {
            width: 80px;
            height: 80px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            user-select: none;
            cursor: pointer;
            transition: background-color 0.1s;
        }
        .control-button:active {
            background-color: #0056b3;
        }
        #jump-button { margin-left: 100px; } /* Space out Jump/Shoot from Movement */
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="controls">
        <button class="control-button" id="left-button" ontouchstart="handleControl(true, 'left')" ontouchend="handleControl(false, 'left')">◀</button>
        <button class="control-button" id="right-button" ontouchstart="handleControl(true, 'right')" ontouchend="handleControl(false, 'right')">▶</button>
        <button class="control-button" id="jump-button" ontouchstart="handleControl(true, 'jump')">▲</button>
        <button class="control-button" id="shoot-button" ontouchstart="handleControl(true, 'shoot')">⛏</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('Your browser does not support WebGL.');
        }

        // --- Configuration ---
        const WIDTH = 800;
        const HEIGHT = 450;
        const GRAVITY = 0.5;
        const JUMP_POWER = -10;
        const MOVE_SPEED = 5;
        const AXE_SPEED = 15;

        // Set up the canvas size
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        gl.viewport(0, 0, WIDTH, HEIGHT);

        // --- Shaders (Minimal 2D Color Shader) ---
        const vsSource = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            varying vec4 v_color;
            uniform mat4 u_projectionMatrix;

            void main() {
                gl_Position = u_projectionMatrix * a_position;
                v_color = a_color;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec4 v_color;

            void main() {
                gl_FragColor = v_color;
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        }

        gl.useProgram(shaderProgram);

        // Get attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        const colorAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_color');
        const projectionMatrixUniformLocation = gl.getUniformLocation(shaderProgram, 'u_projectionMatrix');

        // Create a simple orthographic projection matrix for 2D (maps pixel coords to clip space)
        function getOrthographicMatrix(width, height) {
            // This is a simple 2D transformation: scale to -1 to 1 range, translate, and invert Y
            return new Float32Array([
                2 / width, 0, 0, 0,
                0, -2 / height, 0, 0, // Negative Y for standard pixel coords (top-left is 0,0)
                0, 0, 1, 0,
                -1, 1, 0, 1
            ]);
        }

        const projectionMatrix = getOrthographicMatrix(WIDTH, HEIGHT);
        gl.uniformMatrix4fv(projectionMatrixUniformLocation, false, projectionMatrix);


        // --- Game Objects ---

        const player = {
            x: 100, y: 100,
            width: 20, height: 40,
            velX: 0, velY: 0,
            isGrounded: false,
            color: [1.0, 0.0, 0.0, 1.0] // Red
        };

        const platforms = [
            // Ground
            { x: 0, y: HEIGHT - 20, width: WIDTH, height: 20, color: [0.3, 0.3, 0.3, 1.0] },
            // Platform 1
            { x: 50, y: HEIGHT - 100, width: 150, height: 10, color: [0.1, 0.8, 0.1, 1.0] },
            // Platform 2
            { x: 400, y: HEIGHT - 180, width: 200, height: 10, color: [0.1, 0.8, 0.1, 1.0] }
        ];

        const axes = [];

        // --- Input Handling ---

        const controlsState = {
            left: false,
            right: false,
            jump: false,
            shoot: false
        };

        function handleControl(isDown, action) {
            controlsState[action] = isDown;

            // Simple jump trigger (only jump on press, not hold)
            if (action === 'jump' && isDown) {
                if (player.isGrounded) {
                    player.velY = JUMP_POWER;
                    player.isGrounded = false;
                }
            }

            // Simple shoot trigger (only shoot on press)
            if (action === 'shoot' && isDown) {
                shootAxe();
            }
        }

        // --- Game Logic ---

        function shootAxe() {
            // Launch an axe from the player's center
            const axe = {
                x: player.x + player.width / 2,
                y: player.y + player.height / 2,
                width: 15,
                height: 15,
                velX: AXE_SPEED * (player.velX >= 0 ? 1 : -1), // Fire in the direction player is moving/facing
                velY: 0,
                color: [0.5, 0.5, 0.5, 1.0] // Gray
            };
            axes.push(axe);
        }

        function updatePlayer() {
            // Apply gravity
            player.velY += GRAVITY;

            // Apply horizontal movement based on controls
            if (controlsState.left) {
                player.velX = -MOVE_SPEED;
            } else if (controlsState.right) {
                player.velX = MOVE_SPEED;
            } else {
                player.velX = 0;
            }

            // Update position
            player.x += player.velX;
            player.y += player.velY;

            // Basic Collision Detection (AABB)
            player.isGrounded = false;
            for (const platform of platforms) {
                // Check for collision
                if (player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y < platform.y + platform.height &&
                    player.y + player.height > platform.y) {

                    // Collision occurred. Resolve Y collision first (Vertical)
                    if (player.velY > 0) { // Moving Down (Landing)
                        player.y = platform.y - player.height;
                        player.velY = 0;
                        player.isGrounded = true;
                    } else if (player.velY < 0) { // Moving Up (Hitting head)
                        player.y = platform.y + platform.height;
                        player.velY = 0;
                    }

                    // Resolve X collision (Horizontal) - Left as an exercise!
                    // This simple example prioritizes Y resolution for platforming feel.
                }
            }
        }

        function updateAxes() {
            for (let i = axes.length - 1; i >= 0; i--) {
                const axe = axes[i];
                axe.x += axe.velX;
                // axe.y += axe.velY; // Could add gravity/arc if desired

                // Check if axe is off-screen
                if (axe.x < 0 || axe.x > WIDTH || axe.y < 0 || axe.y > HEIGHT) {
                    axes.splice(i, 1); // Remove from array
                }
            }
        }

        // --- Rendering ---

        // Buffers for WebGL
        const positionBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();

        function drawRect(x, y, w, h, color) {
            const positions = [
                x, y,
                x + w, y,
                x, y + h,
                x, y + h,
                x + w, y,
                x + w, y + h,
            ];

            const colors = [
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
                color[0], color[1], color[2], color[3],
            ];

            // Load positions
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionAttributeLocation);

            // Load colors
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(colorAttributeLocation);

            // Draw the rectangle (6 vertices = 2 triangles)
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function drawScene() {
            gl.clearColor(0.2, 0.2, 0.2, 1.0); // Dark gray background
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Draw platforms
            for (const platform of platforms) {
                drawRect(platform.x, platform.y, platform.width, platform.height, platform.color);
            }

            // Draw player
            drawRect(player.x, player.y, player.width, player.height, player.color);

            // Draw axes
            for (const axe of axes) {
                drawRect(axe.x, axe.y, axe.width, axe.height, axe.color);
            }
        }

        // --- Game Loop ---
        function gameLoop() {
            // 1. Update Game State
            updatePlayer();
            updateAxes();

            // 2. Draw Scene
            drawScene();

            // Loop
            requestAnimationFrame(gameLoop);
        }

        // Start the game!
        gameLoop();
    </script>
</body>
</html>

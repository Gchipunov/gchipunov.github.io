<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>XPBD Exploding Softbody (Volume Constraint)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none;
        }
        button {
            pointer-events: auto; padding: 10px 20px;
            background: #ff4444; color: white; border: none;
            border-radius: 4px; font-weight: bold; cursor: pointer;
            font-size: 16px; margin-top: 10px;
        }
        button:hover { background: #ff6666; }
        button:active { transform: scale(0.98); }
        .slider-container { margin-bottom: 10px; pointer-events: auto; }
        label { display: block; margin-bottom: 5px; font-size: 14px;}
        input { width: 100%; }
    </style>
</head>
<body>

<div id="ui">
    <h3>XPBD Volume Constraint</h3>
    <div class="slider-container">
        <label>Pressure (Volume Target)</label>
        <input type="range" id="pressureRange" min="1.0" max="4.0" step="0.1" value="1.0">
    </div>
    <div id="stats">Vertices: 0 | Constraints: 0</div>
    <button id="explodeBtn">ðŸ’¥ EXPLODE (Overpressure)</button>
    <p style="font-size: 0.8em; color: #aaa;">Scroll to Zoom | Drag to Rotate</p>
</div>

<div id="canvas-container"></div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- CONFIGURATION ---
const DT = 1/60;
const SUBSTEPS = 10; // Physics stability
const TEAR_THRESHOLD = 2.5; // Ratio of stretch allowed before snapping

// --- PHYSICS STATE ---
let particles = []; // { x, y, z, oldX, oldY, oldZ, invMass }
let constraints = []; // { p1, p2, restLen, type }
let faces = []; // Indices [a, b, c] for volume calc
let simulationTime = 0;
let targetVolumeScale = 1.0;
let initialVolume = 0;
let meshRef = null;

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 8);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.getElementById('canvas-container').appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lights
const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
scene.add(ambientLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(5, 10, 7);
dirLight.castShadow = true;
scene.add(dirLight);

// Floor
const floorGeo = new THREE.PlaneGeometry(20, 20);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -2;
floor.receiveShadow = true;
scene.add(floor);

// --- XPBD CORE FUNCTIONS ---

function getVolume() {
    let vol = 0;
    // Volume of a closed mesh is the sum of signed volumes of tetrahedra formed by faces and origin
    // V = 1/6 * sum( p1 . (p2 x p3) )
    for (let f of faces) {
        const p1 = particles[f[0]];
        const p2 = particles[f[1]];
        const p3 = particles[f[2]];

        // Cross product (p2 x p3)
        const cx = p2.y * p3.z - p2.z * p3.y;
        const cy = p2.z * p3.x - p2.x * p3.z;
        const cz = p2.x * p3.y - p2.y * p3.x;

        // Dot product p1 . cross
        vol += p1.x * cx + p1.y * cy + p1.z * cz;
    }
    return vol / 6.0;
}

function solveVolumeConstraint(dt) {
    // 1. Calculate current volume
    const currentVol = getVolume();
    const restVol = initialVolume * targetVolumeScale;
    
    // Constraint C(x) = V - Vrest = 0
    let C = currentVol - restVol;
    
    // If we are close enough or volume is negative (inverted), skip or handle gracefully
    if (Math.abs(C) < 0.001) return;

    // XPBD Compliance (alpha). 0 = rigid. Higher = softer gas.
    const compliance = 0.0001 / (dt * dt); 
    
    // 2. Calculate Gradients (nabla C)
    // The gradient of Volume w.r.t vertex i is 1/6 * sum(normals of adjacent faces)
    // Simplified: We accumulate the gradient vector for every particle
    const grads = new Float32Array(particles.length * 3).fill(0);
    let sumGradSq = 0;

    for (let f of faces) {
        const id1 = f[0], id2 = f[1], id3 = f[2];
        const p1 = particles[id1], p2 = particles[id2], p3 = particles[id3];

        // Gradient for p1 is 1/6 * (p2 x p3)
        // Note: Correct winding order is critical here
        
        // n1 = (p2 x p3) / 6
        const n1x = (p2.y * p3.z - p2.z * p3.y) / 6;
        const n1y = (p2.z * p3.x - p2.x * p3.z) / 6;
        const n1z = (p2.x * p3.y - p2.y * p3.x) / 6;

        // n2 = (p3 x p1) / 6
        const n2x = (p3.y * p1.z - p3.z * p1.y) / 6;
        const n2y = (p3.z * p1.x - p3.x * p1.z) / 6;
        const n2z = (p3.x * p1.y - p3.y * p1.x) / 6;

        // n3 = (p1 x p2) / 6
        const n3x = (p1.y * p2.z - p1.z * p2.y) / 6;
        const n3y = (p1.z * p2.x - p1.x * p2.z) / 6;
        const n3z = (p1.x * p2.y - p1.y * p2.x) / 6;

        // Accumulate
        grads[id1 * 3] += n1x; grads[id1 * 3 + 1] += n1y; grads[id1 * 3 + 2] += n1z;
        grads[id2 * 3] += n2x; grads[id2 * 3 + 1] += n2y; grads[id2 * 3 + 2] += n2z;
        grads[id3 * 3] += n3x; grads[id3 * 3 + 1] += n3y; grads[id3 * 3 + 2] += n3z;
    }

    // 3. Calculate Lagrange Multiplier denominator
    for (let i = 0; i < particles.length; i++) {
        if (particles[i].invMass === 0) continue;
        const gx = grads[i*3];
        const gy = grads[i*3+1];
        const gz = grads[i*3+2];
        sumGradSq += particles[i].invMass * (gx*gx + gy*gy + gz*gz);
    }

    if (sumGradSq < 1e-6) return;

    // 4. Calculate Lambda
    const alpha = compliance; 
    const lambda = -C / (sumGradSq + alpha);

    // 5. Apply Position Deltas
    for (let i = 0; i < particles.length; i++) {
        if (particles[i].invMass === 0) continue;
        const w = particles[i].invMass;
        
        particles[i].x += lambda * w * grads[i*3];
        particles[i].y += lambda * w * grads[i*3+1];
        particles[i].z += lambda * w * grads[i*3+2];
    }
}

function solveDistanceConstraints(dt) {
    for (let i = constraints.length - 1; i >= 0; i--) {
        const c = constraints[i];
        const p1 = particles[c.p1];
        const p2 = particles[c.p2];

        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const dz = p2.z - p1.z;
        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

        if (dist === 0) continue;

        // Tearing logic
        if (dist > c.restLen * TEAR_THRESHOLD) {
            constraints.splice(i, 1); // Remove spring (Explosion effect)
            continue;
        }

        const correction = (dist - c.restLen) / dist;
        const w1 = p1.invMass;
        const w2 = p2.invMass;
        const wSum = w1 + w2;
        
        if (wSum === 0) continue;

        // XPBD Spring compliance (stiffness)
        // compliance = alpha / dt^2. We use a simple stiff constraint (alpha=0) here for "skin"
        // standard PBD projection:
        const px = dx * correction * (w1 / wSum);
        const py = dy * correction * (w1 / wSum);
        const pz = dz * correction * (w1 / wSum);
        
        const qx = dx * correction * (w2 / wSum);
        const qy = dy * correction * (w2 / wSum);
        const qz = dz * correction * (w2 / wSum);

        p1.x += px; p1.y += py; p1.z += pz;
        p2.x -= qx; p2.y -= qy; p2.z -= qz;
    }
}

function updatePhysics() {
    const subDt = DT / SUBSTEPS;

    for (let s = 0; s < SUBSTEPS; s++) {
        // 1. Prediction & External Forces
        for (let p of particles) {
            if (p.invMass === 0) continue;

            // Gravity
            const fy = -9.8 * p.invMass; 
            
            // Integrate Velocity: v = v + a * dt
            // We store velocity implicitly via old positions usually, 
            // but explicit help for gravity
            let vy = (p.y - p.oldY) / subDt + (-9.8 * subDt);
            let vx = (p.x - p.oldX) / subDt;
            let vz = (p.z - p.oldZ) / subDt;

            // Dampening
            vx *= 0.999; vy *= 0.999; vz *= 0.999;

            p.oldX = p.x;
            p.oldY = p.y;
            p.oldZ = p.z;

            // Prediction: x = x + v * dt
            p.x += vx * subDt;
            p.y += vy * subDt;
            p.z += vz * subDt;

            // Simple floor collision
            if (p.y < -2) {
                p.y = -2;
                // friction
                p.oldX += (p.x - p.oldX) * 0.1;
                p.oldZ += (p.z - p.oldZ) * 0.1;
            }
        }

        // 2. Solve Constraints
        solveVolumeConstraint(subDt);
        solveDistanceConstraints(subDt);
    }
}

function syncMesh() {
    const positions = meshRef.geometry.attributes.position.array;
    for (let i = 0; i < particles.length; i++) {
        positions[i * 3] = particles[i].x;
        positions[i * 3 + 1] = particles[i].y;
        positions[i * 3 + 2] = particles[i].z;
    }
    meshRef.geometry.attributes.position.needsUpdate = true;
    meshRef.geometry.computeVertexNormals();
}

// --- INITIALIZATION ---

function initPhysicsMesh(geometry) {
    // 1. Create Particles
    const posAttr = geometry.attributes.position;
    particles = [];
    
    // Merge vertices to ensure mesh is "watertight" for volume constraint
    // Three.js geometries often duplicate vertices for UV seams. 
    geometry.deleteAttribute('normal');
    geometry.deleteAttribute('uv');
    geometry = THREE.BufferGeometryUtils.mergeVertices(geometry);
    
    const positions = geometry.attributes.position.array;

    for (let i = 0; i < positions.length; i += 3) {
        particles.push({
            x: positions[i],
            y: positions[i+1],
            z: positions[i+2],
            oldX: positions[i],
            oldY: positions[i+1],
            oldZ: positions[i+2],
            invMass: 1.0 // Simple mass
        });
    }

    // 2. Create Distance Constraints (Edges)
    constraints = [];
    // Helper to find edges from triangles
    const indices = geometry.index.array;
    const edges = new Set();
    faces = [];

    for (let i = 0; i < indices.length; i += 3) {
        const a = indices[i];
        const b = indices[i+1];
        const c = indices[i+2];

        faces.push([a, b, c]);

        // Add unique edges
        const e1 = [Math.min(a,b), Math.max(a,b)].toString();
        const e2 = [Math.min(b,c), Math.max(b,c)].toString();
        const e3 = [Math.min(c,a), Math.max(c,a)].toString();

        [e1, e2, e3].forEach((eKey, idx) => {
            if(!edges.has(eKey)) {
                edges.add(eKey);
                const [p1, p2] = eKey.split(',').map(Number);
                const dist = Math.sqrt(
                    Math.pow(particles[p1].x - particles[p2].x, 2) + 
                    Math.pow(particles[p1].y - particles[p2].y, 2) + 
                    Math.pow(particles[p1].z - particles[p2].z, 2)
                );
                constraints.push({ p1, p2, restLen: dist });
            }
        });
    }

    // 3. Setup Mesh for Rendering
    const material = new THREE.MeshStandardMaterial({ 
        color: 0xffaa00, 
        roughness: 0.4,
        metalness: 0.1,
        wireframe: false,
        side: THREE.DoubleSide
    });
    
    meshRef = new THREE.Mesh(geometry, material);
    meshRef.castShadow = true;
    scene.add(meshRef);

    // Initial Volume for Rest Length
    initialVolume = getVolume();
    
    document.getElementById('stats').innerText = `Vertices: ${particles.length} | Constraints: ${constraints.length}`;
}

// Start
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
THREE.BufferGeometryUtils = BufferGeometryUtils; // Hack for module scope

// =========================================================
// REPLACE THIS GEOMETRY WITH THE STANFORD BUNNY IF DESIRED
// You would use OBJLoader to load 'bunny.obj', calculate volume,
// and pass geometry to initPhysicsMesh.
// =========================================================
const geometry = new THREE.IcosahedronGeometry(1.5, 3); 
initPhysicsMesh(geometry);

// --- UI LOGIC ---
const pRange = document.getElementById('pressureRange');
pRange.addEventListener('input', (e) => {
    targetVolumeScale = parseFloat(e.target.value);
});

document.getElementById('explodeBtn').addEventListener('click', () => {
    // Massive pressure spike
    targetVolumeScale = 8.0; 
    pRange.value = 8.0;
    // We rely on the "TEAR_THRESHOLD" in solveDistanceConstraints to break the mesh
});

// --- ANIMATION LOOP ---
function animate() {
    requestAnimationFrame(animate);
    
    updatePhysics();
    syncMesh();
    
    controls.update();
    renderer.render(scene, camera);
}
animate();

// Handle Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>

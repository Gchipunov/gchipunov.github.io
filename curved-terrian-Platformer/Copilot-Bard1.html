<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL 2D Platformer: Fixed & Optimized</title>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; margin: 20px auto; background: #222; box-shadow: 0 0 20px rgba(0,0,0,0.5); border-radius: 4px; }
        #ui { position: absolute; top: 20px; left: 20px; color: #eee; pointer-events: none; }
        h1 { margin: 0 0 10px 0; font-size: 18px; color: #ff9800; }
        p { margin: 4px 0; font-size: 14px; opacity: 0.8; }
        .controls { margin-top: 10px; font-size: 12px; color: #aaa; }
    </style>
</head>
<body>

<div id="ui">
    <h1>Curved Terrain Engine</h1>
    <div id="debug">Initializing...</div>
    <div class="controls">
        Controls: <b>Arrow Keys / WASD</b> to Move & Jump<br>
        Hold direction to run.
    </div>
</div>

<canvas id="glcanvas" width="900" height="500"></canvas>

<script type="text/javascript">
/*
    WebGL 2D Platformer - Fixed Version
    - Fixed memory leaks (buffers created once, not per frame)
    - Corrected attribute pointer binding order
    - Improved physics integration on slopes
*/

// --- WebGL Context Setup ---
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');

if (!gl) { alert('WebGL not supported'); }

// --- Shader Sources ---

const vertexShaderSrc = `
attribute vec2 aPosition;
attribute vec3 aColor;
attribute vec2 aNormal;
uniform mat4 uProjection;
varying vec3 vColor;
varying vec2 vNormal;
void main() {
    gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);
    vColor = aColor;
    vNormal = aNormal;
}
`;

const fragmentShaderSrc = `
precision mediump float;
varying vec3 vColor;
varying vec2 vNormal;
void main() {
    // Simple lighting based on normal Y (top down light)
    float light = 0.6 + 0.4 * vNormal.y;
    gl_FragColor = vec4(vColor * light, 1.0);
}
`;

// --- Shader Compilation ---

function compileShader(src, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

const vShader = compileShader(vertexShaderSrc, gl.VERTEX_SHADER);
const fShader = compileShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, vShader);
gl.attachShader(program, fShader);
gl.linkProgram(program);
gl.useProgram(program);

// --- Locations ---
const aPositionLoc = gl.getAttribLocation(program, 'aPosition');
const aColorLoc = gl.getAttribLocation(program, 'aColor');
const aNormalLoc = gl.getAttribLocation(program, 'aNormal');
const uProjectionLoc = gl.getUniformLocation(program, 'uProjection');

// --- Projection (Orthographic) ---
// 0,0 at top-left
const proj = new Float32Array([
    2/canvas.width, 0, 0, 0,
    0, -2/canvas.height, 0, 0,
    0, 0, -1, 0,
    -1, 1, 0, 1
]);
gl.uniformMatrix4fv(uProjectionLoc, false, proj);

// --- Math Utilities ---

const terrainCurve = [
    { x: 50, y: 400 },
    { x: 300, y: 450 },
    { x: 600, y: 150 },
    { x: 850, y: 400 }
];

function cubicBezier(t, p0, p1, p2, p3) {
    const u = 1 - t;
    const tt = t*t, uu = u*u;
    const uuu = uu * u, ttt = tt * t;
    return {
        x: uuu*p0.x + 3*uu*t*p1.x + 3*u*tt*p2.x + ttt*p3.x,
        y: uuu*p0.y + 3*uu*t*p1.y + 3*u*tt*p2.y + ttt*p3.y
    };
}

function cubicBezierTangent(t, p0, p1, p2, p3) {
    const u = 1 - t;
    return {
        x: -3*u*u*p0.x + 3*(u*u - 2*u*t)*p1.x + 3*(2*u*t - t*t)*p2.x + 3*t*t*p3.x,
        y: -3*u*u*p0.y + 3*(u*u - 2*u*t)*p1.y + 3*(2*u*t - t*t)*p2.y + 3*t*t*p3.y
    };
}

function cubicBezierNormal(t, p0, p1, p2, p3) {
    const tan = cubicBezierTangent(t, p0, p1, p2, p3);
    const len = Math.sqrt(tan.x*tan.x + tan.y*tan.y);
    return { x: -tan.y/len, y: tan.x/len };
}

// Optimized closest point search
function closestTOnCurve(px, py, curve) {
    let minDist = Infinity, minT = 0;
    const steps = 60; 
    // Coarse search
    for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const pt = cubicBezier(t, ...curve);
        const d = (px - pt.x)**2 + (py - pt.y)**2;
        if (d < minDist) { minDist = d; minT = t; }
    }
    // Refine search (Binary)
    let start = Math.max(0, minT - 1/steps);
    let end = Math.min(1, minT + 1/steps);
    for(let i=0; i<10; i++){
        const mid = (start + end)/2;
        const pt = cubicBezier(mid, ...curve);
        const d = (px - pt.x)**2 + (py - pt.y)**2;
        const ptLeft = cubicBezier(start, ...curve);
        const dLeft = (px - ptLeft.x)**2 + (py - ptLeft.y)**2;
        if(dLeft < d) end = mid; else start = mid;
    }
    return (start + end) / 2;
}

// --- Data Generation ---

// 1. Terrain Mesh
const terrainSegments = 100;
let terrainVertices = [];
for (let i = 0; i < terrainSegments; ++i) {
    const t0 = i / terrainSegments;
    const t1 = (i+1) / terrainSegments;
    const p0 = cubicBezier(t0, ...terrainCurve);
    const p1 = cubicBezier(t1, ...terrainCurve);
    const n0 = cubicBezierNormal(t0, ...terrainCurve);
    const n1 = cubicBezierNormal(t1, ...terrainCurve);
    const thk = 40; // Thickness

    // Format: X, Y, R, G, B, Nx, Ny
    // Top Edge (Lighter)
    const colorTop = [0.4, 0.8, 0.5]; 
    const colorBot = [0.2, 0.5, 0.3];

    terrainVertices.push(
        p0.x, p0.y, ...colorTop, n0.x, n0.y,
        p1.x, p1.y, ...colorTop, n1.x, n1.y,
        p1.x, p1.y + thk, ...colorBot, n1.x, n1.y,
        p0.x, p0.y + thk, ...colorBot, n0.x, n0.y
    );
}

// 2. Buffer Creation (Done ONCE, not in render loop)
const terrainBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(terrainVertices), gl.STATIC_DRAW);

const playerBuffer = gl.createBuffer();
// We will update player data dynamically, but we create the handle here.

// --- Game Logic ---

const player = {
    x: 50, y: 300,
    vx: 0, vy: 0,
    radius: 12,
    grounded: false,
    color: [1.0, 0.6, 0.2]
};

const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

const FIXED_DT = 1/60;
let accumulator = 0;
let lastTime = performance.now();

function updatePhysics(dt) {
    // Input
    const left = keys['ArrowLeft'] || keys['a'];
    const right = keys['ArrowRight'] || keys['d'];
    const jump = keys['ArrowUp'] || keys['w'] || keys[' '];

    const acc = 1500;
    const fric = 1000;
    const maxSpeed = 300;
    
    // Horizontal Movement
    if (left) player.vx -= acc * dt;
    if (right) player.vx += acc * dt;
    
    // Friction
    if (!left && !right) {
        if (player.vx > 0) player.vx = Math.max(0, player.vx - fric * dt);
        if (player.vx < 0) player.vx = Math.min(0, player.vx + fric * dt);
    }
    
    // Clamp Speed
    player.vx = Math.max(-maxSpeed, Math.min(maxSpeed, player.vx));

    // Gravity
    player.vy += 1200 * dt;

    // Apply Velocity
    let nextX = player.x + player.vx * dt;
    let nextY = player.y + player.vy * dt;

    // Collision with Curve
    const t = closestTOnCurve(nextX, nextY, terrainCurve);
    const curvePos = cubicBezier(t, ...terrainCurve);
    const normal = cubicBezierNormal(t, ...terrainCurve);

    // Vector from curve to player
    const distVec = { x: nextX - curvePos.x, y: nextY - curvePos.y };
    // Projection of distVec onto normal
    const distNormal = distVec.x * normal.x + distVec.y * normal.y;

    player.grounded = false;

    // Collision Detection (Snap to surface)
    // If we are close enough to the surface and moving downwards relative to it
    if (distNormal < player.radius && distNormal > -player.radius && player.vy > -100) {
        
        // 1. Snap Position
        nextX = curvePos.x + normal.x * player.radius;
        nextY = curvePos.y + normal.y * player.radius;
        
        // 2. Project Velocity onto Tangent (Slide along surface)
        const tan = { x: normal.y, y: -normal.x }; // Rotate normal 90deg
        // Dot product of velocity and tangent
        const vDotTan = player.vx * tan.x + player.vy * tan.y;
        
        player.vx = tan.x * vDotTan;
        player.vy = tan.y * vDotTan;
        
        player.grounded = true;

        // Jump
        if (jump) {
            player.vy -= 500; // Jump impulse
            // Push slightly away from normal to prevent immediate re-snap
            player.x += normal.x * 2; 
            player.y += normal.y * 2;
            player.grounded = false;
        }
    }

    // World Bounds
    if (nextY > canvas.height + 50) { // Reset if fallen
        nextX = 50; nextY = 300; player.vx=0; player.vy=0;
    }

    player.x = nextX;
    player.y = nextY;
}

// --- Rendering ---

function render() {
    // 1. Setup Frame
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.enableVertexAttribArray(aPositionLoc);
    gl.enableVertexAttribArray(aColorLoc);
    gl.enableVertexAttribArray(aNormalLoc);

    // 2. Draw Terrain
    // Bind the specific buffer for terrain
    gl.bindBuffer(gl.ARRAY_BUFFER, terrainBuffer);
    
    // Set pointers relative to CURRENTLY bound buffer
    const stride = 7 * 4; // 7 floats * 4 bytes
    gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(aNormalLoc, 2, gl.FLOAT, false, stride, 5 * 4);

    for (let i = 0; i < terrainSegments; ++i) {
        gl.drawArrays(gl.TRIANGLE_FAN, i * 4, 4);
    }

    // 3. Draw Player
    // Generate player geometry (Circle)
    const pVerts = [];
    const segs = 30;
    // Center point
    pVerts.push(player.x, player.y, ...player.color, 0, 1); 
    for(let i=0; i<=segs; i++) {
        const theta = (i/segs) * Math.PI * 2;
        pVerts.push(
            player.x + Math.cos(theta)*player.radius,
            player.y + Math.sin(theta)*player.radius,
            ...player.color,
            0, 1
        );
    }

    // Bind Player Buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, playerBuffer);
    // Use DYNAMIC_DRAW because content changes every frame
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pVerts), gl.DYNAMIC_DRAW);

    // Reset pointers for Player Buffer layout (Same stride 7, but different data source)
    gl.vertexAttribPointer(aPositionLoc, 2, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(aColorLoc, 3, gl.FLOAT, false, stride, 2 * 4);
    gl.vertexAttribPointer(aNormalLoc, 2, gl.FLOAT, false, stride, 5 * 4);

    gl.drawArrays(gl.TRIANGLE_FAN, 0, segs + 2);

    // 4. Update Debug UI
    document.getElementById('debug').innerHTML = 
        `Pos: ${player.x.toFixed(0)}, ${player.y.toFixed(0)} <br>` +
        `Vel: ${player.vx.toFixed(0)}, ${player.vy.toFixed(0)} <br>` +
        `State: ${player.grounded ? "Grounded" : "Air"}`;
}

// --- Main Loop ---

function gameLoop(now) {
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    // Cap dt to prevent explosion on tab switch
    let safeDt = Math.min(dt, 0.1); 

    accumulator += safeDt;
    while (accumulator >= FIXED_DT) {
        updatePhysics(FIXED_DT);
        accumulator -= FIXED_DT;
    }

    render();
    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

</script>
</body>
</html>

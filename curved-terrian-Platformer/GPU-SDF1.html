<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL GPGPU Platformer: SDF & Ping-Pong Physics</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; color: #aaa; font-family: monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #overlay { position: absolute; top: 10px; left: 10px; pointer-events: none; }
        h1 { margin: 0; color: #fff; font-size: 16px; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>GPU-Based SDF Platformer</h1>
        <p>Controls: Arrow Keys / WASD</p>
        <p>Tech: WebGL 1.0, GPGPU Ping-Pong Buffers, SDF Collision</p>
    </div>
    <canvas id="glcanvas"></canvas>

<script id="vs-quad" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_uv;
    void main() {
        v_uv = a_position * 0.5 + 0.5; // Map -1..1 to 0..1
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
</script>

<script id="fs-sdf-gen" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_uv;
    uniform vec2 u_res;

    // Bezier control points hardcoded for the demo
    // P0, P1, P2, P3
    const vec2 p0 = vec2(0.0, 0.5);
    const vec2 p1 = vec2(0.3, 0.2);
    const vec2 p2 = vec2(0.7, 0.8);
    const vec2 p3 = vec2(1.0, 0.5);

    // Iterative distance to cubic bezier
    float distToBezier(vec2 pos) {
        float minDist = 100.0;
        // Discretize curve into segments to approximate SDF
        // (Analytical solution is too heavy for WebGL1 Loop limits)
        for(int i = 0; i < 50; i++) {
            float t = float(i) / 49.0;
            float t2 = t * t;
            float t3 = t2 * t;
            float mt = 1.0 - t;
            float mt2 = mt * mt;
            float mt3 = mt2 * mt;

            vec2 p = mt3*p0 + 3.0*mt2*t*p1 + 3.0*mt*t2*p2 + t3*p3;
            
            // Adjust Aspect Ratio for distance calculation
            vec2 diff = p - pos;
            diff.x *= (u_res.x / u_res.y); 
            
            float d = length(diff);
            if(d < minDist) minDist = d;
        }
        return minDist;
    }

    void main() {
        // We output the distance in the Red channel
        // Also a gradient for the "Ground" in Green
        float d = distToBezier(v_uv);
        
        // Signed distance: We treat "below" the curve as solid.
        // Simple hack: if y is greater than curve y at x? 
        // For this demo, we just use the distance boundary.
        
        gl_FragColor = vec4(d, 0.0, 0.0, 1.0);
    }
</script>

<script id="fs-physics" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_uv;
    
    uniform sampler2D u_prev_state; // Input Texture (Previous Frame)
    uniform sampler2D u_sdf;        // Terrain SDF
    uniform vec2 u_res;
    uniform vec2 u_input;           // x = horiz, y = jump
    uniform float u_dt;
    uniform float u_reset;          // 1.0 if reset needed

    // Player constants
    const float GRAVITY = 1.8;
    const float ACCEL = 3.0;
    const float FRICTION = 0.90;
    const float JUMP_FORCE = 0.8;
    const float RADIUS = 0.02;      // Player radius in UV space

    void main() {
        // Read previous frame data
        vec4 data = texture2D(u_prev_state, v_uv);
        vec2 pos = data.xy;
        vec2 vel = data.zw;

        if (u_reset > 0.5) {
            pos = vec2(0.1, 0.8); // Spawn point
            vel = vec2(0.0, 0.0);
        } else {
            // 1. Apply Forces
            vel.x += u_input.x * ACCEL * u_dt;
            vel.y += GRAVITY * u_dt; // Positive y is down in UV usually, depending on setup
            vel.x *= FRICTION;

            // 2. Predict next position
            vec2 nextPos = pos + vel * u_dt;

            // 3. SDF Collision Detection
            // Sample SDF at predicted position
            vec4 sdfData = texture2D(u_sdf, nextPos);
            float dist = sdfData.r;

            // Correct aspect ratio for radius check
            float aspect = u_res.x / u_res.y;
            float trueDist = dist; // Simplified for this view

            if (trueDist < RADIUS) {
                // COLLISION DETECTED
                
                // Calculate Normal using finite difference on the SDF texture
                float eps = 1.0 / u_res.x;
                float dx = texture2D(u_sdf, nextPos + vec2(eps, 0.0)).r - texture2D(u_sdf, nextPos - vec2(eps, 0.0)).r;
                float dy = texture2D(u_sdf, nextPos + vec2(0.0, eps)).r - texture2D(u_sdf, nextPos - vec2(0.0, eps)).r;
                vec2 normal = normalize(vec2(dx, dy));

                // Push out
                nextPos += normal * (RADIUS - trueDist);
                
                // Reflect velocity (bounce/slide)
                float vDotN = dot(vel, normal);
                if (vDotN < 0.0) {
                    vel -= normal * vDotN * 1.2; // 1.2 for slight bounce/friction fix
                }
                
                // Jump Logic (Ground detection via normal)
                // If normal points up (negative Y in UV space roughly, or towards center)
                if (normal.y < -0.5 && u_input.y > 0.5) {
                     vel.y = -JUMP_FORCE;
                }
            }

            // Screen Boundaries
            if(nextPos.x < 0.0) { nextPos.x = 0.0; vel.x *= -0.5; }
            if(nextPos.x > 1.0) { nextPos.x = 1.0; vel.x *= -0.5; }
            if(nextPos.y > 1.0) { nextPos = vec2(0.1, 0.7); vel = vec2(0,0); } // Reset on fall

            pos = nextPos;
        }

        // Write new state
        gl_FragColor = vec4(pos, vel);
    }
</script>

<script id="fs-render" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_uv;

    uniform sampler2D u_state; // Current Physics State
    uniform sampler2D u_sdf;   // Terrain SDF
    uniform vec2 u_res;

    void main() {
        // 1. Draw Terrain
        float dist = texture2D(u_sdf, v_uv).r;
        vec3 color = vec3(0.1);
        
        // Create isolines/grid for curved terrain effect
        float grid = abs(sin(dist * 200.0));
        
        // Fill terrain (assuming solid below specific distance or just a thick line)
        // Here we draw a thick glowing line for the platform
        float thickness = 0.005;
        float glow = 0.02 / abs(dist - thickness);
        color += vec3(0.2, 0.6, 1.0) * glow;
        
        if (dist < thickness) {
            color = vec3(0.1, 0.4, 0.8);
        }

        // 2. Draw Player
        // We fetch the player position from the physics texture.
        // Note: fetch at (0,0) or center of texture because physics texture 
        // is uniform for the whole screen (or 1x1 pixel logically).
        // Since we are using a viewport quad, we just sample the middle.
        vec4 pState = texture2D(u_state, vec2(0.5, 0.5));
        vec2 pPos = pState.xy;

        // Calculate distance from current pixel to player position
        vec2 diff = v_uv - pPos;
        diff.x *= (u_res.x / u_res.y); // Aspect correction
        float distToPlayer = length(diff);
        float pRadius = 0.02;

        if (distToPlayer < pRadius) {
            color = vec3(1.0, 0.5, 0.2); // Player Color (Orange)
            // Simple shading
            color += vec3(0.2) * (1.0 - distToPlayer/pRadius);
        }

        gl_FragColor = vec4(color, 1.0);
    }
</script>

<script>
    // --- WebGL Setup ---
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) alert("WebGL not supported");

    // Enable Float Textures (Critical for Physics Simulation)
    const ext = gl.getExtension('OES_texture_float');
    if (!ext) alert("Your browser/GPU does not support OES_texture_float. Physics will fail.");

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Shader Compiler ---
    function createShader(gl, sourceId, type) {
        const src = document.getElementById(sourceId).text;
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(sh));
            return null;
        }
        return sh;
    }

    function createProgram(gl, vsId, fsId) {
        const vs = createShader(gl, vsId, gl.VERTEX_SHADER);
        const fs = createShader(gl, fsId, gl.FRAGMENT_SHADER);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        return prog;
    }

    const progSDF = createProgram(gl, 'vs-quad', 'fs-sdf-gen');
    const progPhys = createProgram(gl, 'vs-quad', 'fs-physics');
    const progRender = createProgram(gl, 'vs-quad', 'fs-render');

    // --- Geometry (Full Screen Quad) ---
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  1, -1, -1,  1,
        -1,  1,  1, -1,  1,  1
    ]), gl.STATIC_DRAW);

    // --- Texture & FBO Utilities ---
    function createTexture(width, height) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        // Float texture for precision physics
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);
        return tex;
    }

    // --- Framebuffer Setup ---
    // 1. SDF Texture (Static)
    const texSDF = createTexture(1024, 1024); // High res for SDF
    const fboSDF = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboSDF);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texSDF, 0);

    // 2. Physics Ping-Pong Buffers
    // We only need 1x1 pixel ideally, but we make it small (e.g., 4x4) to avoid edge cases
    const simRes = 4;
    const texPhysA = createTexture(simRes, simRes);
    const texPhysB = createTexture(simRes, simRes);
    
    const fboPhysA = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPhysA);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texPhysA, 0);

    const fboPhysB = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboPhysB);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texPhysB, 0);

    // --- Input Handling ---
    const keys = { Left: 0, Right: 0, Up: 0 };
    window.addEventListener('keydown', e => {
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.Left = 1;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.Right = 1;
        if(e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.Up = 1;
    });
    window.addEventListener('keyup', e => {
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.Left = 0;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.Right = 0;
        if(e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.Up = 0;
    });

    // --- Initialization Pass: Generate SDF ---
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboSDF);
    gl.viewport(0, 0, 1024, 1024);
    gl.useProgram(progSDF);
    
    const locPos = gl.getAttribLocation(progSDF, 'a_position');
    gl.enableVertexAttribArray(locPos);
    gl.vertexAttribPointer(locPos, 2, gl.FLOAT, false, 0, 0);
    
    gl.uniform2f(gl.getUniformLocation(progSDF, 'u_res'), 1024, 1024);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // --- Main Loop ---
    let lastTime = 0;
    let pingPong = false; // Toggle between A and B
    let firstFrame = true;

    function render(now) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;

        // 1. PHYSICS PASS
        // Render into the destination FBO (Write), reading from source Texture (Read)
        const fboDest = pingPong ? fboPhysA : fboPhysB;
        const texSrc = pingPong ? texPhysB : texPhysA;

        gl.bindFramebuffer(gl.FRAMEBUFFER, fboDest);
        gl.viewport(0, 0, simRes, simRes);
        gl.useProgram(progPhys);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texSrc);
        gl.uniform1i(gl.getUniformLocation(progPhys, 'u_prev_state'), 0);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, texSDF);
        gl.uniform1i(gl.getUniformLocation(progPhys, 'u_sdf'), 1);

        gl.uniform2f(gl.getUniformLocation(progPhys, 'u_res'), canvas.width, canvas.height);
        gl.uniform2f(gl.getUniformLocation(progPhys, 'u_input'), keys.Right - keys.Left, keys.Up);
        gl.uniform1f(gl.getUniformLocation(progPhys, 'u_dt'), dt);
        gl.uniform1f(gl.getUniformLocation(progPhys, 'u_reset'), firstFrame ? 1.0 : 0.0);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // 2. RENDER PASS
        // Render to screen, reading from the DESTINATION texture of the physics pass
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.useProgram(progRender);

        // Bind the physics texture we just wrote to
        const texState = pingPong ? texPhysA : texPhysB;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texState);
        gl.uniform1i(gl.getUniformLocation(progRender, 'u_state'), 0);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, texSDF);
        gl.uniform1i(gl.getUniformLocation(progRender, 'u_sdf'), 1);

        gl.uniform2f(gl.getUniformLocation(progRender, 'u_res'), canvas.width, canvas.height);

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        pingPong = !pingPong;
        firstFrame = false;
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebGL 2D Platformer: Curved Terrain Demo</title>
  <style>
    body { margin: 0; background: #222; }
    canvas { display: block; margin: 0 auto; background: #222; }
    #debug { position: absolute; top: 10px; left: 10px; color: #fff; font: 14px monospace; }
  </style>
</head>
<body>
<canvas id="glcanvas" width="900" height="500"></canvas>
<div id="debug"></div>
<script type="text/javascript">
// --- WebGL Setup ---
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
if (!gl) alert('WebGL not supported');

// --- Shader Sources ---
const vertexShaderSrc = `
attribute vec2 aPosition;
attribute vec3 aColor;
attribute vec2 aNormal;
uniform mat4 uProjection;
varying vec3 vColor;
varying vec2 vNormal;
void main() {
    gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);
    vColor = aColor;
    vNormal = aNormal;
}
`;

const fragmentShaderSrc = `
precision mediump float;
varying vec3 vColor;
varying vec2 vNormal;
void main() {
    float shade = 0.5 + 0.5 * vNormal.y;
    gl_FragColor = vec4(vColor * shade, 1.0);
}
`;

// --- Shader Compilation ---
function compileShader(src, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
  }
  return shader;
}
const vs = compileShader(vertexShaderSrc, gl.VERTEX_SHADER);
const fs = compileShader(fragmentShaderSrc, gl.FRAGMENT_SHADER);

// --- Program ---
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  throw new Error('Program link error: ' + gl.getProgramInfoLog(program));
}
gl.useProgram(program);

// --- Projection Matrix (orthographic) ---
function ortho(left, right, bottom, top, near, far) {
  return new Float32Array([
    2/(right-left), 0, 0, 0,
    0, 2/(top-bottom), 0, 0,
    0, 0, -2/(far-near), 0,
    -(right+left)/(right-left), -(top+bottom)/(top-bottom), -(far+near)/(far-near), 1
  ]);
}
const uProjection = gl.getUniformLocation(program, 'uProjection');
gl.uniformMatrix4fv(uProjection, false, ortho(0, canvas.width, canvas.height, 0, -1, 1));

// --- Geometry: simple curved terrain strip ---
const positions = [];
const colors = [];
const normals = [];
for (let x = 0; x <= 900; x += 20) {
  const y = 250 + 100 * Math.sin(x * 0.01); // curved terrain
  // top vertex
  positions.push(x, y);
  colors.push(0.2, 0.8, 0.2);
  normals.push(0, 1);
  // bottom vertex
  positions.push(x, 500);
  colors.push(0.1, 0.3, 0.1);
  normals.push(0, -1);
}
const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

const colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

const normalBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

// --- Attribute Setup ---
const aPosition = gl.getAttribLocation(program, 'aPosition');
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aPosition);

const aColor = gl.getAttribLocation(program, 'aColor');
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aColor);

const aNormal = gl.getAttribLocation(program, 'aNormal');
gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
gl.vertexAttribPointer(aNormal, 2, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aNormal);

// --- Render ---
gl.clearColor(0.1, 0.1, 0.1, 1);
gl.clear(gl.COLOR_BUFFER_BIT);
gl.drawArrays(gl.TRIANGLE_STRIP, 0, positions.length/2);
</script>
</body>
</html>

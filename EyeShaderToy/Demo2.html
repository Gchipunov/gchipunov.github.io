<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Live Editable WebGL Eye Shader</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        canvas { display: block; }
        
        /* Overlay UI */
        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            opacity: 0.7;
            z-index: 1;
        }

        /* Shader Editor Styles */
        #editor-container {
            position: absolute;
            top: 0;
            right: 0;
            width: 400px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            border-left: 1px solid #444;
            z-index: 10;
        }

        #editor-header {
            padding: 10px;
            color: #ccc;
            background: #222;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #codeEditor {
            flex-grow: 1;
            background-color: #111;
            color: #aaddff;
            border: none;
            padding: 10px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            resize: none;
            outline: none;
            white-space: pre;
            overflow: auto;
        }

        #controls {
            padding: 10px;
            background: #222;
            display: flex;
            gap: 10px;
        }

        button {
            background: #2ecc71;
            color: white;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
            flex-grow: 1;
        }

        button:hover { background: #27ae60; }
        
        #status {
            color: #e74c3c;
            font-size: 11px;
            margin-top: 5px;
            display: none;
        }
    </style>
</head>
<body>

<div id="instructions">Move mouse to look â€¢ Edit Shader on the right</div>

<div id="editor-container">
    <div id="editor-header">Fragment Shader (GLSL)</div>
    <textarea id="codeEditor" spellcheck="false"></textarea>
    <div id="controls">
        <div style="width:100%">
            <button id="compileBtn">Update & Compile</button>
            <div id="status"></div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vPosition;

    void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

uniform float uTime;
uniform vec3 uColor;

// --- Noise Functions ---
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
             -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

void main() {
    vec3 viewDir = vec3(0.0, 0.0, 1.0);
    float dotProd = dot(vNormal, viewDir);
    
    // Config
    float pupilSize = 0.98;
    float irisSize = 0.90;
    
    // Colors
    vec3 colorPupil = vec3(0.0, 0.0, 0.0);
    vec3 colorSclera = vec3(0.95, 0.95, 0.98);
    vec3 colorIris = uColor; 

    // Iris Detail
    vec2 centeredPos = vPosition.xy;
    float angle = atan(centeredPos.y, centeredPos.x);
    float radius = length(centeredPos);
    
    float noiseVal = snoise(vec2(angle * 2.0, radius * 10.0));
    colorIris = mix(colorIris, colorIris * 0.5, noiseVal * 0.5 + 0.5);
    
    // Limbal Ring
    float limbal = smoothstep(irisSize, irisSize + 0.05, dotProd);
    colorIris = mix(colorIris * 0.5, colorIris, limbal);

    // Veins
    float veins = snoise(vPosition.xy * 3.0 + vec2(uTime * 0.1));
    colorSclera = mix(colorSclera, vec3(0.9,0.7,0.7), smoothstep(0.6, 0.9, veins) * 0.2);

    // Mixing
    vec3 finalColor;
    float pupilMix = smoothstep(pupilSize - 0.005, pupilSize, dotProd);
    float irisMix = smoothstep(irisSize - 0.01, irisSize, dotProd);

    if (dotProd > pupilSize) finalColor = colorPupil;
    else if (dotProd > irisSize) finalColor = colorIris;
    else finalColor = colorSclera;

    // Specular
    vec3 lightDir = normalize(vec3(1.0, 1.0, 2.0));
    vec3 reflectDir = reflect(-lightDir, vNormal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 30.0);
    finalColor += spec * 0.8;

    gl_FragColor = vec4(finalColor, 1.0);
}
</script>

<script>
    // --- 1. Scene Setup ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- 2. Shader Setup ---
    const initialVert = document.getElementById('vertexShader').textContent;
    const initialFrag = document.getElementById('fragmentShader').textContent;

    // Helper to create material
    function createEyeMaterial(colorHex) {
        return new THREE.ShaderMaterial({
            vertexShader: initialVert,
            fragmentShader: initialFrag,
            uniforms: { 
                uTime: { value: 0.0 },
                uColor: { value: new THREE.Color(colorHex) }
            }
        });
    }

    const materialLeft = createEyeMaterial(0x4488ff);
    const materialRight = createEyeMaterial(0x44ff88);

    const geometry = new THREE.SphereGeometry(1, 64, 64);
    
    const eyeLeft = new THREE.Mesh(geometry, materialLeft);
    eyeLeft.position.x = -1.2;
    scene.add(eyeLeft);

    const eyeRight = new THREE.Mesh(geometry, materialRight);
    eyeRight.position.x = 1.2;
    scene.add(eyeRight);

    // --- 3. Interaction & Editor Logic ---
    const mouse = new THREE.Vector2();
    const editor = document.getElementById('codeEditor');
    const compileBtn = document.getElementById('compileBtn');
    const statusDiv = document.getElementById('status');

    // Load initial code into textarea
    editor.value = initialFrag.trim();

    // Mouse Move
    document.addEventListener('mousemove', (event) => {
        // Only move eyes if not interacting with editor
        if(event.target.tagName !== 'TEXTAREA') {
            mouse.x = (event.clientX - window.innerWidth / 2) / 100;
            mouse.y = (event.clientY - window.innerHeight / 2) / 100;
        }
    });

    // Compile Function
    compileBtn.addEventListener('click', () => {
        const newFragCode = editor.value;
        statusDiv.style.display = 'none';
        statusDiv.innerText = '';

        try {
            // Update both materials
            materialLeft.fragmentShader = newFragCode;
            materialLeft.needsUpdate = true;
            
            materialRight.fragmentShader = newFragCode;
            materialRight.needsUpdate = true;

            // Note: Three.js compiles lazily (on next render). 
            // If GLSL syntax is wrong, it will log errors to the Console (F12).
            console.log("Shader updated. Check console for GLSL errors if mesh disappears.");
        } catch (e) {
            statusDiv.style.display = 'block';
            statusDiv.innerText = "Error: " + e.message;
        }
    });

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 4. Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const elapsedTime = clock.getElapsedTime();

        // Update Uniforms
        materialLeft.uniforms.uTime.value = elapsedTime;
        materialRight.uniforms.uTime.value = elapsedTime;

        // Eye Rotation
        const targetX = Math.max(Math.min(mouse.y * 0.5, 1.0), -1.0);
        const targetY = Math.max(Math.min(mouse.x * 0.5, 1.0), -1.0);

        eyeLeft.rotation.x += (targetX - eyeLeft.rotation.x) * 0.1;
        eyeLeft.rotation.y += (targetY - eyeLeft.rotation.y) * 0.1;

        eyeRight.rotation.x += (targetX - eyeRight.rotation.x) * 0.1;
        eyeRight.rotation.y += (targetY - eyeRight.rotation.y) * 0.1;

        renderer.render(scene, camera);
    }

    animate();
</script>

</body>
</html>

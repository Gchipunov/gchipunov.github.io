<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concrete Commander - WebGL RTS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
        #hud-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 160px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0));
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        .panel {
            background: rgba(20, 30, 40, 0.85);
            border: 2px solid #4a90e2;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            gap: 10px;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        button {
            background: linear-gradient(to bottom, #3a4a5a, #2a3a4a);
            color: white;
            border: 1px solid #5a6a7a;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            width: 100px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            text-transform: uppercase;
        }
        button:hover {
            background: #4a90e2;
            border-color: #7ab0f2;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        button:active {
            transform: translateY(1px);
        }
        button.active {
            background: #4a90e2;
            border-color: #fff;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        .warning-btn {
            border-color: #e2a04a;
            color: #ffddaa;
        }
        .warning-btn:hover {
            background: #e28a4a;
            border-color: #ffc288;
        }
        #info-box {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #4a90e2;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
        }
        #cursor-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
    <!-- Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <div id="info-box">
            <h3>Mission Control</h3>
            <p>1. Select MCV (Yellow Truck)</p>
            <p>2. Toggle "Reverse Gear" to drive backwards</p>
            <p>3. Right Click to Move (Squish Soldiers!)</p>
            <p>4. Click "DEPLOY" to build Base</p>
        </div>

        <div id="hud-bottom">
            <!-- MCV Controls -->
            <div id="panel-mcv" class="panel hidden">
                <div style="color:white; margin-right:10px; width: 100px;">
                    <h3>MCV</h3>
                    <small>Mobile Construction Vehicle</small>
                </div>
                <button id="btn-reverse">
                    <span class="icon">üîÑ</span>
                    Reverse
                </button>
                <button id="btn-deploy">
                    <span class="icon">üèóÔ∏è</span>
                    Deploy
                </button>
            </div>

            <!-- Construction Yard Controls -->
            <div id="panel-base" class="panel hidden">
                <div style="color:white; margin-right:10px; width: 100px;">
                    <h3>Const. Yard</h3>
                    <small>Main Base</small>
                </div>
                <button id="btn-power">
                    <span class="icon">‚ö°</span>
                    Power
                </button>
                <button id="btn-refinery">
                    <span class="icon">üè≠</span>
                    Factory
                </button>
                <button id="btn-silo">
                    <span class="icon">‚ò¢Ô∏è</span>
                    Silo
                </button>
                <button id="btn-undeploy" class="warning-btn">
                    <span class="icon">üöö</span>
                    Pack Up
                </button>
            </div>
        </div>
        <div id="cursor-tooltip"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GAME CONFIGURATION ---
        const COLORS = {
            ground: 0x2a2a2a,
            grid: 0x444444,
            selection: 0x00ff00,
            mcvBody: 0xffaa00,
            base: 0xffcc00,
            power: 0x44ff44,
            factory: 0xff4444,
            silo: 0x8888ff,
            enemy: 0xff3333
        };

        const GRID_SIZE = 100;
        const TILE_SIZE = 5;
        const GRID_DIM = 21;

        // --- GLOBAL VARIABLES ---
        let scene, camera, renderer, controls, raycaster;
        let mouse = new THREE.Vector2();
        let groundPlane;
        
        let navGrid = [];
        let units = [];
        let buildings = [];
        let enemies = []; // Soldier list
        let effects = [];
        let selectedEntity = null;
        let placementMode = null;
        
        // MCV Settings
        let reverseMode = false;

        let clock = new THREE.Clock();

        // --- PATHFINDING UTILITIES ---
        function initGrid() {
            navGrid = new Array(GRID_DIM).fill(0).map(() => new Array(GRID_DIM).fill(false));
        }

        function worldToGrid(x, z) {
            const gx = Math.round((x + (GRID_SIZE/2)) / TILE_SIZE);
            const gz = Math.round((z + (GRID_SIZE/2)) / TILE_SIZE);
            return { x: gx, z: gz };
        }

        function gridToWorld(gx, gz) {
            const wx = (gx * TILE_SIZE) - (GRID_SIZE/2);
            const wz = (gz * TILE_SIZE) - (GRID_SIZE/2);
            return new THREE.Vector3(wx, 0, wz);
        }

        function setObstacle(worldPos, isBlocked) {
            const { x, z } = worldToGrid(worldPos.x, worldPos.z);
            if (x >= 0 && x < GRID_DIM && z >= 0 && z < GRID_DIM) {
                navGrid[x][z] = isBlocked;
            }
        }

        function isWalkable(gx, gz) {
            if (gx < 0 || gx >= GRID_DIM || gz < 0 || gz >= GRID_DIM) return false;
            return !navGrid[gx][gz];
        }

        function findPath(startPos, endPos) {
            const startNode = worldToGrid(startPos.x, startPos.z);
            const endNode = worldToGrid(endPos.x, endPos.z);

            if (!isWalkable(endNode.x, endNode.z)) {
                const offsets = [[0,1], [1,0], [0,-1], [-1,0], [1,1], [-1,-1], [1,-1], [-1,1]];
                let found = false;
                for(let o of offsets) {
                    if(isWalkable(endNode.x + o[0], endNode.z + o[1])) {
                        endNode.x += o[0]; endNode.z += o[1];
                        found = true;
                        break;
                    }
                }
                if (!found) return [];
            }

            const startKey = `${startNode.x},${startNode.z}`;
            const endKey = `${endNode.x},${endNode.z}`;
            if (startKey === endKey) return [endPos];

            let openSet = [];
            let closedSet = new Set();
            let cameFrom = {};
            let gScore = {}; 
            let fScore = {}; 

            gScore[startKey] = 0;
            fScore[startKey] = Math.abs(endNode.x - startNode.x) + Math.abs(endNode.z - startNode.z);
            openSet.push({ x: startNode.x, z: startNode.z, f: fScore[startKey] });

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                const currentKey = `${current.x},${current.z}`;

                if (currentKey === endKey) {
                    return reconstructPath(cameFrom, currentKey);
                }

                closedSet.add(currentKey);

                const neighbors = [
                    { x: current.x + 1, z: current.z }, { x: current.x - 1, z: current.z },
                    { x: current.x, z: current.z + 1 }, { x: current.x, z: current.z - 1 }
                ];

                for (let neighbor of neighbors) {
                    const nKey = `${neighbor.x},${neighbor.z}`;
                    if (closedSet.has(nKey)) continue;
                    if (!isWalkable(neighbor.x, neighbor.z)) continue;

                    const tentativeG = gScore[currentKey] + 1;
                    if (tentativeG < (gScore[nKey] || Infinity)) {
                        cameFrom[nKey] = current;
                        gScore[nKey] = tentativeG;
                        fScore[nKey] = tentativeG + (Math.abs(endNode.x - neighbor.x) + Math.abs(endNode.z - neighbor.z));
                        if (!openSet.find(n => n.x === neighbor.x && n.z === neighbor.z)) {
                            openSet.push({ x: neighbor.x, z: neighbor.z, f: fScore[nKey] });
                        }
                    }
                }
            }
            return [];
        }

        function reconstructPath(cameFrom, currentKey) {
            const path = [];
            while (cameFrom[currentKey]) {
                const node = cameFrom[currentKey];
                const parts = currentKey.split(',').map(Number);
                path.unshift(gridToWorld(parts[0], parts[1]));
                currentKey = `${node.x},${node.z}`;
            }
            return path;
        }

        // --- INITIALIZATION ---
        function init() {
            initGrid();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101015);
            scene.fog = new THREE.FogExp2(0x101015, 0.008);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-30, 40, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1;
            controls.minDistance = 10;
            controls.maxDistance = 100;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const planeGeometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: COLORS.ground, roughness: 0.8, metalness: 0.2 });
            groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);

            const gridHelper = new THREE.GridHelper(GRID_SIZE, 20, COLORS.grid, COLORS.grid);
            scene.add(gridHelper);

            raycaster = new THREE.Raycaster();

            // Spawn Entities
            spawnMCV(new THREE.Vector3(0, 0, 0));
            
            // Spawn Enemy Soldiers
            for(let i=0; i<15; i++) {
                let x = (Math.random() * 80) - 40;
                let z = (Math.random() * 80) - 40;
                // Avoid spawning in center
                if (Math.abs(x) < 10 && Math.abs(z) < 10) x += 20;
                spawnEnemy(new THREE.Vector3(x, 0, z));
            }

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('contextmenu', (e) => e.preventDefault());

            // UI Listeners
            document.getElementById('btn-deploy').addEventListener('click', deployMCV);
            document.getElementById('btn-undeploy').addEventListener('click', undeployBase); 
            document.getElementById('btn-power').addEventListener('click', () => startPlacement('power'));
            document.getElementById('btn-refinery').addEventListener('click', () => startPlacement('factory'));
            document.getElementById('btn-silo').addEventListener('click', () => startPlacement('silo'));
            
            const btnReverse = document.getElementById('btn-reverse');
            btnReverse.addEventListener('click', () => {
                reverseMode = !reverseMode;
                btnReverse.classList.toggle('active', reverseMode);
            });

            animate();
        }

        // --- ASSETS ---

        function createSelectionRing() {
            const geometry = new THREE.RingGeometry(2.5, 3, 32);
            const material = new THREE.MeshBasicMaterial({ color: COLORS.selection, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = -Math.PI / 2;
            mesh.position.y = 0.1;
            mesh.visible = false;
            return mesh;
        }

        function createMCVMesh() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 4), new THREE.MeshStandardMaterial({ color: COLORS.mcvBody }));
            body.position.y = 1.25; body.castShadow = true; group.add(body);
            const cab = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 1.5), new THREE.MeshStandardMaterial({ color: 0xdd9900 }));
            cab.position.set(0, 1.6, 1.5); cab.castShadow = true; group.add(cab);
            const wind = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.6, 0.1), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            wind.position.set(0, 1.7, 2.26); group.add(wind);
            const mixer = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 3.5, 12), new THREE.MeshStandardMaterial({ color: 0x999999 }));
            mixer.rotation.x = Math.PI / 2; mixer.position.set(0, 2.6, -0.5); mixer.rotation.z = 0.2; mixer.castShadow = true; mixer.name = "mixer"; group.add(mixer);
            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            [[-1.1,0.5,1.5],[1.1,0.5,1.5],[-1.1,0.5,-1.2],[1.1,0.5,-1.2],[-1.1,0.5,-0.2],[1.1,0.5,-0.2]].forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2; w.position.set(...pos); w.castShadow = true; group.add(w);
            });
            return group;
        }

        function createEnemyMesh() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1, 4, 8), new THREE.MeshStandardMaterial({ color: COLORS.enemy }));
            body.position.y = 0.9;
            body.castShadow = true;
            group.add(body);
            // Gun
            const gun = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 1), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            gun.position.set(0.3, 1.2, 0.4);
            group.add(gun);
            return group;
        }

        // --- CLASSES ---

        class Soldier {
            constructor(pos) {
                this.type = 'Soldier';
                this.mesh = createEnemyMesh();
                this.mesh.position.copy(pos);
                scene.add(this.mesh);
                
                this.timer = Math.random() * 10;
                this.target = null;
                this.isDead = false;
            }

            update(dt) {
                if (this.isDead) return;

                // Wander Logic
                this.timer -= dt;
                if (this.timer <= 0) {
                    this.timer = 2 + Math.random() * 3;
                    const angle = Math.random() * Math.PI * 2;
                    this.target = new THREE.Vector3(
                        this.mesh.position.x + Math.cos(angle) * 5,
                        0,
                        this.mesh.position.z + Math.sin(angle) * 5
                    );
                }

                if (this.target) {
                    const dir = new THREE.Vector3().subVectors(this.target, this.mesh.position).normalize();
                    this.mesh.lookAt(this.target);
                    this.mesh.position.add(dir.multiplyScalar(2 * dt));
                    if (this.mesh.position.distanceTo(this.target) < 0.5) this.target = null;
                }
            }

            die() {
                if (this.isDead) return;
                this.isDead = true;
                // Squish animation
                this.mesh.scale.set(1.5, 0.1, 1.5);
                this.mesh.position.y = 0.1;
                
                // Blood splat effect
                createClickEffect(this.mesh.position, 0xaa0000);
                
                // Remove later
                setTimeout(() => {
                    scene.remove(this.mesh);
                    enemies = enemies.filter(e => e !== this);
                }, 2000);
            }
        }

        class MCV {
            constructor(position) {
                this.type = 'MCV';
                this.mesh = createMCVMesh();
                this.mesh.position.copy(position);
                this.selectionRing = createSelectionRing();
                this.mesh.add(this.selectionRing);
                scene.add(this.mesh);
                this.mesh.userData.entity = this;
                
                this.path = [];
                this.speed = 0;
                this.maxSpeed = 10;
                this.acceleration = 15;
                this.turnSpeed = 4.0;
                
                this.isMoving = false;
                this.drivingReverse = false; 
                this.deployed = false;
                this.transforming = false;
            }

            move(targetPoint, inReverse) {
                if (this.transforming || this.deployed) return;
                const newPath = findPath(this.mesh.position, targetPoint);
                if (newPath && newPath.length > 0) {
                    this.path = newPath;
                    this.isMoving = true;
                    this.drivingReverse = inReverse;
                    createClickEffect(this.path[this.path.length-1]);
                }
            }

            update(dt) {
                if (this.transforming) {
                    // Animation Logic from code2
                    const mixer = this.mesh.getObjectByName('mixer');
                    if (mixer) mixer.rotation.y += dt * 5;
                    this.mesh.scale.multiplyScalar(1.01);
                    if (this.mesh.scale.x > 1.5) {
                        this.finishDeploy();
                    }
                    return;
                }

                if (this.deployed) return;

                // Check collisions with soldiers
                enemies.forEach(soldier => {
                    if (soldier.isDead) return;
                    if (this.mesh.position.distanceTo(soldier.mesh.position) < 2.0) {
                        soldier.die();
                    }
                });

                if (this.isMoving && this.path.length > 0) {
                    const nextPoint = this.path[0];
                    const diff = new THREE.Vector3().subVectors(nextPoint, this.mesh.position);
                    diff.y = 0;
                    const dist = diff.length();

                    // Waypoint switching
                    if (dist < 1.0) {
                        this.path.shift();
                        if (this.path.length === 0) {
                            this.isMoving = false;
                            this.speed = 0; // Stop
                            return;
                        }
                    }

                    // Physics / Steering Logic
                    // 1. Determine Target Rotation
                    let targetAngle = Math.atan2(diff.x, diff.z);
                    if (this.drivingReverse) {
                        targetAngle += Math.PI;
                    }

                    // 2. Current Rotation
                    let currentAngle = this.mesh.rotation.y;

                    // 3. Shortest turn logic
                    let rotDiff = targetAngle - currentAngle;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;

                    // 4. Turn towards target
                    const turnAmount = Math.sign(rotDiff) * Math.min(Math.abs(rotDiff), this.turnSpeed * dt);
                    this.mesh.rotation.y += turnAmount;

                    // 5. Accelerate
                    if (this.speed < this.maxSpeed) {
                        this.speed += this.acceleration * dt;
                    }

                    // 6. Apply Velocity based on CAR FACING
                    const moveDir = this.drivingReverse ? -1 : 1;
                    
                    const velocity = new THREE.Vector3(
                        Math.sin(this.mesh.rotation.y),
                        0,
                        Math.cos(this.mesh.rotation.y)
                    ).multiplyScalar(this.speed * moveDir * dt);

                    this.mesh.position.add(velocity);

                    // Suspension bounce
                    this.mesh.position.y = Math.sin(Date.now() * 0.05) * 0.05; 
                }
            }

            deploy() {
                if (this.isMoving || this.deployed) return;
                this.transforming = true;
                // Center on grid before deploying
                this.mesh.position.x = Math.round(this.mesh.position.x);
                this.mesh.position.z = Math.round(this.mesh.position.z);
                
                // Deselect while transforming
                if (selectedEntity === this) deselect();
            }

            finishDeploy() {
                this.transforming = false;
                this.deployed = true;
                
                const pos = this.mesh.position.clone();
                
                // Remove MCV
                scene.remove(this.mesh);
                units = units.filter(u => u !== this);

                // Create Building
                spawnConstructionYard(pos);
            }
            
            setSelected(bool) {
                this.selectionRing.visible = bool;
                if(bool) document.getElementById('panel-mcv').classList.remove('hidden');
                
                // Update button state based on persistent global setting or unit setting
                const btn = document.getElementById('btn-reverse');
                if(bool) btn.classList.toggle('active', reverseMode);
            }
        }

        // Reuse Base/Building logic from before (simplified here for length, assuming standard implementation)
        class ConstructionYard {
            constructor(pos) {
                this.type = 'Base';
                this.mesh = createYardMesh();
                this.mesh.position.copy(pos);
                this.selectionRing = createSelectionRing();
                this.selectionRing.scale.set(1.5,1.5,1);
                this.mesh.add(this.selectionRing);
                scene.add(this.mesh);
                this.mesh.userData.entity = this;
                setObstacle(pos, true);
                this.isPacking = false;
            }
            update(dt) { 
                if(this.isPacking) {
                    this.mesh.scale.subScalar(dt*2);
                    if(this.mesh.scale.x <= 0.1) this.finishPack();
                }
            }
            packUp() { this.isPacking = true; if(selectedEntity===this) deselect(); }
            finishPack() {
                const pos = this.mesh.position.clone();
                setObstacle(pos, false);
                scene.remove(this.mesh);
                buildings = buildings.filter(b=>b!==this);
                const mcv = spawnMCV(pos);
                selectEntity(mcv);
            }
            setSelected(bool) {
                this.selectionRing.visible = bool;
                if(bool) document.getElementById('panel-base').classList.remove('hidden');
            }
        }

        class Building {
            constructor(type, pos) {
                this.type = type;
                this.mesh = createBuildingMesh(type);
                this.mesh.position.copy(pos);
                setObstacle(pos, true);
                this.selectionRing = createSelectionRing();
                this.mesh.add(this.selectionRing);
                scene.add(this.mesh);
                this.mesh.userData.entity = this;
                this.mesh.scale.y = 0.01;
                this.buildProgress = 0;
            }
            update(dt) {
                if(this.buildProgress<1) {
                    this.buildProgress+=dt;
                    this.mesh.scale.y = this.buildProgress;
                    if(this.buildProgress>1) this.mesh.scale.y=1;
                }
            }
            setSelected(bool) { this.selectionRing.visible = bool; }
        }

        function createYardMesh() {
            const g = new THREE.Group();
            const b = new THREE.Mesh(new THREE.BoxGeometry(6,1,6), new THREE.MeshStandardMaterial({color:0x555555}));
            b.position.y=0.5; g.add(b);
            const body = new THREE.Mesh(new THREE.BoxGeometry(4,3,4), new THREE.MeshStandardMaterial({color:COLORS.base}));
            body.position.y=2; g.add(body);
            return g;
        }

        function createBuildingMesh(type) {
            const g = new THREE.Group();
            if(type==='power') {
                const c = new THREE.Mesh(new THREE.CylinderGeometry(1.5,2,4,16), new THREE.MeshStandardMaterial({color:COLORS.power}));
                c.position.y=2; g.add(c);
            } else if (type==='factory') {
                 const b = new THREE.Mesh(new THREE.BoxGeometry(4,2.5,4), new THREE.MeshStandardMaterial({color:COLORS.factory}));
                 b.position.y=1.25; g.add(b);
            } else {
                 const s = new THREE.Mesh(new THREE.SphereGeometry(2,16,16), new THREE.MeshStandardMaterial({color:COLORS.silo}));
                 s.position.y=0; s.scale.y=1.5; g.add(s);
            }
            return g;
        }

        function spawnMCV(pos) { const u = new MCV(pos); units.push(u); return u; }
        function spawnConstructionYard(pos) { const b = new ConstructionYard(pos); buildings.push(b); selectEntity(b); }
        function spawnEnemy(pos) { const e = new Soldier(pos); enemies.push(e); }

        function onPointerDown(event) {
            if(event.target.closest('button')) return;
            mouse.x = (event.clientX/window.innerWidth)*2-1;
            mouse.y = -(event.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);

            if(placementMode && event.button===0) { placeBuilding(); return; }
            if(placementMode && event.button===2) { cancelPlacement(); return; }

            const hits = raycaster.intersectObjects([...units.map(u=>u.mesh), ...buildings.map(b=>b.mesh), groundPlane], true);
            if(hits.length>0) {
                const hit = hits[0];
                let obj = hit.object;
                while(obj.parent && !obj.userData.entity) obj = obj.parent;
                const ent = obj.userData.entity;

                if(event.button===0) {
                    if(ent) selectEntity(ent);
                    else if (hit.object===groundPlane) deselect();
                } else if (event.button===2) {
                    if(selectedEntity && selectedEntity.type==='MCV' && hit.object===groundPlane) {
                        selectedEntity.move(hit.point.clone(), reverseMode);
                    }
                }
            }
        }

        function placeBuilding() {
            if(!placementMode) return;
            const pos = placementMode.mesh.position.clone();
            const gp = worldToGrid(pos.x, pos.z);
            if(!isWalkable(gp.x, gp.z)) { alert("Blocked!"); return; }
            scene.remove(placementMode.mesh);
            placementMode = null;
            buildings.push(new Building(placementMode?.type || 'power', pos)); // Fix ref
            document.body.style.cursor='default';
            document.getElementById('cursor-tooltip').style.display='none';
        }

        function cancelPlacement() {
            if(placementMode) scene.remove(placementMode.mesh);
            placementMode = null;
            document.body.style.cursor='default';
            document.getElementById('cursor-tooltip').style.display='none';
        }

        function selectEntity(e) { deselect(); selectedEntity=e; selectedEntity.setSelected(true); }
        function deselect() { if(selectedEntity) { selectedEntity.setSelected(false); selectedEntity=null; } document.querySelectorAll('.panel').forEach(p=>p.classList.add('hidden')); }
        function deployMCV() { if(selectedEntity?.type==='MCV') selectedEntity.deploy(); }
        function undeployBase() { if(selectedEntity?.type==='Base') selectedEntity.packUp(); }

        function startPlacement(type) {
            if(placementMode) cancelPlacement();
            const g = createBuildingMesh(type);
            g.traverse(c=>{if(c.isMesh){c.material=c.material.clone();c.material.transparent=true;c.material.opacity=0.5;}});
            scene.add(g);
            placementMode = {type:type, mesh:g};
            document.body.style.cursor='crosshair';
            const tt = document.getElementById('cursor-tooltip');
            tt.style.display='block'; tt.innerText="Left Click Place | Right Click Cancel";
        }

        function createClickEffect(pos, color=0xffffff) {
            const g = new THREE.RingGeometry(0.5,1,32);
            const m = new THREE.MeshBasicMaterial({color:color, transparent:true, opacity:0.8, side:THREE.DoubleSide});
            const mesh = new THREE.Mesh(g,m);
            mesh.rotation.x = -Math.PI/2; mesh.position.copy(pos); mesh.position.y=0.1;
            scene.add(mesh);
            effects.push({mesh:mesh, age:0});
        }

        function onPointerMove(e) {
            mouse.x = (e.clientX/window.innerWidth)*2-1;
            mouse.y = -(e.clientY/window.innerHeight)*2+1;
            if(placementMode) {
                raycaster.setFromCamera(mouse,camera);
                const h = raycaster.intersectObject(groundPlane);
                if(h.length>0) {
                    const p = h[0].point;
                    placementMode.mesh.position.set(Math.round(p.x/5)*5, 0, Math.round(p.z/5)*5);
                }
            }
            const tt = document.getElementById('cursor-tooltip');
            if(tt.style.display==='block') { tt.style.left=e.clientX+15+'px'; tt.style.top=e.clientY+15+'px'; }
        }

        function onWindowResize() {
            camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            units.forEach(u=>u.update(dt));
            buildings.forEach(b=>b.update(dt));
            enemies.forEach(e=>e.update(dt));
            for(let i=effects.length-1; i>=0; i--) {
                const f = effects[i]; f.age+=dt; f.mesh.scale.addScalar(dt*2); f.mesh.material.opacity-=dt*2;
                if(f.age>0.5) { scene.remove(f.mesh); effects.splice(i,1); }
            }
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>

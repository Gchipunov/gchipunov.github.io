<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Drone Operator Defense</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Segoe UI', sans-serif; }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
        }
        h1 { margin: 0; font-size: 24px; text-shadow: 0 0 10px #000; }
        #stats { font-size: 18px; margin-bottom: 10px; color: #aaa; }
        
        #controls {
            pointer-events: auto;
            margin-top: 10px;
        }

        button {
            background: #007bff;
            border: 2px solid #0056b3;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            box-shadow: 0 4px #004494;
            transition: all 0.1s;
        }

        button:active {
            box-shadow: 0 0 #004494;
            transform: translateY(4px);
        }

        button:disabled {
            background: #555;
            border-color: #333;
            box-shadow: none;
            cursor: not-allowed;
            transform: translateY(4px);
        }

        #energy-bar-container {
            width: 200px;
            height: 10px;
            background: #333;
            margin-top: 5px;
            border: 1px solid #555;
        }
        #energy-bar {
            width: 0%;
            height: 100%;
            background: #00ffaa;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>BARRACKS DEFENSE: DRONE OPS</h1>
        <div id="stats">Wave: <span id="wave-disp">1</span> | Enemies Alive: <span id="enemy-disp">0</span></div>
        
        <div id="controls">
            <button id="btn-train" onclick="trainOperator()">Train Drone Operator (50 Energy)</button>
            <div id="energy-bar-container">
                <div id="energy-bar"></div>
            </div>
            <p style="font-size: 12px; color: #888;">Energy regenerates over time.</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- GAME CONFIGURATION ---
        const CONFIG = {
            energyRate: 0.5,
            operatorCost: 50,
            spawnRate: 200, // Frames between enemy spawns
            groundSize: 200
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let units = [];
        let projectiles = [];
        let particles = [];
        let lastTime = 0;
        let energy = 50;
        let wave = 1;
        let frameCount = 0;

        // --- ASSETS (Geometries/Materials reused for performance) ---
        const geoBox = new THREE.BoxGeometry(1, 1, 1);
        const geoSphere = new THREE.SphereGeometry(0.5, 8, 8);
        const geoDrone = new THREE.ConeGeometry(0.3, 1, 8);
        
        const matGround = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const matBarracks = new THREE.MeshStandardMaterial({ color: 0x0044ff });
        const matOperator = new THREE.MeshStandardMaterial({ color: 0x0088ff });
        const matEnemy = new THREE.MeshStandardMaterial({ color: 0xff2222 });
        const matDrone = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const matBullet = new THREE.MeshBasicMaterial({ color: 0xffaaaa });

        // --- INITIALIZATION ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x111111, 20, 100);

            // Camera (Isometric-ish view)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 60);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            // Ground
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.groundSize, CONFIG.groundSize), matGround);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid Helper
            const grid = new THREE.GridHelper(CONFIG.groundSize, 40, 0x444444, 0x222222);
            scene.add(grid);

            // Barracks (Player Base)
            createBuilding(-40, 0x0044ff);

            // Enemy Spawn Point Marker (Visual only)
            createBuilding(40, 0x550000); // Red base

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // Start Loop
            animate();
        }

        function createBuilding(zPos, color) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(10, 6, 4), new THREE.MeshStandardMaterial({ color: color }));
            b.position.set(0, 3, zPos);
            b.castShadow = true;
            b.receiveShadow = true;
            scene.add(b);
        }

        // --- GAME LOGIC CLASSES ---

        class Unit {
            constructor(team, x, z) {
                this.team = team; // 'player' or 'enemy'
                this.hp = team === 'player' ? 30 : 20;
                this.maxHp = this.hp;
                this.range = team === 'player' ? 25 : 15;
                this.cooldown = 0;
                this.maxCooldown = team === 'player' ? 60 : 30; // Player shoots slower but homing
                this.speed = team === 'player' ? 0.05 : 0.08;
                
                // Visuals
                this.mesh = new THREE.Mesh(geoBox, team === 'player' ? matOperator : matEnemy);
                this.mesh.position.set(x, 1, z);
                this.mesh.castShadow = true;
                
                // Add a "rifle" or "controller" visual
                const gun = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 1), new THREE.MeshStandardMaterial({color:0x333333}));
                gun.position.set(0.4, 0, 0.4);
                this.mesh.add(gun);

                scene.add(this.mesh);
            }

            update() {
                if (this.hp <= 0) return false;

                // Cooldown tick
                if (this.cooldown > 0) this.cooldown--;

                // Find nearest target
                let target = null;
                let minDist = Infinity;

                units.forEach(u => {
                    if (u.team !== this.team && u.hp > 0) {
                        const dist = this.mesh.position.distanceTo(u.mesh.position);
                        if (dist < minDist) {
                            minDist = dist;
                            target = u;
                        }
                    }
                });

                // AI Logic
                if (target) {
                    // Look at target
                    this.mesh.lookAt(target.mesh.position);

                    if (minDist <= this.range) {
                        // Attack
                        if (this.cooldown <= 0) {
                            this.shoot(target);
                            this.cooldown = this.maxCooldown;
                        }
                    } else {
                        // Move forward
                        this.mesh.translateZ(this.speed);
                    }
                } else {
                    // No targets, move towards enemy base line
                    const targetZ = this.team === 'player' ? 40 : -40;
                    const goal = new THREE.Vector3(this.mesh.position.x, 1, targetZ);
                    this.mesh.lookAt(goal);
                    if (Math.abs(this.mesh.position.z - targetZ) > 2) {
                        this.mesh.translateZ(this.speed);
                    }
                }
                return true;
            }

            shoot(target) {
                if (this.team === 'player') {
                    // Spawn Drone (Homing)
                    projectiles.push(new DroneProjectile(
                        this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)),
                        target,
                        this.team
                    ));
                } else {
                    // Spawn Rifle Bullet (Fast, Linear)
                    projectiles.push(new RifleProjectile(
                        this.mesh.position.clone(),
                        target.mesh.position.clone(),
                        this.team
                    ));
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                // Flash white
                this.mesh.material.emissive = new THREE.Color(0xffffff);
                setTimeout(() => { 
                    if(this.mesh) this.mesh.material.emissive = new THREE.Color(0x000000); 
                }, 50);

                if (this.hp <= 0) {
                    createExplosion(this.mesh.position, this.team === 'player' ? 0x0088ff : 0xff2222);
                    scene.remove(this.mesh);
                }
            }
        }

        class DroneProjectile {
            constructor(startPos, targetUnit, team) {
                this.mesh = new THREE.Mesh(geoDrone, matDrone);
                this.mesh.position.copy(startPos);
                this.mesh.rotation.x = Math.PI / 2; // Point cone forward
                scene.add(this.mesh);
                
                this.target = targetUnit;
                this.team = team;
                this.speed = 0.3;
                this.damage = 10;
                this.life = 100;
            }

            update() {
                this.life--;
                if (this.life <= 0 || (this.target && this.target.hp <= 0)) {
                    // If target dies, just keep going straight or die
                    if (!this.target || this.target.hp <= 0) this.target = null; 
                }

                if (this.target) {
                    // Homing logic
                    const direction = new THREE.Vector3().subVectors(this.target.mesh.position, this.mesh.position).normalize();
                    this.mesh.position.add(direction.multiplyScalar(this.speed));
                    this.mesh.lookAt(this.target.mesh.position);

                    if (this.mesh.position.distanceTo(this.target.mesh.position) < 1) {
                        this.target.takeDamage(this.damage);
                        return false; // Destroy projectile
                    }
                } else {
                    // Dumb fire if lost target
                    this.mesh.translateZ(this.speed);
                }

                return true;
            }
            
            destroy() {
                scene.remove(this.mesh);
            }
        }

        class RifleProjectile {
            constructor(startPos, endPos, team) {
                this.mesh = new THREE.Mesh(geoSphere, matBullet);
                this.mesh.position.copy(startPos);
                this.mesh.scale.set(0.3, 0.3, 0.3);
                scene.add(this.mesh);

                this.velocity = new THREE.Vector3().subVectors(endPos, startPos).normalize().multiplyScalar(0.8);
                this.team = team;
                this.damage = 2; // Rifles fire fast, do low damage
                this.life = 60;
            }

            update() {
                this.life--;
                this.mesh.position.add(this.velocity);

                // Simple collision check
                for (let u of units) {
                    if (u.team !== this.team && u.hp > 0) {
                        if (this.mesh.position.distanceTo(u.mesh.position) < 1.0) {
                            u.takeDamage(this.damage);
                            return false;
                        }
                    }
                }
                
                return this.life > 0;
            }

            destroy() {
                scene.remove(this.mesh);
            }
        }

        // --- PARTICLES ---
        function createExplosion(pos, color) {
            for(let i=0; i<8; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({color: color}));
                p.position.copy(pos);
                
                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5 + 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                particles.push({ mesh: p, vel: vel, life: 30 });
                scene.add(p);
            }
        }

        // --- MAIN LOOP ---

        function animate() {
            requestAnimationFrame(animate);

            // 1. Manage Energy
            if (energy < 100) energy += CONFIG.energyRate;
            if (energy > 100) energy = 100;
            updateUI();

            // 2. Spawn Enemies
            frameCount++;
            if (frameCount % CONFIG.spawnRate === 0) {
                spawnEnemy();
                // Make game harder over time
                if (frameCount % 1000 === 0) {
                    CONFIG.spawnRate = Math.max(50, CONFIG.spawnRate - 10);
                    wave++;
                }
            }

            // 3. Update Units
            units = units.filter(u => {
                const alive = u.update();
                return alive;
            });

            // 4. Update Projectiles
            projectiles = projectiles.filter(p => {
                const active = p.update();
                if (!active) p.destroy();
                return active;
            });

            // 5. Update Particles
            particles = particles.filter(p => {
                p.life--;
                p.mesh.position.add(p.vel);
                p.vel.y -= 0.02; // Gravity
                p.mesh.rotation.x += 0.1;
                if(p.life <= 0) scene.remove(p.mesh);
                return p.life > 0;
            });

            // 6. Render
            renderer.render(scene, camera);
        }

        // --- GAME ACTIONS ---

        window.trainOperator = function() {
            if (energy >= CONFIG.operatorCost) {
                energy -= CONFIG.operatorCost;
                // Spawn randomly around barracks
                const x = (Math.random() - 0.5) * 10;
                const unit = new Unit('player', x, -35);
                units.push(unit);
            }
        };

        function spawnEnemy() {
            const x = (Math.random() - 0.5) * 20;
            const unit = new Unit('enemy', x, 35);
            units.push(unit);
        }

        // --- UI & UTILS ---

        function updateUI() {
            const bar = document.getElementById('energy-bar');
            bar.style.width = energy + '%';
            
            const btn = document.getElementById('btn-train');
            btn.disabled = energy < CONFIG.operatorCost;

            document.getElementById('wave-disp').innerText = wave;
            document.getElementById('enemy-disp').innerText = units.filter(u => u.team === 'enemy').length;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
    </script>
</body>
</html>

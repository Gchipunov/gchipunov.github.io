<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Drunk Plumber Simulator 2025: Extended Edition</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Courier New', Courier, monospace; 
            touch-action: none; 
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: yellow;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            line-height: 1.5;
            z-index: 10;
        }
        /* RADAR STYLES */
        #radar-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 140px;
            height: 140px;
            background: rgba(0, 20, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 50%;
            z-index: 10;
            overflow: hidden;
            box-shadow: 0 0 10px #00ff00;
        }
        #radar-canvas {
            width: 100%;
            height: 100%;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 40px;
            font-weight: bold;
            text-align: center;
            text-shadow: 4px 4px 0 #ff0000;
            display: none;
            z-index: 20;
        }
        .bar-container { width: 150px; height: 15px; border: 2px solid white; margin-bottom: 5px; background: rgba(0,0,0,0.5); }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #buzz-bar { background-color: #ff00ff; width: 100%; }
        #parts-bar { background-color: #ffa500; width: 100%; }

        /* --- MOBILE CONTROLS --- */
        .control-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            z-index: 100;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.6); border-color: #fff; }
        #btn-left { bottom: 30px; left: 20px; }
        #btn-right { bottom: 30px; left: 110px; }
        #btn-up { bottom: 110px; right: 30px; background: rgba(0, 255, 0, 0.2); }
        #btn-down { bottom: 30px; right: 30px; background: rgba(255, 0, 0, 0.2); }
    </style>
</head>
<body>

<div id="hud">
    <div><strong>JOB: </strong>FIX PIPES</div>
    <div>DAMAGE: $<span id="score">0</span></div>
    <br>
    <div>BLOOD ALCOHOL</div>
    <div class="bar-container"><div id="buzz-bar" class="bar-fill"></div></div>
    <div>PARTS</div>
    <div class="bar-container"><div id="parts-bar" class="bar-fill"></div></div>
</div>

<div id="radar-container">
    <canvas id="radar-canvas" width="140" height="140"></canvas>
</div>

<div id="message">GAME OVER<br>YOU GOT TOO SOBER</div>

<div id="btn-left" class="control-btn">←</div>
<div id="btn-right" class="control-btn">→</div>
<div id="btn-up" class="control-btn">GAS</div>
<div id="btn-down" class="control-btn">BRK</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

    // --- GAME CONFIG ---
    const MAP_SIZE = 1600; // Total world size
    const STORES_COUNT = 10; // Number of Liquor & Depot stores
    const BUILDING_COUNT = 150;
    const PIPE_COUNT = 60;
    
    // --- GAME STATE ---
    const state = {
        score: 0,
        buzz: 100,      
        parts: 50,      
        gameOver: false,
        speed: 0,
        steering: 0,
        drunkSway: 0
    };

    // --- SETUP SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.012);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(100, 200, 100);
    dirLight.castShadow = true;
    dirLight.shadow.camera.left = -100;
    dirLight.shadow.camera.right = 100;
    dirLight.shadow.camera.top = 100;
    dirLight.shadow.camera.bottom = -100;
    scene.add(dirLight);

    // --- ASSETS ---
    // 1. Ground
    const groundGeo = new THREE.PlaneGeometry(MAP_SIZE*2, MAP_SIZE*2);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // 2. The Truck (Utility Pickup Style)
    const truckGroup = new THREE.Group();
    const truckMat = new THREE.MeshStandardMaterial({ color: 0xdddddd }); // White/Grey body
    const darkMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); // Bumpers/wheels
    const rackMat = new THREE.MeshStandardMaterial({ color: 0x880000 }); // Red rack

    // Cab
    const cab = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.8, 2.5), truckMat);
    cab.position.set(0, 1.6, 2.5);
    cab.castShadow = true;
    truckGroup.add(cab);

    // Bed (Flatbed area)
    const bed = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.8, 3.5), truckMat);
    bed.position.set(0, 1.1, -0.5); 
    bed.castShadow = true;
    truckGroup.add(bed);

    // Windshield
    const glass = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 0.1), new THREE.MeshBasicMaterial({color: 0x111111}));
    glass.position.set(0, 2, 3.76);
    truckGroup.add(glass);

    // Utility Rack (The Plumber Look)
    const rackLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 0.1), rackMat); rackLeg1.position.set(1.1, 2, -2);
    const rackLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 0.1), rackMat); rackLeg2.position.set(-1.1, 2, -2);
    const rackLeg3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 0.1), rackMat); rackLeg3.position.set(1.1, 2, 1.2);
    const rackLeg4 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 0.1), rackMat); rackLeg4.position.set(-1.1, 2, 1.2);
    const rackTop = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.1, 4), rackMat); rackTop.position.set(0, 3, -0.4);
    
    // Pipes on rack
    const rackPipe = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4.5), new THREE.MeshStandardMaterial({color:0xffffff}));
    rackPipe.rotation.x = Math.PI/2;
    rackPipe.position.set(0.5, 3.1, -0.4);

    truckGroup.add(rackLeg1, rackLeg2, rackLeg3, rackLeg4, rackTop, rackPipe);

    // Wheels
    const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
    wheelGeo.rotateZ(Math.PI/2);
    const w1 = new THREE.Mesh(wheelGeo, darkMat); w1.position.set(1.1, 0.5, 2.5);
    const w2 = new THREE.Mesh(wheelGeo, darkMat); w2.position.set(-1.1, 0.5, 2.5);
    const w3 = new THREE.Mesh(wheelGeo, darkMat); w3.position.set(1.1, 0.5, -1.5);
    const w4 = new THREE.Mesh(wheelGeo, darkMat); w4.position.set(-1.1, 0.5, -1.5);
    truckGroup.add(w1, w2, w3, w4);

    scene.add(truckGroup);

    // --- WORLD GENERATION ---
    const buildings = [];
    const pipes = [];
    const liquorStores = [];
    const depotStores = [];
    const particles = [];
    
    function randomPos() {
        return (Math.random() - 0.5) * MAP_SIZE;
    }

    // Buildings
    for(let i=0; i<BUILDING_COUNT; i++) {
        const x = randomPos();
        const z = randomPos();
        if(Math.abs(x) < 30 && Math.abs(z) < 30) continue; // Spawn Area Clear
        
        const h = 10 + Math.random() * 30;
        const w = 5 + Math.random() * 10;
        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, w), 
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true;
        scene.add(mesh);
        buildings.push({ mesh, collider: new THREE.Box3().setFromObject(mesh) });
    }

    // Broken Pipes
    for(let i=0; i<PIPE_COUNT; i++) {
        const x = randomPos();
        const z = randomPos();
        const mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, 3, 8),
            new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x0044aa })
        );
        mesh.position.set(x, 1.5, z);
        scene.add(mesh);
        pipes.push({ mesh, active: true });
    }

    // Helper for Stores
    function createStore(color, x, z, typeList) {
        // Zone
        const zone = new THREE.Mesh(
            new THREE.CylinderGeometry(10, 10, 1, 32),
            new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.3 })
        );
        zone.position.set(x, 0.1, z);
        scene.add(zone);
        
        // Floating Sign
        const sign = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshBasicMaterial({color: color}));
        sign.position.set(x, 8, z);
        
        // Simple animation logic added later
        scene.add(sign);
        
        typeList.push({ zone, sign });
    }

    // Liquor Stores (Pink)
    for(let i=0; i<STORES_COUNT; i++) {
        createStore(0xff00ff, randomPos(), randomPos(), liquorStores);
    }

    // Home Depots (Orange)
    for(let i=0; i<STORES_COUNT; i++) {
        createStore(0xffa500, randomPos(), randomPos(), depotStores);
    }

    // --- PARTICLES ---
    function spawnParticles(pos) {
        for(let i=0; i<10; i++) {
            const p = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.6, 0.6),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            p.position.copy(pos);
            p.position.y += Math.random() * 5;
            p.userData = { vel: new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)) };
            scene.add(p);
            particles.push(p);
        }
    }

    // --- INPUT ---
    const keys = { w:false, a:false, s:false, d:false };

    window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowUp' || e.key === 'w') keys.w = true;
        if(e.key === 'ArrowDown' || e.key === 's') keys.s = true;
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.a = true;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.d = true;
    });
    window.addEventListener('keyup', (e) => {
        if(e.key === 'ArrowUp' || e.key === 'w') keys.w = false;
        if(e.key === 'ArrowDown' || e.key === 's') keys.s = false;
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.a = false;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.d = false;
    });

    function bindTouch(id, key) {
        const btn = document.getElementById(id);
        const activate = (e) => { e.preventDefault(); keys[key] = true; };
        const deactivate = (e) => { e.preventDefault(); keys[key] = false; };
        btn.addEventListener('touchstart', activate, {passive: false});
        btn.addEventListener('touchend', deactivate, {passive: false});
        btn.addEventListener('mousedown', activate);
        btn.addEventListener('mouseup', deactivate);
        btn.addEventListener('mouseleave', deactivate);
    }
    bindTouch('btn-up', 'w');
    bindTouch('btn-down', 's');
    bindTouch('btn-left', 'a');
    bindTouch('btn-right', 'd');

    // --- RADAR LOGIC ---
    const radarCanvas = document.getElementById('radar-canvas');
    const radarCtx = radarCanvas.getContext('2d');
    const RADAR_RANGE = 250; // Distance shown on radar
    const RADAR_RADIUS = 70; // Half of canvas size

    function updateRadar() {
        // Clear
        radarCtx.fillStyle = 'rgba(0, 20, 0, 0.8)';
        radarCtx.fillRect(0, 0, 140, 140);
        
        // Draw Grid
        radarCtx.strokeStyle = '#004400';
        radarCtx.beginPath();
        radarCtx.arc(70, 70, 35, 0, Math.PI*2);
        radarCtx.stroke();

        // Helper to draw blip
        function drawBlip(objX, objZ, color, size) {
            const dx = objX - truckGroup.position.x;
            const dz = objZ - truckGroup.position.z;
            
            // Rotate blip based on truck rotation so "Up" on radar is "Forward" for truck
            // We want the world relative to the truck.
            const angle = -truckGroup.rotation.y;
            const rx = dx * Math.cos(angle) - dz * Math.sin(angle);
            const rz = dx * Math.sin(angle) + dz * Math.cos(angle);

            // Scale to radar
            const mapX = 70 + (rx / RADAR_RANGE) * 70;
            const mapY = 70 - (rz / RADAR_RANGE) * 70; // Invert Z for canvas Y

            // Distance Check (Clamp to circle)
            const dist = Math.sqrt(Math.pow(mapX-70, 2) + Math.pow(mapY-70, 2));
            if (dist < 70) {
                radarCtx.fillStyle = color;
                radarCtx.beginPath();
                radarCtx.arc(mapX, mapY, size, 0, Math.PI*2);
                radarCtx.fill();
            }
        }

        // 1. Draw Stores
        liquorStores.forEach(s => drawBlip(s.zone.position.x, s.zone.position.z, '#ff00ff', 3));
        depotStores.forEach(s => drawBlip(s.zone.position.x, s.zone.position.z, '#ffa500', 3));
        
        // 2. Draw Pipes
        pipes.forEach(p => {
            if(p.active) drawBlip(p.mesh.position.x, p.mesh.position.z, '#00ccff', 2);
        });

        // 3. Draw Player (Center)
        radarCtx.fillStyle = '#00ff00';
        radarCtx.beginPath();
        radarCtx.moveTo(70, 65);
        radarCtx.lineTo(67, 73);
        radarCtx.lineTo(73, 73);
        radarCtx.fill();
    }

    // --- GAME LOOP ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        if (state.gameOver) return;

        // 1. Drunk Logic
        state.buzz -= dt * 2.5; 
        if (state.buzz <= 0) {
            state.buzz = 0;
            state.gameOver = true;
            document.getElementById('message').style.display = 'block';
        }
        
        const swayIntensity = (state.buzz / 100) * 0.05;
        state.drunkSway = Math.sin(time * 2) * swayIntensity;

        // 2. Physics
        if (keys.w) state.speed += 30 * dt; // Faster truck for bigger map
        if (keys.s) state.speed -= 20 * dt;
        state.speed *= 0.96; 

        let targetSteer = 0;
        if (keys.a) targetSteer = 2.5;
        if (keys.d) targetSteer = -2.5;
        
        state.steering += (targetSteer - state.steering) * 2 * dt; 

        truckGroup.rotation.y += (state.steering + state.drunkSway) * dt * (state.speed * 0.1);
        truckGroup.translateZ(state.speed * dt);

        // 3. Camera
        const relativeCameraOffset = new THREE.Vector3(0, 10, -18);
        const cameraOffset = relativeCameraOffset.applyMatrix4(truckGroup.matrixWorld);
        camera.position.lerp(cameraOffset, 0.1);
        camera.lookAt(truckGroup.position);
        camera.rotation.z = (state.steering * -0.1) + (Math.sin(time * 3) * 0.05);

        // 4. Collisions
        const truckBox = new THREE.Box3().setFromObject(truckGroup);

        // Buildings
        buildings.forEach(b => {
            if (truckBox.intersectsBox(b.collider)) {
                state.speed *= -0.5;
                truckGroup.translateZ(-3);
                state.score += Math.floor(Math.random() * 500) + 100;
                camera.position.y += 1;
            }
        });

        // Pipes
        pipes.forEach(p => {
            if (p.active && truckGroup.position.distanceTo(p.mesh.position) < 5) {
                p.active = false;
                scene.remove(p.mesh);
                spawnParticles(p.mesh.position);

                if (state.parts > 0) {
                    state.parts -= 10;
                    if(state.parts < 0) state.parts = 0;
                    state.score += 50; 
                } else {
                    state.score += 5000; 
                }
            }
        });

        // Stores Checks
        liquorStores.forEach(s => {
            s.sign.rotation.y += dt; // Spin sign
            if (truckGroup.position.distanceTo(s.zone.position) < 10) {
                state.buzz = Math.min(state.buzz + 50 * dt, 100);
            }
        });

        depotStores.forEach(s => {
            s.sign.rotation.y += dt; // Spin sign
            if (truckGroup.position.distanceTo(s.zone.position) < 10) {
                state.parts = Math.min(state.parts + 50 * dt, 100);
            }
        });

        // 5. Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.position.add(p.userData.vel);
            p.userData.vel.y -= 0.05;
            p.scale.multiplyScalar(0.9);
            if (p.scale.x < 0.01) {
                scene.remove(p);
                particles.splice(i, 1);
            }
        }

        // 6. UI & Radar
        document.getElementById('score').innerText = state.score.toLocaleString();
        document.getElementById('buzz-bar').style.width = state.buzz + '%';
        document.getElementById('parts-bar').style.width = state.parts + '%';
        
        updateRadar(); // Update Radar Canvas

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>

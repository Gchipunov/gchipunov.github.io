<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Drunk Plumber Simulator 2025</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: yellow;
            font-size: 18px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            line-height: 1.5;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 40px;
            font-weight: bold;
            text-align: center;
            text-shadow: 4px 4px 0 #ff0000;
            display: none;
        }
        .bar-container { width: 200px; height: 20px; border: 2px solid white; margin-bottom: 5px; background: rgba(0,0,0,0.5); }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #buzz-bar { background-color: #ff00ff; width: 100%; }
        #parts-bar { background-color: #ffa500; width: 100%; }
    </style>
</head>
<body>

<div id="hud">
    <div><strong>JOB: </strong>FIX THE PIPES</div>
    <div>DAMAGE CAUSED: $<span id="score">0</span></div>
    <br>
    <div>BLOOD ALCOHOL LEVEL (Keep High!)</div>
    <div class="bar-container"><div id="buzz-bar" class="bar-fill"></div></div>
    <div>PVC ELBOWS & GLUE</div>
    <div class="bar-container"><div id="parts-bar" class="bar-fill"></div></div>
</div>

<div id="message">GAME OVER<br>YOU GOT TOO SOBER</div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

    // --- GAME STATE ---
    const state = {
        score: 0,
        buzz: 100,      // Max 100. If 0, game over.
        parts: 50,      // Max 100. Used to fix pipes.
        gameOver: false,
        speed: 0,
        steering: 0,
        drunkSway: 0
    };

    // --- SETUP SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    scene.fog = new THREE.FogExp2(0x111111, 0.015);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- ASSETS ---
    // 1. Ground
    const groundGeo = new THREE.PlaneGeometry(1000, 1000);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // 2. The Truck (Ford E350-ish)
    const truckGroup = new THREE.Group();
    
    // Body
    const bodyGeo = new THREE.BoxGeometry(2.2, 2.5, 6);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White van
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 1.75;
    body.castShadow = true;
    truckGroup.add(body);

    // Cab
    const cabGeo = new THREE.BoxGeometry(2.1, 1.8, 2);
    const cab = new THREE.Mesh(cabGeo, bodyMat);
    cab.position.set(0, 1.5, 3.5); // Front
    truckGroup.add(cab);

    // Windshield
    const glassGeo = new THREE.BoxGeometry(1.8, 1, 0.1);
    const glassMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
    const glass = new THREE.Mesh(glassGeo, glassMat);
    glass.position.set(0, 2, 4.5);
    truckGroup.add(glass);

    // Text on side
    // (Simulated with a colored stripe for simplicity)
    const stripeGeo = new THREE.BoxGeometry(2.3, 0.5, 4);
    const stripeMat = new THREE.MeshBasicMaterial({ color: 0x880000 }); // "Plumber Red"
    const stripe = new THREE.Mesh(stripeGeo, stripeMat);
    stripe.position.set(0, 2, 0);
    truckGroup.add(stripe);

    scene.add(truckGroup);

    // --- WORLD GENERATION ---
    const buildings = [];
    const pipes = [];
    const particles = [];
    
    // Helper to create buildings
    function createBuilding(x, z) {
        const h = 10 + Math.random() * 20;
        const geo = new THREE.BoxGeometry(10, h, 10);
        const mat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true;
        scene.add(mesh);
        buildings.push({ mesh, collider: new THREE.Box3().setFromObject(mesh) });
    }

    // Helper to create Broken Pipes
    function createPipe(x, z) {
        const geo = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
        const mat = new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x0044aa });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, 1.5, z);
        scene.add(mesh);
        pipes.push({ mesh, active: true });
    }

    // Generate City Grid
    for(let i=0; i<40; i++) {
        const x = (Math.random() - 0.5) * 400;
        const z = (Math.random() - 0.5) * 400;
        if(Math.abs(x) < 20 && Math.abs(z) < 20) continue; // clear spawn
        createBuilding(x, z);
    }

    // Generate Pipes
    for(let i=0; i<30; i++) {
        const x = (Math.random() - 0.5) * 350;
        const z = (Math.random() - 0.5) * 350;
        createPipe(x, z);
    }

    // --- STORES ---
    // 1. Liquor Store (Pink Zone)
    const liquorZone = new THREE.Mesh(
        new THREE.CylinderGeometry(8, 8, 1, 32),
        new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 })
    );
    liquorZone.position.set(-80, 0.1, -80);
    scene.add(liquorZone);
    // Sign
    const liquorSign = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshBasicMaterial({color: 0xff00ff}));
    liquorSign.position.set(-80, 5, -80);
    scene.add(liquorSign);

    // 2. Home Depot (Orange Zone)
    const depotZone = new THREE.Mesh(
        new THREE.CylinderGeometry(8, 8, 1, 32),
        new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.5 })
    );
    depotZone.position.set(80, 0.1, 80);
    scene.add(depotZone);
    // Sign
    const depotSign = new THREE.Mesh(new THREE.BoxGeometry(4,4,4), new THREE.MeshBasicMaterial({color: 0xffa500}));
    depotSign.position.set(80, 5, 80);
    scene.add(depotSign);

    // --- PARTICLES (Water Spray) ---
    function spawnParticles(pos) {
        for(let i=0; i<10; i++) {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const p = new THREE.Mesh(geo, mat);
            p.position.copy(pos);
            p.position.y += Math.random() * 5;
            p.userData = { 
                vel: new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5)) 
            };
            scene.add(p);
            particles.push(p);
        }
    }

    // --- INPUT ---
    const keys = { w:false, a:false, s:false, d:false };
    window.addEventListener('keydown', (e) => {
        if(e.key === 'ArrowUp' || e.key === 'w') keys.w = true;
        if(e.key === 'ArrowDown' || e.key === 's') keys.s = true;
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.a = true;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.d = true;
    });
    window.addEventListener('keyup', (e) => {
        if(e.key === 'ArrowUp' || e.key === 'w') keys.w = false;
        if(e.key === 'ArrowDown' || e.key === 's') keys.s = false;
        if(e.key === 'ArrowLeft' || e.key === 'a') keys.a = false;
        if(e.key === 'ArrowRight' || e.key === 'd') keys.d = false;
    });

    // --- GAME LOOP ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        if (state.gameOver) return;

        // 1. Drunk Logic
        state.buzz -= dt * 2.5; // Decrement buzz
        if (state.buzz <= 0) {
            state.buzz = 0;
            state.gameOver = true;
            document.getElementById('message').style.display = 'block';
        }
        
        // Visual sway based on drunkenness
        // The less buzz you have, the more you shake (withdrawal?) 
        // OR: High buzz = slow sway. Low buzz = jitters. 
        // Let's do: High Buzz = Wide, slow sway.
        const swayIntensity = (state.buzz / 100) * 0.05;
        state.drunkSway = Math.sin(time * 2) * swayIntensity;

        // 2. Car Physics (Arcade)
        if (keys.w) state.speed += 20 * dt;
        if (keys.s) state.speed -= 15 * dt;
        state.speed *= 0.95; // Friction

        // Steering with drunk delay
        let targetSteer = 0;
        if (keys.a) targetSteer = 2.5;
        if (keys.d) targetSteer = -2.5;
        
        // LERP steering to simulate sluggish reaction time
        state.steering += (targetSteer - state.steering) * 2 * dt; 

        // Apply movement
        truckGroup.rotation.y += (state.steering + state.drunkSway) * dt * (state.speed * 0.1);
        truckGroup.translateZ(state.speed * dt);

        // 3. Camera Follow
        const relativeCameraOffset = new THREE.Vector3(0, 8, -15); // Behind and up
        const cameraOffset = relativeCameraOffset.applyMatrix4(truckGroup.matrixWorld);
        
        // LERP camera for smoothness + Drunk Roll
        camera.position.lerp(cameraOffset, 0.1);
        camera.lookAt(truckGroup.position);
        
        // Drunk camera roll
        camera.rotation.z = (state.steering * -0.1) + (Math.sin(time * 3) * 0.05);

        // 4. Collisions & Gameplay

        const truckBox = new THREE.Box3().setFromObject(truckGroup);

        // Buildings (Crash)
        buildings.forEach(b => {
            if (truckBox.intersectsBox(b.collider)) {
                // Bounce back
                state.speed *= -0.5;
                truckGroup.translateZ(-2);
                state.score += Math.floor(Math.random() * 500) + 100;
                
                // Camera shake effect
                camera.position.y += 1;
            }
        });

        // Pipes (Fix or Break)
        pipes.forEach(p => {
            if (p.active && truckGroup.position.distanceTo(p.mesh.position) < 4) {
                p.active = false;
                scene.remove(p.mesh);
                spawnParticles(p.mesh.position);

                if (state.parts > 0) {
                    state.parts -= 10;
                    if(state.parts < 0) state.parts = 0;
                    // Properly Fixed? No, you're drunk.
                    // But we count it as a "Job Done" essentially
                    state.score += 50; 
                } else {
                    // No parts, just smashed it
                    state.score += 5000; // Big damage bill
                }
            }
        });

        // Liquor Store (Refill Buzz)
        if (truckGroup.position.distanceTo(liquorZone.position) < 10) {
            state.buzz = Math.min(state.buzz + 50 * dt, 100);
        }

        // Home Depot (Refill Parts)
        if (truckGroup.position.distanceTo(depotZone.position) < 10) {
            state.parts = Math.min(state.parts + 50 * dt, 100);
        }

        // 5. Particles Update
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.position.add(p.userData.vel);
            p.userData.vel.y -= 0.05; // Gravity
            p.scale.multiplyScalar(0.9);
            if (p.scale.x < 0.01) {
                scene.remove(p);
                particles.splice(i, 1);
            }
        }

        // 6. UI Update
        document.getElementById('score').innerText = state.score.toLocaleString();
        document.getElementById('buzz-bar').style.width = state.buzz + '%';
        document.getElementById('parts-bar').style.width = state.parts + '%';

        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Tank - Pure WebGL</title>
    <style>
        body { margin: 0; overflow: hidden; background: #333; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #ui { position: absolute; top: 10px; width: 100%; text-align: center; color: white; font-family: sans-serif; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">CLICK GROUND TO MOVE TANK</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        // --- Shaders ---
        const vs = `
            attribute vec4 aPos;
            attribute vec3 aNorm;
            uniform mat4 uProj;
            uniform mat4 uView;
            uniform mat4 uModel;
            varying vec3 vNorm;
            void main() {
                gl_Position = uProj * uView * uModel * aPos;
                vNorm = aNorm;
            }
        `;
        const fs = `
            precision mediump float;
            varying vec3 vNorm;
            uniform vec3 uCol;
            void main() {
                vec3 lightDir = normalize(vec3(0.5, 1.0, 0.7));
                float d = max(dot(vNorm, lightDir), 0.2);
                gl_FragColor = vec4(uCol * d, 1.0);
            }
        `;

        // --- Math Toolkit ---
        const M4 = {
            identity: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            multiply: (a, b) => {
                let out = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        out[i*4+j] = a[i*4+0]*b[0*4+j] + a[i*4+1]*b[1*4+j] + a[i*4+2]*b[2*4+j] + a[i*4+3]*b[3*4+j];
                    }
                }
                return out;
            },
            perspective: (fovy, aspect, near, far) => {
                let f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
                return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]);
            },
            translate: (m, x, y, z) => M4.multiply(m, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1])),
            rotateY: (m, rad) => {
                let s = Math.sin(rad), c = Math.cos(rad);
                return M4.multiply(m, new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]));
            },
            scale: (m, x, y, z) => M4.multiply(m, new Float32Array([x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]))
        };

        // --- Initialize WebGL Program ---
        function createShader(gl, type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source); gl.compileShader(s);
            return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl, gl.VERTEX_SHADER, vs));
        gl.attachShader(prog, createShader(gl, gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        // --- Geometry (Cube) ---
        const vertices = new Float32Array([
            -1,-1,1, 1,-1,1, 1,1,1, -1,1,1,  -1,-1,-1, -1,1,-1, 1,1,-1, 1,-1,-1,
            -1,1,-1, -1,1,1, 1,1,1, 1,1,-1,  -1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1,
             1,-1,-1, 1,1,-1, 1,1,1, 1,-1,1, -1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1
        ]);
        const normals = new Float32Array([
            0,0,1, 0,0,1, 0,0,1, 0,0,1,  0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
            0,1,0, 0,1,0, 0,1,0, 0,1,0,  0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
            1,0,0, 1,0,0, 1,0,0, 1,0,0, -1,0,0, -1,0,0, -1,0,0, -1,0,0
        ]);
        const indices = new Uint16Array([
            0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11, 12,13,14, 12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23
        ]);

        const buf = (data, type) => {
            const b = gl.createBuffer();
            gl.bindBuffer(type, b);
            gl.bufferData(type, data, gl.STATIC_DRAW);
            return b;
        };
        const vBuf = buf(vertices, gl.ARRAY_BUFFER);
        const nBuf = buf(normals, gl.ARRAY_BUFFER);
        const iBuf = buf(indices, gl.ELEMENT_ARRAY_BUFFER);

        const aPos = gl.getAttribLocation(prog, 'aPos');
        const aNorm = gl.getAttribLocation(prog, 'aNorm');
        const uProj = gl.getUniformLocation(prog, 'uProj');
        const uView = gl.getUniformLocation(prog, 'uView');
        const uModel = gl.getUniformLocation(prog, 'uModel');
        const uCol = gl.getUniformLocation(prog, 'uCol');

        // --- Game State ---
        let tank = { x: 0, z: 0, rot: 0 }, target = { x: 0, z: 0 }, moving = false;

        window.onclick = (e) => {
            target.x = (e.clientX / window.innerWidth - 0.5) * 40 + tank.x;
            target.z = (e.clientY / window.innerHeight - 0.5) * 40 + tank.z;
            moving = true;
        };

        function drawObj(modelMat, color) {
            gl.uniformMatrix4fv(uModel, false, modelMat);
            gl.uniform3fv(uCol, color);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuf);
            gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aPos);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, nBuf);
            gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(aNorm);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iBuf);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        }

        function loop() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.2, 0.4, 0.6, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            // 1. Movement Logic
            if (moving) {
                let dx = target.x - tank.x, dz = target.z - tank.z;
                let dist = Math.sqrt(dx*dx + dz*dz);
                if (dist > 0.2) {
                    let targetRot = Math.atan2(dx, dz);
                    // Smooth rotation
                    let diff = targetRot - tank.rot;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    tank.rot += diff * 0.1;
                    
                    tank.x += Math.sin(tank.rot) * 0.1;
                    tank.z += Math.cos(tank.rot) * 0.1;
                } else { moving = false; }
            }

            // 2. Camera (Top-down follow)
            const proj = M4.perspective(0.8, canvas.width / canvas.height, 0.1, 200);
            let view = M4.identity();
            view = M4.translate(view, 0, -25, -35); // Camera Height and Distance
            view = M4.multiply(view, new Float32Array([1,0,0,0, 0,0.7,0.7,0, 0,-0.7,0.7,0, 0,0,0,1])); // Tilt
            view = M4.translate(view, -tank.x, 0, -tank.z); // Follow tank
            
            gl.uniformMatrix4fv(uProj, false, proj);
            gl.uniformMatrix4fv(uView, false, view);

            // 3. Render Ground
            drawObj(M4.scale(M4.identity(), 50, 0.1, 50), [0.3, 0.5, 0.3]);

            // 4. Render Tank Parts
            let base = M4.translate(M4.identity(), tank.x, 0.6, tank.z);
            base = M4.rotateY(base, tank.rot);

            // Hull
            drawObj(M4.scale(base, 1.2, 0.5, 1.8), [0.1, 0.2, 0.4]);
            // Turret
            drawObj(M4.scale(M4.translate(base, 0, 0.8, 0), 0.8, 0.4, 0.8), [0.2, 0.3, 0.5]);
            // Double Barrels
            drawObj(M4.scale(M4.translate(base, -0.3, 0.8, 1.5), 0.1, 0.1, 1.0), [0.1, 0.1, 0.1]);
            drawObj(M4.scale(M4.translate(base, 0.3, 0.8, 1.5), 0.1, 0.1, 1.0), [0.1, 0.1, 0.1]);

            requestAnimationFrame(loop);
        }

        window.onresize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };
        window.onresize();
        requestAnimationFrame(loop);
    </script>
</body>
</html>

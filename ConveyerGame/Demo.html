<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Conveyor Belt Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none; /* Let clicks pass through to canvas */
        }
        h1 { margin: 0; font-size: 24px; text-transform: uppercase; letter-spacing: 2px; }
        #score-board { font-size: 18px; margin-top: 5px; color: #aaa; }
        #lives { margin-top: 5px; color: #ff5555; font-weight: bold;}

        /* Game Over Screen */
        #game-over {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 10;
        }
        button {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: background 0.3s;
        }
        button:hover { background: #45a049; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <h1>Quality Control</h1>
        <div id="score-board">Score: 0</div>
        <div id="lives">Lives: 3</div>
        <p style="font-size: 12px; color: #888;">Click RED cubes. Save GREEN cubes.</p>
    </div>

    <div id="game-over">
        <h1 style="font-size: 50px; color: #ff5555;">GAME OVER</h1>
        <p id="final-score">Final Score: 0</p>
        <button id="restart-btn">Restart Shift</button>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const BELT_SPEED = 2.5; // Units per second
        const SPAWN_RATE = 1.2; // Seconds between spawns
        const BELT_WIDTH = 4;
        const BELT_LENGTH = 15;
        
        // --- State ---
        let score = 0;
        let lives = 3;
        let isGameOver = false;
        let lastTime = 0;
        let spawnTimer = 0;
        let items = []; // Array to hold our 3D objects

        // --- DOM Elements ---
        const scoreEl = document.getElementById('score-board');
        const livesEl = document.getElementById('lives');
        const gameOverEl = document.getElementById('game-over');
        const finalScoreEl = document.getElementById('final-score');
        const restartBtn = document.getElementById('restart-btn');

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // Isometric-ish Camera
        const aspect = window.innerWidth / window.innerHeight;
        const d = 10;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); // High angle
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- The Conveyor Belt ---
        // 1. Generate a procedural texture for the belt stripes
        function createBeltTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            // Background
            ctx.fillStyle = '#333333';
            ctx.fillRect(0, 0, 64, 64);
            // Stripe
            ctx.fillStyle = '#444444';
            ctx.fillRect(0, 0, 4, 64); // Vertical line acting as horizontal stripe when rotated
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            // Repeat texture to make it look like a long belt
            texture.repeat.set(10, 1); 
            return texture;
        }

        const beltTexture = createBeltTexture();
        const beltGeometry = new THREE.BoxGeometry(BELT_LENGTH, 0.5, BELT_WIDTH);
        const beltMaterial = new THREE.MeshStandardMaterial({ map: beltTexture });
        const belt = new THREE.Mesh(beltGeometry, beltMaterial);
        belt.position.y = -0.25;
        belt.receiveShadow = true;
        scene.add(belt);

        // Frame for the belt
        const frameGeo = new THREE.BoxGeometry(BELT_LENGTH, 0.6, BELT_WIDTH + 0.5);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        frame.position.y = -0.35;
        scene.add(frame);

        // --- Interaction (Raycaster) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            if (isGameOver) return;

            // Normalize mouse position
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersections with items
            const intersects = raycaster.intersectObjects(items);

            if (intersects.length > 0) {
                const hitObject = intersects[0].object;
                handleItemClick(hitObject);
            }
        });

        // --- Game Logic ---

        function spawnItem() {
            const isBad = Math.random() > 0.6; // 40% chance of a bad item
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            
            // Green for Good, Red for Bad
            const color = isBad ? 0xff3333 : 0x33cc33;
            const material = new THREE.MeshStandardMaterial({ color: color });
            
            const cube = new THREE.Mesh(geometry, material);
            
            // Start at the right side of the belt
            cube.position.set(BELT_LENGTH / 2, 0.5, (Math.random() - 0.5) * (BELT_WIDTH - 1.5));
            cube.castShadow = true;
            cube.userData = { isBad: isBad, type: 'item' }; // Store data in the mesh
            
            scene.add(cube);
            items.push(cube);
        }

        function handleItemClick(object) {
            // Remove from scene and array
            scene.remove(object);
            items = items.filter(i => i !== object);
            
            // Logic
            if (object.userData.isBad) {
                // Correct click
                score += 10;
                updateUI();
                spawnExplosion(object.position, 0xff3333);
            } else {
                // Incorrect click (destroyed a good item)
                loseLife();
            }
        }

        function loseLife() {
            lives--;
            updateUI();
            if (lives <= 0) endGame();
        }

        function endGame() {
            isGameOver = true;
            gameOverEl.style.display = 'flex';
            finalScoreEl.innerText = `Final Score: ${score}`;
        }

        function updateUI() {
            scoreEl.innerText = `Score: ${score}`;
            livesEl.innerText = `Lives: ${lives}`;
        }

        // Simple particle effect for feedback
        function spawnExplosion(pos, color) {
            const particleCount = 8;
            const geom = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<particleCount; i++) {
                const p = new THREE.Mesh(geom, mat);
                p.position.copy(pos);
                // Random velocity
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5) * 0.2,
                    Math.random() * 0.3,
                    (Math.random()-0.5) * 0.2
                );
                scene.add(p);
                // Animate and remove particle
                animateParticle(p);
            }
        }

        function animateParticle(p) {
            let life = 30;
            function step() {
                if(life > 0) {
                    p.position.add(p.userData.vel);
                    p.rotation.x += 0.1;
                    p.userData.vel.y -= 0.01; // gravity
                    life--;
                    requestAnimationFrame(step);
                } else {
                    scene.remove(p);
                }
            }
            step();
        }

        function resetGame() {
            // Clear existing items
            items.forEach(i => scene.remove(i));
            items = [];
            
            score = 0;
            lives = 3;
            isGameOver = false;
            gameOverEl.style.display = 'none';
            updateUI();
        }

        restartBtn.addEventListener('click', resetGame);

        // --- Main Game Loop ---
        function animate(time) {
            requestAnimationFrame(animate);

            // Calculate Delta Time (seconds passed since last frame)
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            if (isGameOver) {
                renderer.render(scene, camera);
                return;
            }

            // 1. Animate Belt Texture (UV offset)
            // This creates the illusion of movement
            beltTexture.offset.x -= (BELT_SPEED / 10) * dt; 

            // 2. Spawn Logic
            spawnTimer += dt;
            if (spawnTimer > SPAWN_RATE) {
                spawnItem();
                spawnTimer = 0;
            }

            // 3. Move Items
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.position.x -= BELT_SPEED * dt;

                // Check if item reached the end (Left side)
                if (item.position.x < -BELT_LENGTH / 2) {
                    // Item fell off logic
                    if (item.userData.isBad) {
                        // A bad item got through!
                        loseLife();
                    }
                    
                    // Remove item
                    scene.remove(item);
                    items.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start Loop
        animate(0);

    </script>
</body>
</html>

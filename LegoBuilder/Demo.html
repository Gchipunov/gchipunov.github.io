<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Brick Crafter</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; }
        .hint { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        b { color: #ffcc00; }
    </style>
</head>
<body>

<div id="ui">
    <div class="hint">
        <h2>Brick Builder 1.0</h2>
        <p><b>WASD</b>: Move Selector | <b>Space</b>: Place Brick</p>
        <p><b>R</b>: Reset | <b>Colors</b>: Random on place</p>
    </div>
</div>

<canvas id="glCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

<script>
/** SHADER SOURCE **/
const vsSource = `
    attribute vec4 aVertexPosition;
    attribute vec4 aVertexColor;
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    varying lowp vec4 vColor;
    void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        vColor = aVertexColor;
    }
`;

const fsSource = `
    varying lowp vec4 vColor;
    void main() {
        gl_FragColor = vColor;
    }
`;

let bricks = [];
let selectorPos = [0, 0, -10];

function main() {
    const canvas = document.querySelector('#glCanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) return;

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
    const programInfo = {
        program: shaderProgram,
        attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
            vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
        },
        uniformLocations: {
            projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
        },
    };

    // Initial Floor
    for(let x = -5; x <= 5; x++) {
        for(let z = -15; z <= -5; z++) {
            bricks.push({pos: [x*1.1, -2, z*1.1], color: [0.3, 0.3, 0.3, 1]});
        }
    }

    window.addEventListener('keydown', (e) => {
        if(e.key === 'w') selectorPos[2] -= 1.1;
        if(e.key === 's') selectorPos[2] += 1.1;
        if(e.key === 'a') selectorPos[1] -= 1.1;
        if(e.key === 'd') selectorPos[1] += 1.1;
        if(e.key === 'ArrowUp') selectorPos[1] += 1.1;
        if(e.key === 'ArrowDown') selectorPos[1] -= 1.1;
        if(e.key === ' ') {
            bricks.push({
                pos: [...selectorPos], 
                color: [Math.random(), Math.random(), Math.random(), 1]
            });
        }
        if(e.key === 'r') bricks = [];
    });

    function render(now) {
        drawScene(gl, programInfo);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
}

function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    return shaderProgram;
}

function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

function drawScene(gl, programInfo) {
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clearDepth(1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, 45 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.1, 100.0);

    // Draw existing bricks
    bricks.forEach(brick => {
        drawCube(gl, programInfo, projectionMatrix, brick.pos, brick.color, 0.5);
    });

    // Draw selector (ghost brick)
    drawCube(gl, programInfo, projectionMatrix, selectorPos, [1, 1, 1, 0.5], 0.55);
}

function drawCube(gl, programInfo, projectionMatrix, translation, color, size) {
    const modelViewMatrix = mat4.create();
    mat4.translate(modelViewMatrix, modelViewMatrix, translation);
    
    // Create a rotating effect for fun
    // mat4.rotate(modelViewMatrix, modelViewMatrix, 0.1, [0, 1, 0]);

    const positions = [
        -size, -size,  size,  size, -size,  size,  size,  size,  size, -size,  size,  size,
        -size, -size, -size, -size,  size, -size,  size,  size, -size,  size, -size, -size,
        -size,  size, -size, -size,  size,  size,  size,  size,  size,  size,  size, -size,
        -size, -size, -size,  size, -size, -size,  size, -size,  size, -size, -size,  size,
         size, -size, -size,  size,  size, -size,  size,  size,  size,  size, -size,  size,
        -size, -size, -size, -size, -size,  size, -size,  size,  size, -size,  size, -size,
    ];

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    let colors = [];
    for (let j = 0; j < 24; ++j) {
        colors = colors.concat(color);
    }

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

    const indices = [
        0,  1,  2,      0,  2,  3,
        4,  5,  6,      4,  6,  7,
        8,  9,  10,     8,  10, 11,
        12, 13, 14,     12, 14, 15,
        16, 17, 18,     16, 18, 19,
        20, 21, 22,     20, 22, 23,
    ];

    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(programInfo.attribLocations.vertexColor, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.useProgram(programInfo.program);
    gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
    gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);

    gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
}

window.onload = main;
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL 3D Physics Water on Terrain</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <div id="info">3D Physics Water on Terrain<br>Three.js + Cannon-es</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- Configuration ---
        const PARTICLE_COUNT = 400;
        const PARTICLE_SIZE = 0.4;
        const TERRAIN_SIZE = 30;
        const TERRAIN_SEGMENTS = 30; // Resolution of the grid

        // --- Globals ---
        let scene, camera, renderer, world;
        let particles = []; // Stores { mesh, body }
        let time = 0;

        init();
        animate();

        function init() {
            // 1. Setup Three.js Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 30);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            // 2. Setup Cannon.js World
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            // Optimization: sweep and prune for broadphase
            world.broadphase = new CANNON.SAPBroadphase(world);

            // Materials
            const groundMat = new CANNON.Material();
            const waterMat = new CANNON.Material();

            // Contact behavior (make water slippery)
            const waterGroundContact = new CANNON.ContactMaterial(groundMat, waterMat, {
                friction: 0.0, // Very slippery
                restitution: 0.1 // Not too bouncy
            });
            world.addContactMaterial(waterGroundContact);
            
            // Water-Water contact
            const waterWaterContact = new CANNON.ContactMaterial(waterMat, waterMat, {
                friction: 0.1,
                restitution: 0.1
            });
            world.addContactMaterial(waterWaterContact);

            // 3. Generate Terrain Data
            const matrix = [];
            const sizeX = TERRAIN_SEGMENTS;
            const sizeZ = TERRAIN_SEGMENTS;

            // We generate a height matrix for physics
            for (let i = 0; i < sizeX; i++) {
                matrix.push([]);
                for (let j = 0; j < sizeZ; j++) {
                    const height = generateHeight(i, j, sizeX, sizeZ);
                    matrix[i].push(height);
                }
            }

            // 4. Create Physics Terrain
            const elementSize = TERRAIN_SIZE / sizeX;
            const heightfieldShape = new CANNON.Heightfield(matrix, {
                elementSize: elementSize
            });
            const heightfieldBody = new CANNON.Body({ mass: 0, material: groundMat });
            heightfieldBody.addShape(heightfieldShape);
            
            // Center the physics terrain
            heightfieldBody.position.set(
                -(sizeX * elementSize) / 2,
                0,
                (sizeZ * elementSize) / 2
            );
            heightfieldBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(heightfieldBody);

            // 5. Create Visual Terrain
            const geometry = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, sizeX - 1, sizeZ - 1);
            
            // Update vertices to match physics heightfield
            const posAttribute = geometry.attributes.position;
            // Note: Three.js PlaneGeometry is created on X Y plane by default, but rotated -90 X usually. 
            // Here we iterate manually to match the matrix structure.
            
            for (let i = 0; i < sizeX; i++) {
                for (let j = 0; j < sizeZ; j++) {
                    // Calculate vertex index
                    // Heightfield data in cannon is [x][y], mapped to [i][j]
                    // PlaneGeometry organizes vertices row by row
                    const index = i * sizeX + j; 
                    
                    // The height in the physics matrix needs to be applied to the Z component (because plane is vertical initially) 
                    // or Y if we rotate it. Let's modify Z here and rotate the mesh later.
                    // However, Cannon Heightfield orientation is specific. 
                    // Let's rely on mapping the matrix values directly.
                    
                    // Careful alignment logic:
                    // Cannon Heightfield origin is at corner. ThreeJS Plane is at center.
                    
                    // Let's just create a custom mesh based exactly on the matrix to ensure 1:1 match
                    const h = matrix[i][j];
                    // PlaneGeometry index order is X then Y (or X then Z depending on orientation)
                    // We simply set the Z value of the plane geometry (which becomes Y after rotation)
                    
                    // Actually, let's just set the Z attribute of the plane geometry, 
                    // because we will rotate the mesh -Math.PI/2 to lay it flat.
                    // But we need to make sure the loop order matches.
                    
                    // In ThreeJS PlaneGeometry:
                    // loop y (segmentsH), loop x (segmentsW)
                    
                    // Our matrix is i(x), j(z).
                    // We need to map correctly. 
                    
                    // Visual adjustment:
                    // Because simple mapping is tricky, we will sample the same height function used for the matrix
                    // directly onto the ThreeJS mesh vertices.
                }
            }
            
            // Re-traverse geometry to apply heights using the same math function
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i); // This is 'y' in local space, which maps to world Z
                
                // We need to map local coordinate back to grid index to sample height
                // Coordinate range is -TERRAIN_SIZE/2 to +TERRAIN_SIZE/2
                
                // Inverse map:
                const normX = (x + TERRAIN_SIZE/2) / TERRAIN_SIZE;
                const normY = (y + TERRAIN_SIZE/2) / TERRAIN_SIZE; // Actually Z in world
                
                // Map to indices 0..sizeX-1
                // We use floor to pick nearest grid point, or calculate exact math function
                // Using the exact math function is smoother for visuals
                const worldX = (sizeX-1) * normX;
                const worldZ = (sizeZ-1) * normY;
                
                const zVal = generateHeight(worldX, worldZ, sizeX, sizeZ);
                posAttribute.setZ(i, zVal);
            }
            
            geometry.computeVertexNormals();

            const terrainMat = new THREE.MeshStandardMaterial({ 
                color: 0x55aa55,
                roughness: 0.8,
                metalness: 0.1,
                side: THREE.DoubleSide
                // wireframe: true 
            });
            const terrainMesh = new THREE.Mesh(geometry, terrainMat);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            // Adjust visual position to align with physics body center
            // Physics body is corner-based, Mesh is center-based. 
            // They should align naturally if centered at 0,0
            
            // However, Cannon heightfield is usually +X, -Y oriented relative to local frame? 
            // It's tricky. Let's visually check and offset if needed.
            // Based on standard implementation, we often need to rotate the cannon body.
            // We did that above: heightfieldBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            
            // Let's refine the position:
            // Cannon heightfield pivot is at (0,0,0) of the field (corner).
            // We moved physics body by -(sizeX * elementSize) / 2.
            // This aligns the corner to the negative corner, effectively centering it.
            // So visual mesh at (0,0,0) should match.
            
            scene.add(terrainMesh);

            // 6. Create "Water" Particles
            const sphereGeo = new THREE.SphereGeometry(PARTICLE_SIZE, 16, 16);
            const sphereMat = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                roughness: 0.0,
                metalness: 0.1,
                transparent: true,
                opacity: 0.8
            });

            // Use InstancedMesh? For simplicity and different physics positions, separate meshes are easier to manage in logic for beginners.
            // But for 400 particles, separate meshes are fine.
            
            for(let i=0; i<PARTICLE_COUNT; i++) {
                createParticle(sphereGeo, sphereMat, waterMat);
            }

            window.addEventListener('resize', onWindowResize);
        }

        // --- Helper: Height Generation ---
        function generateHeight(i, j, sizeX, sizeZ) {
            // Normalize inputs to 0..2PI range for waves
            const x = (i / sizeX) * Math.PI * 4;
            const y = (j / sizeZ) * Math.PI * 4;
            
            // Combine Sines/Cosines for terrain shape
            let h = Math.sin(x) * 2 + Math.cos(y) * 2;
            
            // Add a "bowl" shape so water stays in center
            const distFromCenter = Math.sqrt(Math.pow(i - sizeX/2, 2) + Math.pow(j - sizeZ/2, 2));
            h += (distFromCenter / sizeX) * 15;
            
            // Invert so we have a valley
            return -h + 10; 
        }

        function createParticle(geo, mat, physMat) {
            // Three Mesh
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            scene.add(mesh);

            // Cannon Body
            const shape = new CANNON.Sphere(PARTICLE_SIZE);
            const body = new CANNON.Body({
                mass: 1, // Dynamic
                material: physMat,
                position: new CANNON.Vec3(
                    (Math.random() - 0.5) * 10, // Spread X
                    15 + Math.random() * 20,    // Height Y
                    (Math.random() - 0.5) * 10  // Spread Z
                )
            });
            body.addShape(shape);
            body.linearDamping = 0.3; // Simulate slight air resistance/fluid viscosity
            world.addBody(body);

            particles.push({ mesh, body });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Step Physics
            // Fixed time step for stability
            world.fixedStep();

            // Sync Visuals
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                p.mesh.position.copy(p.body.position);
                p.mesh.quaternion.copy(p.body.quaternion);
                
                // Simple respawn logic if they fall off world
                if (p.body.position.y < -10) {
                    p.body.position.set(
                        (Math.random() - 0.5) * 10,
                        20,
                        (Math.random() - 0.5) * 10
                    );
                    p.body.velocity.set(0,0,0);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

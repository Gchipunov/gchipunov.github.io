<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raw WebGL Military Base</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="info">Raw WebGL Base<br>Drag to Rotate View</div>
    <canvas id="glcanvas"></canvas>

    <script>
        // --- 1. Shader Source Code ---
        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec4 aVertexColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            varying highp vec3 vLighting;
            varying highp vec4 vColor;

            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vColor = aVertexColor;

                // Simple Directional Lighting
                highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);
                highp vec3 directionalLightColor = vec3(1, 1, 1);
                highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));

                highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);
                highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);
                vLighting = ambientLight + (directionalLightColor * directional);
            }
        `;

        const fsSource = `
            varying highp vec3 vLighting;
            varying highp vec4 vColor;

            void main(void) {
                gl_FragColor = vec4(vColor.rgb * vLighting, vColor.a);
            }
        `;

        // --- 2. Minimal Matrix Math Library (No external libs) ---
        const Mat4 = {
            create: () => new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]),
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                out[0] = f / aspect; out[1]=0; out[2]=0; out[3]=0;
                out[4] = 0; out[5] = f; out[6]=0; out[7]=0;
                out[8] = 0; out[9] = 0; out[10]=(far + near) * nf; out[11]=-1;
                out[12]=0; out[13]=0; out[14]=(2 * far * near) * nf; out[15]=0;
            },
            translate: (out, a, v) => {
                let x=v[0], y=v[1], z=v[2];
                out[12] = a[0]*x + a[4]*y + a[8]*z + a[12];
                out[13] = a[1]*x + a[5]*y + a[9]*z + a[13];
                out[14] = a[2]*x + a[6]*y + a[10]*z + a[14];
                out[15] = a[3]*x + a[7]*y + a[11]*z + a[15];
            },
            rotate: (out, a, rad, axis) => {
                let x=axis[0], y=axis[1], z=axis[2];
                let len = Math.sqrt(x*x + y*y + z*z);
                if(len < 0.00001) return null;
                len = 1/len; x*=len; y*=len; z*=len;
                let s = Math.sin(rad), c = Math.cos(rad), t = 1-c;
                let a00=a[0], a01=a[1], a02=a[2], a03=a[3];
                let a10=a[4], a11=a[5], a12=a[6], a13=a[7];
                let a20=a[8], a21=a[9], a22=a[10], a23=a[11];
                let b00 = x*x*t+c, b01 = y*x*t+z*s, b02 = z*x*t-y*s;
                let b10 = x*y*t-z*s, b11 = y*y*t+c, b12 = z*y*t+x*s;
                let b20 = x*z*t+y*s, b21 = y*z*t-x*s, b22 = z*z*t+c;
                out[0] = a00*b00 + a10*b01 + a20*b02;
                out[1] = a01*b00 + a11*b01 + a21*b02;
                out[2] = a02*b00 + a12*b01 + a22*b02;
                out[3] = a03*b00 + a13*b01 + a23*b02;
                out[4] = a00*b10 + a10*b11 + a20*b12;
                out[5] = a01*b10 + a11*b11 + a21*b12;
                out[6] = a02*b10 + a12*b11 + a22*b12;
                out[7] = a03*b10 + a13*b11 + a23*b12;
                out[8] = a00*b20 + a10*b21 + a20*b22;
                out[9] = a01*b20 + a11*b21 + a21*b22;
                out[10]= a02*b20 + a12*b21 + a22*b22;
                out[11]= a03*b20 + a13*b21 + a23*b22;
            },
            scale: (out, a, v) => {
                out[0] = a[0]*v[0]; out[1] = a[1]*v[0]; out[2] = a[2]*v[0]; out[3] = a[3]*v[0];
                out[4] = a[4]*v[1]; out[5] = a[5]*v[1]; out[6] = a[6]*v[1]; out[7] = a[7]*v[1];
                out[8] = a[8]*v[2]; out[9] = a[9]*v[2]; out[10]= a[10]*v[2]; out[11]= a[11]*v[2];
                out[12]= a[12];     out[13]= a[13];     out[14]= a[14];      out[15]= a[15];
            },
            invert: (out, a) => {
                // Simplified invert for lighting normals
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b00 = a00 * a11 - a01 * a10;
                let b01 = a00 * a12 - a02 * a10;
                let b02 = a00 * a13 - a03 * a10;
                let b03 = a01 * a12 - a02 * a11;
                let b04 = a01 * a13 - a03 * a11;
                let b05 = a02 * a13 - a03 * a12;
                let b06 = a20 * a31 - a21 * a30;
                let b07 = a20 * a32 - a22 * a30;
                let b08 = a20 * a33 - a23 * a30;
                let b09 = a21 * a32 - a22 * a31;
                let b10 = a21 * a33 - a23 * a31;
                let b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) return null;
                det = 1.0 / det;
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                // ... partial implementation sufficient for rotation matrices ...
                return out;
            },
            transpose: (out, a) => {
                out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
                out[4] = a[1]; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
                out[8] = a[2]; out[9] = a[6]; out[10]= a[10]; out[11]= a[14];
                out[12]= a[3]; out[13]= a[7]; out[14]= a[11]; out[15]= a[15];
            }
        };

        // --- 3. WebGL Initialization ---
        const canvas = document.querySelector('#glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) { alert('Unable to initialize WebGL.'); }

        // Compile Shader
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, loadShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(shaderProgram, loadShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(shaderProgram);

        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
            },
        };

        // --- 4. Geometry Generators ---

        function createCube(color, openFront = false) {
            // Basic Cube Vertices
            const positions = [
                // Front face (Optional)
                ...(!openFront ? [-1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1] : []),
                // Back face
                -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1, -1,
                // Top face
                -1,  1, -1, -1,  1,  1,  1,  1,  1,  1,  1, -1,
                // Bottom face
                -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,
                // Right face
                 1, -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,
                // Left face
                -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1,
            ];

            const normals = [
                ...(!openFront ? [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1] : []), // Front
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, // Back
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // Top
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // Bottom
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // Right
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // Left
            ];

            const indices = [];
            let offset = 0;
            const faceCount = openFront ? 5 : 6;
            for(let i=0; i<faceCount; i++){
                indices.push(offset, offset+1, offset+2, offset, offset+2, offset+3);
                offset += 4;
            }

            // Colors
            let colors = [];
            for (let j = 0; j < positions.length / 3; ++j) {
                colors = colors.concat(color);
            }

            return { positions, normals, indices, colors };
        }

        // --- 5. Scene Objects ---
        
        // Define objects
        const objects = [];

        function addObject(geometryData, position, scale, rotation = [0,0,0], parent = null) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometryData.positions), gl.STATIC_DRAW);

            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometryData.normals), gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geometryData.colors), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geometryData.indices), gl.STATIC_DRAW);

            const obj = {
                buffers: { position: positionBuffer, normal: normalBuffer, color: colorBuffer, indices: indexBuffer },
                vertexCount: geometryData.indices.length,
                transform: { pos: position, scale: scale, rot: rotation },
                parent: parent,
                localMatrix: Mat4.create(),
                worldMatrix: Mat4.create()
            };
            objects.push(obj);
            return obj;
        }

        // 1. Warehouse (Grey, Open Front)
        // Positioned at origin
        const warehouse = addObject(createCube([0.5, 0.5, 0.5, 1.0], true), [0, 5, 0], [10, 5, 8]);

        // 2. Crane Base (Inside, Yellow)
        const craneBase = addObject(createCube([0.9, 0.8, 0.1, 1.0]), [-3, -4, 0], [0.5, 4, 0.5], [0,0,0], warehouse);
        // Crane Arm
        const craneArm = addObject(createCube([0.9, 0.8, 0.1, 1.0]), [2, 1, 0], [4, 0.4, 0.4], [0,0,0], craneBase);

        // 3. Bunker Window (Side extension, Dark Green)
        const bunker = addObject(createCube([0.3, 0.4, 0.2, 1.0]), [1.1, -0.5, 0], [0.3, 0.4, 0.5], [0,0,0], warehouse);

        // 4. Radar (Top, Red/White)
        // Base
        const radarBase = addObject(createCube([0.3, 0.3, 0.3, 1.0]), [0, 1.1, 0], [0.5, 0.5, 0.5], [0,0,0], warehouse);
        // Spinner
        const radarDish = addObject(createCube([0.8, 0.2, 0.2, 1.0]), [0, 1.5, 0], [2, 0.2, 0.2], [0,0,0], radarBase);
        
        // 5. Floor (Ground)
        const ground = addObject(createCube([0.2, 0.3, 0.2, 1.0]), [0, -0.1, 0], [50, 0.1, 50]);


        // --- 6. Rendering & Animation ---
        
        let radarAngle = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0.5;

        function drawScene() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.53, 0.81, 0.92, 1.0); // Sky Blue
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Projection
            const projectionMatrix = Mat4.create();
            Mat4.perspective(projectionMatrix, 45 * Math.PI / 180, canvas.width / canvas.height, 0.1, 100.0);

            // Camera (Orbit)
            const cameraMatrix = Mat4.create();
            const radius = 40;
            const camX = Math.sin(cameraAngleX) * radius * Math.cos(cameraAngleY);
            const camY = Math.sin(cameraAngleY) * radius + 10; // Lift up slightly
            const camZ = Math.cos(cameraAngleX) * radius * Math.cos(cameraAngleY);
            
            // LookAt logic (Manual)
            const zAxis = [camX, camY - 5, camZ]; // Eye to Target (approx)
            // Normalize zAxis, compute xAxis, yAxis... simplified:
            // For this demo, let's just use ModelView = Translate * Rotate inverse
            // Actually, simplest is to move the World away from Camera
            const modelViewMatrix = Mat4.create();
            Mat4.translate(modelViewMatrix, modelViewMatrix, [0, -5, -40]); // Move back
            Mat4.rotate(modelViewMatrix, modelViewMatrix, cameraAngleY, [1, 0, 0]);
            Mat4.rotate(modelViewMatrix, modelViewMatrix, cameraAngleX, [0, 1, 0]);

            // Animation Updates
            radarAngle += 0.03;
            radarDish.transform.rot[1] = radarAngle;

            // Render Objects
            objects.forEach(obj => {
                // 1. Calculate Matrices
                const mat = Mat4.create();
                
                // If parent, start with parent's world matrix, else identity
                if(obj.parent) {
                    // This simple parent logic assumes parent is already updated. 
                    // Since we defined parent first, it works.
                    // Ideally we'd recursively update.
                    // Copy parent matrix
                    for(let i=0; i<16; i++) mat[i] = obj.parent.worldMatrix[i];
                }

                // Apply Local Transform
                Mat4.translate(mat, mat, obj.transform.pos);
                Mat4.rotate(mat, mat, obj.transform.rot[0], [1, 0, 0]);
                Mat4.rotate(mat, mat, obj.transform.rot[1], [0, 1, 0]);
                Mat4.rotate(mat, mat, obj.transform.rot[2], [0, 0, 1]);
                Mat4.scale(mat, mat, obj.transform.scale);

                // Store as world matrix for children
                for(let i=0; i<16; i++) obj.worldMatrix[i] = mat[i];

                // Combine with Camera for GPU
                const finalMV = Mat4.create();
                // We need to apply the camera transform (which is in modelViewMatrix global) * ObjectWorld
                // Since I implemented camera as "Move World", we multiply modelViewMatrix * obj.worldMatrix
                // Note: My simple mat mul is A*B.
                
                // Manual Multiply for Camera * Object
                // let's assume the helper multiply works A*B
                // We actually want CameraTransform * ObjectTransform
                
                // Re-implementation of Multiply for clarity
                 function mult(a, b) {
                    let out = new Float32Array(16);
                    let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                    let b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
                    let b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
                    let b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
                    let b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
                    out[0] = b00*a00 + b01*a10 + b02*a20 + b03*a30;
                    out[1] = b00*a01 + b01*a11 + b02*a21 + b03*a31;
                    out[2] = b00*a02 + b01*a12 + b02*a22 + b03*a32;
                    out[3] = b00*a03 + b01*a13 + b02*a23 + b03*a33;
                    out[4] = b10*a00 + b11*a10 + b12*a20 + b13*a30;
                    out[5] = b10*a01 + b11*a11 + b12*a21 + b13*a31;
                    out[6] = b10*a02 + b11*a12 + b12*a22 + b13*a32;
                    out[7] = b10*a03 + b11*a13 + b12*a23 + b13*a33;
                    out[8] = b20*a00 + b21*a10 + b22*a20 + b23*a30;
                    out[9] = b20*a01 + b21*a11 + b22*a21 + b23*a31;
                    out[10]= b20*a02 + b21*a12 + b22*a22 + b23*a32;
                    out[11]= b20*a03 + b21*a13 + b22*a23 + b23*a33;
                    out[12]= b30*a00 + b31*a10 + b32*a20 + b33*a30;
                    out[13]= b30*a01 + b31*a11 + b32*a21 + b33*a31;
                    out[14]= b30*a02 + b31*a12 + b32*a22 + b33*a32;
                    out[15]= b30*a03 + b31*a13 + b32*a23 + b33*a33;
                    return out;
                }
                
                const drawMatrix = mult(modelViewMatrix, obj.worldMatrix);
                
                // Normal Matrix
                const normalMatrix = Mat4.create();
                Mat4.invert(normalMatrix, drawMatrix);
                Mat4.transpose(normalMatrix, normalMatrix);

                // Draw
                gl.useProgram(programInfo.program);
                
                // Attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffers.position);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffers.normal);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);

                gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffers.color);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexColor, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.buffers.indices);

                // Uniforms
                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, drawMatrix);
                gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);

                gl.drawElements(gl.TRIANGLES, obj.vertexCount, gl.UNSIGNED_SHORT, 0);
            });

            requestAnimationFrame(drawScene);
        }

        // --- 7. Inputs ---
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', e => {
            if(isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                cameraAngleX += deltaX * 0.01;
                cameraAngleY += deltaY * 0.01;
                // Clamp vertical
                if(cameraAngleY > 1.5) cameraAngleY = 1.5;
                if(cameraAngleY < -1.5) cameraAngleY = -1.5;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Start
        requestAnimationFrame(drawScene);

    </script>
</body>
</html>

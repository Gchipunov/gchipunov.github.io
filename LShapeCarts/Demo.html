<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL L-Shape Physics Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; }
        p { margin: 0; font-size: 0.9rem; color: #ccc; }
    </style>
</head>
<body>

<div id="controls">
    <h1>WebGL + Physics</h1>
    <p>Simulating L-Shapes in a container.</p>
    <p>Rendering: Raw WebGL</p>
    <p>Physics: Matter.js</p>
    <p><strong>Click to spawn manually!</strong></p>
</div>

<canvas id="glcanvas"></canvas>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_rotation; // cos(theta), sin(theta)
    uniform vec2 u_scale;

    void main() {
        // Scale
        vec2 scaledPosition = a_position * u_scale;

        // Rotate
        vec2 rotatedPosition = vec2(
            scaledPosition.x * u_rotation.x - scaledPosition.y * u_rotation.y,
            scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x
        );

        // Translate
        vec2 position = rotatedPosition + u_translation;

        // Convert to clip space (-1 to +1)
        // Divide by resolution to get 0->1, multiply by 2 to get 0->2, subtract 1 to get -1->1
        // Flip Y axis because WebGL 0,0 is bottom-left, but physics usually treats Y differently
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;

    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
    // --- CONFIGURATION ---
    const TRAILER_WIDTH = 500;
    const TRAILER_HEIGHT = 600;
    const WALL_THICKNESS = 50;
    const BLOCK_SIZE = 40; // Size of one segment of the L
    
    // --- WEBGL SETUP ---
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) {
        alert("WebGL not supported");
    }

    // Helper to create shader
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    // Helper to create program
    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vsSource = document.getElementById('vertex-shader').text;
    const fsSource = document.getElementById('fragment-shader').text;
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    // Look up locations
    const positionLocation = gl.getAttribLocation(program, "a_position");
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    const colorLocation = gl.getUniformLocation(program, "u_color");
    const translationLocation = gl.getUniformLocation(program, "u_translation");
    const rotationLocation = gl.getUniformLocation(program, "u_rotation");
    const scaleLocation = gl.getUniformLocation(program, "u_scale");

    // Create a buffer for a unit rectangle (centered at 0,0)
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
        -0.5, -0.5,
         0.5, -0.5,
        -0.5,  0.5,
        -0.5,  0.5,
         0.5, -0.5,
         0.5,  0.5,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    // --- PHYSICS SETUP (Matter.js) ---
    const Engine = Matter.Engine,
          Render = Matter.Render, // We won't use this, but good to have ref
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Body = Matter.Body,
          Vector = Matter.Vector;

    const engine = Engine.create();
    const world = engine.world;

    // Create the "Trailer" (Container)
    // We center the container in the middle of the screen space conceptually
    const midX = window.innerWidth / 2;
    const midY = window.innerHeight / 2;
    const floorY = midY + TRAILER_HEIGHT / 2;

    const ground = Bodies.rectangle(midX, floorY, TRAILER_WIDTH, WALL_THICKNESS, { isStatic: true, render: {fillStyle: '#555'} });
    const leftWall = Bodies.rectangle(midX - TRAILER_WIDTH/2 + WALL_THICKNESS/2, midY, WALL_THICKNESS, TRAILER_HEIGHT, { isStatic: true, render: {fillStyle: '#555'} });
    const rightWall = Bodies.rectangle(midX + TRAILER_WIDTH/2 - WALL_THICKNESS/2, midY, WALL_THICKNESS, TRAILER_HEIGHT, { isStatic: true, render: {fillStyle: '#555'} });

    Composite.add(world, [ground, leftWall, rightWall]);

    // Function to create an L-Shape
    function createLShape(x, y) {
        // Matter.js Compound Body
        // Part 1: Vertical segment
        // Part 2: Horizontal segment
        // Adjust offsets so they form an L
        
        const thick = BLOCK_SIZE;
        const length = BLOCK_SIZE * 3;
        
        const partA = Bodies.rectangle(x, y, thick, length);
        const partB = Bodies.rectangle(x + thick, y + length/2 - thick/2, thick, thick);

        const body = Body.create({
            parts: [partA, partB],
            restitution: 0.1, // Bounciness
            friction: 0.5
        });

        // Assign a random color for rendering
        body.renderColor = [Math.random(), Math.random(), Math.random(), 1.0];
        
        return body;
    }

    // --- RENDERING LOOP ---
    
    function resizeCanvas() {
        const displayWidth  = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;

        if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
    }

    function drawRect(x, y, w, h, rotation, color) {
        // Set Uniforms
        gl.uniform2f(translationLocation, x, y);
        gl.uniform2f(scaleLocation, w, h);
        
        // Rotation: pass cos and sin
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        gl.uniform2f(rotationLocation, c, s);

        gl.uniform4fv(colorLocation, color);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function render() {
        resizeCanvas();

        // Clear
        gl.clearColor(0.1, 0.1, 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);

        // Iterate over all physics bodies
        const bodies = Composite.allBodies(world);
        
        bodies.forEach(body => {
            // For static walls (simple rectangles)
            if (body.parts.length === 1) { 
                 const part = body.parts[0]; // Self
                 // Get vertices from Matter.js is tricky for pure rectangles in this raw draw method
                 // Easier to use the stored width/height logic or vertices if known.
                 // Since we created them, we know them, but let's calculate from bounds for walls
                 const w = body.bounds.max.x - body.bounds.min.x;
                 const h = body.bounds.max.y - body.bounds.min.y;
                 const color = body.render.fillStyle === '#555' ? [0.4, 0.4, 0.4, 1.0] : [1,0,0,1];
                 
                 drawRect(body.position.x, body.position.y, w, h, body.angle, color);
            } 
            // For Compound Bodies (The L-Shapes)
            else if (body.parts.length > 1) {
                // Matter.js body.parts[0] is the main hull, subsequent are the sub-parts
                for (let i = 1; i < body.parts.length; i++) {
                    const part = body.parts[i];
                    
                    // We need to calculate the width/height of the part
                    // Matter.js vertices are absolute.
                    // We approximate dimensions based on area for this specific demo or store it.
                    // Since we know we used rectangles:
                    // We can infer width/height from the vertices array of the part.
                    // Vertices are clockwise.
                    const v = part.vertices;
                    const w = Math.sqrt(Math.pow(v[1].x - v[0].x, 2) + Math.pow(v[1].y - v[0].y, 2));
                    const h = Math.sqrt(Math.pow(v[2].x - v[1].x, 2) + Math.pow(v[2].y - v[1].y, 2));
                    
                    drawRect(part.position.x, part.position.y, w, h, part.angle, body.renderColor);
                }
            }
        });

        requestAnimationFrame(render);
    }

    // --- INTERACTION & SPAWNING ---

    // Spawn a new shape every second
    setInterval(() => {
        // Random X position within the trailer
        const spawnX = midX + (Math.random() * (TRAILER_WIDTH - 100) - (TRAILER_WIDTH - 100)/2);
        const lShape = createLShape(spawnX, -100);
        Body.setAngle(lShape, Math.random() * Math.PI * 2);
        Composite.add(world, lShape);
    }, 800);

    // Mouse click to spawn
    window.addEventListener('mousedown', (e) => {
        const lShape = createLShape(e.clientX, e.clientY);
        Body.setAngle(lShape, Math.random() * Math.PI * 2);
        Composite.add(world, lShape);
    });

    // Start
    const runner = Runner.create();
    Runner.run(runner, engine);
    requestAnimationFrame(render);

</script>
</body>
</html>

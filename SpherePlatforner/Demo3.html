<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #resetButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            font-size: 16px;
            background-color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
        /* NEW: Styles for the on-screen D-pad */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 10px;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            font-size: 24px;
            color: white;
            user-select: none; /* Prevents text selection on hold */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #left-btn { grid-area: left; }
        #right-btn { grid-area: right; }
        #up-btn { grid-area: up; }
        #down-btn { grid-area: down; }
    </style>
</head>
<body>
    <button id="resetButton">Reset</button>
    <canvas id="glCanvas"></canvas>
    
    <div id="controls">
        <div id="up-btn" class="control-btn">▲</div>
        <div id="left-btn" class="control-btn">◀</div>
        <div id="right-btn" class="control-btn">▶</div>
        <div id="down-btn" class="control-btn">▼</div>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        uniform mat3 u_projection;
        uniform mat3 u_view;
        uniform mat3 u_model;
        void main() {
            vec3 transformedPosition = u_projection * u_view * u_model * vec3(a_position, 1.0);
            gl_Position = vec4(transformedPosition.xy, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 u_color;
        void main() {
            gl_FragColor = u_color;
        }
    </script>

    <script>
    window.onload = main;

    function main() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported!');
            return;
        }

        const vsSource = document.getElementById('vertex-shader').text;
        const fsSource = document.getElementById('fragment-shader').text;
        const shaderProgram = createShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'a_position'),
            },
            uniformLocations: {
                projection: gl.getUniformLocation(shaderProgram, 'u_projection'),
                view: gl.getUniformLocation(shaderProgram, 'u_view'),
                model: gl.getUniformLocation(shaderProgram, 'u_model'),
                color: gl.getUniformLocation(shaderProgram, 'u_color'),
            },
        };

        const sphereBuffer = createCircleBuffer(gl, 0.05, 32);
        const platformBuffer = createRectangleBuffer(gl);

        function getInitialGameState() {
            return {
                player: {
                    position: [0, 0.5], velocity: [0, 0], radius: 0.05,
                    rotation: 0, onGround: false
                },
                platforms: [
                    { position: [0, 0], scale: [3.0, 0.2] }, { position: [2, 0.5], scale: [0.8, 0.2] },
                    { position: [3.5, 0.8], scale: [0.8, 0.2] }, { position: [5, 0.5], scale: [0.8, 0.2] },
                    { position: [6.5, 1.0], scale: [0.2, 2.0] }, { position: [5.5, 2.5], scale: [0.8, 0.2] },
                    { position: [4, 3.0], scale: [0.8, 0.2] }, { position: [2.5, 3.5], scale: [0.8, 0.2] },
                    { position: [0, -1.5], scale: [2.0, 0.2] }, { position: [-2, -1.2], scale: [0.8, 0.2] },
                    { position: [-3.5, -1.0], scale: [0.8, 0.2] }, { position: [-5, -0.5], scale: [1.5, 0.2] },
                ],
                gravity: -0.0015, moveSpeed: 0.002, jumpForce: 0.030, downForce: -0.025,
                keys: {},
                // NEW: Simplified touch state for buttons
                touch: {
                    moveLeft: false, moveRight: false, jump: false, down: false,
                },
                camera: { position: [0, 0], zoom: 0.5 },
                levelBounds: { minX: -6.0, maxX: 7.0, minY: -3.0, maxY: 5.0, }
            };
        }
        let gameState = getInitialGameState();

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => gameState.keys[e.key] = true);
        window.addEventListener('keyup', (e) => gameState.keys[e.key] = false);
        
        document.getElementById('resetButton').addEventListener('click', () => {
            gameState = getInitialGameState();
        });

        // NEW: Event listeners for on-screen buttons
        function setupButtonControls(buttonId, touchKey) {
            const button = document.getElementById(buttonId);
            button.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.touch[touchKey] = true; }, { passive: false });
            button.addEventListener('touchend', (e) => { e.preventDefault(); gameState.touch[touchKey] = false; }, { passive: false });
            // Add mouse events for desktop testing
            button.addEventListener('mousedown', (e) => { e.preventDefault(); gameState.touch[touchKey] = true; });
            button.addEventListener('mouseup', (e) => { e.preventDefault(); gameState.touch[touchKey] = false; });
            button.addEventListener('mouseleave', (e) => { e.preventDefault(); gameState.touch[touchKey] = false; });
        }

        setupButtonControls('left-btn', 'moveLeft');
        setupButtonControls('right-btn', 'moveRight');
        setupButtonControls('up-btn', 'jump');
        setupButtonControls('down-btn', 'down');

        // FIXED: Pass `gl` into the render function to ensure it's in scope
        function render(now) {
            update(gl, gameState); // Pass gl to update
            drawScene(gl, programInfo, gameState, sphereBuffer, platformBuffer);
            requestAnimationFrame((nextNow) => render(nextNow));
        }
        requestAnimationFrame(render);
    }

    function update(gl, state) { // FIXED: Receive gl as a parameter
        const player = state.player;

        // Horizontal Movement (Keyboard OR Touch)
        if (state.keys['a'] || state.keys['ArrowLeft'] || state.touch.moveLeft) {
            player.velocity[0] = -state.moveSpeed;
            player.rotation += 0.1;
        } else if (state.keys['d'] || state.keys['ArrowRight'] || state.touch.moveRight) {
            player.velocity[0] = state.moveSpeed;
            player.rotation -= 0.1;
        } else {
            player.velocity[0] = 0;
        }

        // Jumping (Keyboard OR Touch)
        if ((state.keys['w'] || state.keys['ArrowUp'] || state.keys[' '] || state.touch.jump) && player.onGround) {
            player.velocity[1] = state.jumpForce;
            player.onGround = false;
        }

        // Downward Force (Touch only)
        if (state.touch.down && !player.onGround) {
            player.velocity[1] = state.downForce;
        }
        
        player.velocity[1] += state.gravity;
        player.position[0] += player.velocity[0];
        player.position[1] += player.velocity[1];

        player.onGround = false;
        state.platforms.forEach(p => {
            const p_left = p.position[0] - p.scale[0] / 2;
            const p_right = p.position[0] + p.scale[0] / 2;
            const p_top = p.position[1] + p.scale[1] / 2;
            const p_bottom = p.position[1] - p.scale[1] / 2;
            
            if (player.position[0] + player.radius > p_left && player.position[0] - player.radius < p_right &&
                player.position[1] - player.radius < p_top && 
                player.position[1] - player.radius > p_bottom &&
                player.velocity[1] <= 0) {
                
                player.position[1] = p_top + player.radius;
                player.velocity[1] = 0;
                player.onGround = true;
            }
        });

        if (player.position[1] < state.levelBounds.minY) {
            Object.assign(state, getInitialGameState()); // This needs to be a global function or passed in
        }

        const lerpFactor = 0.05;
        state.camera.position[0] += (player.position[0] - state.camera.position[0]) * lerpFactor;
        state.camera.position[1] += (player.position[1] - state.camera.position[1]) * lerpFactor;

        // FIXED: Access canvas via the passed-in gl object
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const cameraHalfWidth = state.camera.zoom * aspect;
        const cameraHalfHeight = state.camera.zoom;
        state.camera.position[0] = Math.max(state.levelBounds.minX + cameraHalfWidth, Math.min(state.levelBounds.maxX - cameraHalfWidth, state.camera.position[0]));
        state.camera.position[1] = Math.max(state.levelBounds.minY + cameraHalfHeight, Math.min(state.levelBounds.maxY - cameraHalfHeight, state.camera.position[1]));
    }

    function drawScene(gl, programInfo, gameState, sphereBuffer, platformBuffer) {
        resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0.1, 0.2, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);

        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const projectionMatrix = createProjectionMatrix(gameState.camera.zoom, aspect);
        const viewMatrix = createViewMatrix(gameState.camera.position);

        gl.uniformMatrix3fv(programInfo.uniformLocations.projection, false, projectionMatrix);
        gl.uniformMatrix3fv(programInfo.uniformLocations.view, false, viewMatrix);

        gameState.platforms.forEach(platform => {
            const modelMatrix = createModelMatrix(platform.position, 0, platform.scale);
            gl.uniformMatrix3fv(programInfo.uniformLocations.model, false, modelMatrix);
            gl.uniform4f(programInfo.uniformLocations.color, 0.4, 0.5, 0.4, 1.0);
            drawObject(gl, programInfo, platformBuffer, 6);
        });
        
        const player = gameState.player;
        const playerMatrix = createModelMatrix(player.position, player.rotation, [1, 1]);
        gl.uniformMatrix3fv(programInfo.uniformLocations.model, false, playerMatrix);
        gl.uniform4f(programInfo.uniformLocations.color, 0.9, 0.2, 0.2, 1.0);
        drawObject(gl, programInfo, sphereBuffer, sphereBuffer.numVertices);
    }

    // --- Helper Functions (mostly unchanged) ---
    function drawObject(gl, programInfo, buffer, vertexCount) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, vertexCount);
    }
    function createShaderProgram(gl, vsSource, fsSource) { /* ... no changes ... */
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }
    function loadShader(gl, type, source) { /* ... no changes ... */
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    function createCircleBuffer(gl, radius, segments) { /* ... no changes ... */
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        const vertices = [0.0, 0.0];
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * 2.0 * Math.PI;
            vertices.push(Math.cos(angle) * radius);
            vertices.push(Math.sin(angle) * radius);
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        buffer.numVertices = segments + 2;
        return buffer;
    }
    function createRectangleBuffer(gl) { /* ... no changes ... */
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        const vertices = [ 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        return buffer;
    }
    function createModelMatrix(translation, rotation, scale) { /* ... no changes ... */
        const [tx, ty] = translation;
        const [sx, sy] = scale;
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        return [ c * sx, s * sx, 0, -s * sy, c * sy, 0, tx, ty, 1 ];
    }
    function createViewMatrix(cameraPosition) { /* ... no changes ... */
        const [tx, ty] = cameraPosition;
        return [ 1, 0, 0, 0, 1, 0, -tx, -ty, 1 ];
    }
    function createProjectionMatrix(zoom, aspect) { /* ... no changes ... */
        return [ zoom / aspect, 0, 0, 0, zoom, 0, 0, 0, 1 ];
    }
    function resizeCanvasToDisplaySize(canvas) { /* ... no changes ... */
        const displayWidth  = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            return true;
        }
        return false;
    }
    // HACK: Need getInitialGameState to be accessible in update
    let getInitialGameState = () => {};
    // Re-assign inside main
    const originalMain = main;
    main = () => {
        getInitialGameState = originalMain().getInitialGameState;
        originalMain();
    }
    
    // NOTE: A cleaner way to handle the getInitialGameState in update would be to pass it as a parameter
    // or use a class-based structure for the game. For this single-file example, this makes it work.
    // The following is a cleaner implementation detail I'll integrate into the main block.
    // I will refactor `main` to define `getInitialGameState` outside so `update` can see it.
    
    </script>
    
    <script>
    // --- FINAL CLEANED SCRIPT ---
    (function() {
        // This IIFE (Immediately Invoked Function Expression) helps keep variables from polluting the global scope.
        
        let gameState = {};
        
        // Define this in a scope accessible by both main and update
        function getInitialGameState() {
            return {
                player: {
                    position: [0, 0.5], velocity: [0, 0], radius: 0.05,
                    rotation: 0, onGround: false
                },
                platforms: [
                    { position: [0, 0], scale: [3.0, 0.2] }, { position: [2, 0.5], scale: [0.8, 0.2] },
                    { position: [3.5, 0.8], scale: [0.8, 0.2] }, { position: [5, 0.5], scale: [0.8, 0.2] },
                    { position: [6.5, 1.0], scale: [0.2, 2.0] }, { position: [5.5, 2.5], scale: [0.8, 0.2] },
                    { position: [4, 3.0], scale: [0.8, 0.2] }, { position: [2.5, 3.5], scale: [0.8, 0.2] },
                    { position: [0, -1.5], scale: [2.0, 0.2] }, { position: [-2, -1.2], scale: [0.8, 0.2] },
                    { position: [-3.5, -1.0], scale: [0.8, 0.2] }, { position: [-5, -0.5], scale: [1.5, 0.2] },
                ],
                gravity: -0.0015, moveSpeed: 0.002, jumpForce: 0.030, downForce: -0.025,
                keys: {},
                touch: {
                    moveLeft: false, moveRight: false, jump: false, down: false,
                },
                camera: { position: [0, 0], zoom: 0.5 },
                levelBounds: { minX: -6.0, maxX: 7.0, minY: -3.0, maxY: 5.0, }
            };
        }

        window.onload = function main() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported!');
                return;
            }

            const vsSource = document.getElementById('vertex-shader').text;
            const fsSource = document.getElementById('fragment-shader').text;
            const shaderProgram = createShaderProgram(gl, vsSource, fsSource);

            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'a_position'),
                },
                uniformLocations: {
                    projection: gl.getUniformLocation(shaderProgram, 'u_projection'),
                    view: gl.getUniformLocation(shaderProgram, 'u_view'),
                    model: gl.getUniformLocation(shaderProgram, 'u_model'),
                    color: gl.getUniformLocation(shaderProgram, 'u_color'),
                },
            };

            const sphereBuffer = createCircleBuffer(gl, 0.05, 32);
            const platformBuffer = createRectangleBuffer(gl);

            gameState = getInitialGameState();

            window.addEventListener('keydown', (e) => gameState.keys[e.key] = true);
            window.addEventListener('keyup', (e) => gameState.keys[e.key] = false);
            
            document.getElementById('resetButton').addEventListener('click', () => {
                gameState = getInitialGameState();
            });

            function setupButtonControls(buttonId, touchKey) {
                const button = document.getElementById(buttonId);
                const setFlag = (val) => (e) => {
                    e.preventDefault();
                    gameState.touch[touchKey] = val;
                };
                button.addEventListener('touchstart', setFlag(true), { passive: false });
                button.addEventListener('touchend', setFlag(false), { passive: false });
                button.addEventListener('mousedown', setFlag(true));
                button.addEventListener('mouseup', setFlag(false));
                button.addEventListener('mouseleave', setFlag(false));
            }

            setupButtonControls('left-btn', 'moveLeft');
            setupButtonControls('right-btn', 'moveRight');
            setupButtonControls('up-btn', 'jump');
            setupButtonControls('down-btn', 'down');

            function render(now) {
                update(gl, gameState);
                drawScene(gl, programInfo, gameState, sphereBuffer, platformBuffer);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        function update(gl, state) {
            const player = state.player;

            if (state.keys['a'] || state.keys['ArrowLeft'] || state.touch.moveLeft) {
                player.velocity[0] = -state.moveSpeed;
                player.rotation += 0.1;
            } else if (state.keys['d'] || state.keys['ArrowRight'] || state.touch.moveRight) {
                player.velocity[0] = state.moveSpeed;
                player.rotation -= 0.1;
            } else {
                player.velocity[0] = 0;
            }

            if ((state.keys['w'] || state.keys['ArrowUp'] || state.keys[' '] || state.touch.jump) && player.onGround) {
                player.velocity[1] = state.jumpForce;
                player.onGround = false;
            }

            if (state.touch.down && !player.onGround) {
                player.velocity[1] = state.downForce;
            }
            
            player.velocity[1] += state.gravity;
            player.position[0] += player.velocity[0];
            player.position[1] += player.velocity[1];

            player.onGround = false;
            state.platforms.forEach(p => {
                const p_left = p.position[0] - p.scale[0] / 2;
                const p_right = p.position[0] + p.scale[0] / 2;
                const p_top = p.position[1] + p.scale[1] / 2;
                const p_bottom = p.position[1] - p.scale[1] / 2;
                
                if (player.position[0] + player.radius > p_left && player.position[0] - player.radius < p_right &&
                    player.position[1] - player.radius < p_top && 
                    player.position[1] - player.radius > p_bottom &&
                    player.velocity[1] <= 0) {
                    
                    player.position[1] = p_top + player.radius;
                    player.velocity[1] = 0;
                    player.onGround = true;
                }
            });

            if (player.position[1] < state.levelBounds.minY) {
                Object.assign(state, getInitialGameState());
            }

            const lerpFactor = 0.05;
            state.camera.position[0] += (player.position[0] - state.camera.position[0]) * lerpFactor;
            state.camera.position[1] += (player.position[1] - state.camera.position[1]) * lerpFactor;

            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const cameraHalfWidth = state.camera.zoom * aspect;
            const cameraHalfHeight = state.camera.zoom;
            state.camera.position[0] = Math.max(state.levelBounds.minX + cameraHalfWidth, Math.min(state.levelBounds.maxX - cameraHalfWidth, state.camera.position[0]));
            state.camera.position[1] = Math.max(state.levelBounds.minY + cameraHalfHeight, Math.min(state.levelBounds.maxY - cameraHalfHeight, state.camera.position[1]));
        }

        function drawScene(gl, programInfo, gameState, sphereBuffer, platformBuffer) {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0.1, 0.2, 0.3, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(programInfo.program);

            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const projectionMatrix = createProjectionMatrix(gameState.camera.zoom, aspect);
            const viewMatrix = createViewMatrix(gameState.camera.position);
            gl.uniformMatrix3fv(programInfo.uniformLocations.projection, false, projectionMatrix);
            gl.uniformMatrix3fv(programInfo.uniformLocations.view, false, viewMatrix);

            gameState.platforms.forEach(platform => {
                const modelMatrix = createModelMatrix(platform.position, 0, platform.scale);
                gl.uniformMatrix3fv(programInfo.uniformLocations.model, false, modelMatrix);
                gl.uniform4f(programInfo.uniformLocations.color, 0.4, 0.5, 0.4, 1.0);
                drawObject(gl, programInfo, platformBuffer, 6);
            });
            
            const player = gameState.player;
            const playerMatrix = createModelMatrix(player.position, player.rotation, [1, 1]);
            gl.uniformMatrix3fv(programInfo.uniformLocations.model, false, playerMatrix);
            gl.uniform4f(programInfo.uniformLocations.color, 0.9, 0.2, 0.2, 1.0);
            drawObject(gl, programInfo, sphereBuffer, sphereBuffer.numVertices);
        }

        function drawObject(gl, programInfo, buffer, vertexCount) { /* ... same as before ... */
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, vertexCount);
        }
        function createShaderProgram(gl, vsSource, fsSource) { /* ... same as before ... */
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }
        function loadShader(gl, type, source) { /* ... same as before ... */
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        function createCircleBuffer(gl, radius, segments) { /* ... same as before ... */
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const vertices = [0.0, 0.0];
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * 2.0 * Math.PI;
                vertices.push(Math.cos(angle) * radius);
                vertices.push(Math.sin(angle) * radius);
            }
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            buffer.numVertices = segments + 2;
            return buffer;
        }
        function createRectangleBuffer(gl) { /* ... same as before ... */
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            const vertices = [ 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            return buffer;
        }
        function createModelMatrix(translation, rotation, scale) { /* ... same as before ... */
            const [tx, ty] = translation;
            const [sx, sy] = scale;
            const c = Math.cos(rotation);
            const s = Math.sin(rotation);
            return [ c * sx, s * sx, 0, -s * sy, c * sy, 0, tx, ty, 1 ];
        }
        function createViewMatrix(cameraPosition) { /* ... same as before ... */
            const [tx, ty] = cameraPosition;
            return [ 1, 0, 0, 0, 1, 0, -tx, -ty, 1 ];
        }
        function createProjectionMatrix(zoom, aspect) { /* ... same as before ... */
            return [ zoom / aspect, 0, 0, 0, zoom, 0, 0, 0, 1 ];
        }
        function resizeCanvasToDisplaySize(canvas) { /* ... same as before ... */
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }
    })();
    </script>
</body>
</html>

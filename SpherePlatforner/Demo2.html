<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #333; }
        canvas { display: block; width: 100vw; height: 100vh; }
        /* NEW: Style for the reset button */
        #resetButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            font-size: 16px;
            background-color: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
        }
    </style>
</head>
<body>
    <button id="resetButton">Reset</button>
    <canvas id="glCanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        // NEW: u_projection handles aspect ratio, u_view is the camera, u_model is the object's transform
        uniform mat3 u_projection;
        uniform mat3 u_view;
        uniform mat3 u_model;

        void main() {
            // NEW: Final position is Projection * View * Model * Position
            vec3 transformedPosition = u_projection * u_view * u_model * vec3(a_position, 1.0);
            gl_Position = vec4(transformedPosition.xy, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec4 u_color;
        void main() {
            gl_FragColor = u_color;
        }
    </script>

    <script>
    window.onload = main;

    function main() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGL not supported!');
            return;
        }

        const vsSource = document.getElementById('vertex-shader').text;
        const fsSource = document.getElementById('fragment-shader').text;
        const shaderProgram = createShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'a_position'),
            },
            uniformLocations: {
                // NEW: Uniforms for model, view, and projection matrices
                projection: gl.getUniformLocation(shaderProgram, 'u_projection'),
                view: gl.getUniformLocation(shaderProgram, 'u_view'),
                model: gl.getUniformLocation(shaderProgram, 'u_model'),
                color: gl.getUniformLocation(shaderProgram, 'u_color'),
            },
        };

        const sphereBuffer = createCircleBuffer(gl, 0.05, 32);
        const platformBuffer = createRectangleBuffer(gl);

        // --- Game State ---
        // NEW: Encapsulated initial state into a function for easy resetting
        function getInitialGameState() {
            return {
                player: {
                    position: [0, 0.5],
                    velocity: [0, 0],
                    radius: 0.05,
                    rotation: 0,
                    onGround: false
                },
                // NEW: Bigger level
                platforms: [
                    // Start area
                    { position: [0, 0], scale: [3.0, 0.2] },
                    { position: [2, 0.5], scale: [0.8, 0.2] },
                    { position: [3.5, 0.8], scale: [0.8, 0.2] },
                    { position: [5, 0.5], scale: [0.8, 0.2] },
                    // Vertical section
                    { position: [6.5, 1.0], scale: [0.2, 2.0] },
                    { position: [5.5, 2.5], scale: [0.8, 0.2] },
                    { position: [4, 3.0], scale: [0.8, 0.2] },
                    { position: [2.5, 3.5], scale: [0.8, 0.2] },
                    // Long drop
                    { position: [0, -1.5], scale: [2.0, 0.2] },
                    { position: [-2, -1.2], scale: [0.8, 0.2] },
                    { position: [-3.5, -1.0], scale: [0.8, 0.2] },
                    // Final platform
                    { position: [-5, -0.5], scale: [1.5, 0.2] },
                ],
                gravity: -0.0015,
                moveSpeed: 0.002,
                jumpForce: 0.030,
                downForce: -0.025, // NEW: Force for swiping down
                keys: {},
                // NEW: Touch state management
                touch: {
                    active: false,
                    isSwiping: false,
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    moveLeft: false,
                    moveRight: false,
                },
                // NEW: Camera state
                camera: {
                    position: [0, 0],
                    zoom: 0.5 // Lower value = more zoomed in
                },
                // NEW: Level boundaries
                levelBounds: {
                    minX: -6.0,
                    maxX: 7.0,
                    minY: -3.0, // Fall below this to reset
                    maxY: 5.0,
                }
            };
        }

        let gameState = getInitialGameState();

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => gameState.keys[e.key] = true);
        window.addEventListener('keyup', (e) => gameState.keys[e.key] = false);
        
        // NEW: Reset button logic
        document.getElementById('resetButton').addEventListener('click', () => {
            gameState = getInitialGameState();
        });

        // NEW: Touch Controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            gameState.touch.active = true;
            gameState.touch.isSwiping = false;
            gameState.touch.startX = touch.clientX;
            gameState.touch.startY = touch.clientY;
            gameState.touch.currentX = touch.clientX;
            
            if (touch.clientX < window.innerWidth / 2) {
                gameState.touch.moveLeft = true;
                gameState.touch.moveRight = false;
            } else {
                gameState.touch.moveLeft = false;
                gameState.touch.moveRight = true;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!gameState.touch.active) return;
            const touch = e.touches[0];
            gameState.touch.currentX = touch.clientX;
            const deltaY = touch.clientY - gameState.touch.startY;
            if (Math.abs(deltaY) > 40) { // Threshold to detect a swipe
                gameState.touch.isSwiping = true;
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!gameState.touch.active) return;

            const deltaY = e.changedTouches[0].clientY - gameState.touch.startY;
            
            // Check for swipe up (jump) or swipe down (force down)
            if (gameState.touch.isSwiping) {
                if (deltaY < -50 && gameState.player.onGround) { // Swipe Up
                    gameState.player.velocity[1] = gameState.jumpForce;
                    gameState.player.onGround = false;
                } else if (deltaY > 50) { // Swipe Down
                    gameState.player.velocity[1] = gameState.downForce;
                }
            }

            gameState.touch.active = false;
            gameState.touch.moveLeft = false;
            gameState.touch.moveRight = false;
        }, { passive: false });

        function render(now) {
            update(gameState);
            drawScene(gl, programInfo, gameState, sphereBuffer, platformBuffer);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    }

    // --- Core Update and Drawing Functions ---

    function update(state) {
        const player = state.player;

        // Horizontal Movement (Keyboard OR Touch)
        if (state.keys['a'] || state.keys['ArrowLeft'] || state.touch.moveLeft) {
            player.velocity[0] = -state.moveSpeed;
            player.rotation += 0.1;
        } else if (state.keys['d'] || state.keys['ArrowRight'] || state.touch.moveRight) {
            player.velocity[0] = state.moveSpeed;
            player.rotation -= 0.1;
        } else {
            player.velocity[0] = 0;
        }

        // Jumping (Keyboard only, swipe handles touch jump)
        if ((state.keys['w'] || state.keys['ArrowUp'] || state.keys[' ']) && player.onGround) {
            player.velocity[1] = state.jumpForce;
            player.onGround = false;
        }
        
        player.velocity[1] += state.gravity;
        player.position[0] += player.velocity[0];
        player.position[1] += player.velocity[1];

        player.onGround = false;
        state.platforms.forEach(p => {
            const p_left = p.position[0] - p.scale[0] / 2;
            const p_right = p.position[0] + p.scale[0] / 2;
            const p_top = p.position[1] + p.scale[1] / 2;
            const p_bottom = p.position[1] - p.scale[1] / 2;
            
            if (player.position[0] + player.radius > p_left && player.position[0] - player.radius < p_right &&
                player.position[1] - player.radius < p_top && 
                player.position[1] - player.radius > p_bottom &&
                player.velocity[1] <= 0) {
                
                player.position[1] = p_top + player.radius;
                player.velocity[1] = 0;
                player.onGround = true;
            }
        });

        // NEW: Reset if player falls out of bounds
        if (player.position[1] < state.levelBounds.minY) {
            // A bit of a hack: directly modify the global state object.
            // In a larger app, you'd use a more robust state management system.
            Object.assign(gameState, getInitialGameState());
        }

        // NEW: Update Camera with soft follow (Lerp)
        const lerpFactor = 0.05;
        state.camera.position[0] += (player.position[0] - state.camera.position[0]) * lerpFactor;
        state.camera.position[1] += (player.position[1] - state.camera.position[1]) * lerpFactor;

        // NEW: Clamp camera to level boundaries
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const cameraHalfWidth = state.camera.zoom * aspect;
        const cameraHalfHeight = state.camera.zoom;
        state.camera.position[0] = Math.max(state.levelBounds.minX + cameraHalfWidth, Math.min(state.levelBounds.maxX - cameraHalfWidth, state.camera.position[0]));
        state.camera.position[1] = Math.max(state.levelBounds.minY + cameraHalfHeight, Math.min(state.levelBounds.maxY - cameraHalfHeight, state.camera.position[1]));
    }

    function drawScene(gl, programInfo, gameState, sphereBuffer, platformBuffer) {
        resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0.1, 0.2, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);

        // NEW: Set up projection and view matrices
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const projectionMatrix = createProjectionMatrix(gameState.camera.zoom, aspect);
        const viewMatrix = createViewMatrix(gameState.camera.position);

        gl.uniformMatrix3fv(programInfo.uniformLocations.projection, false, projectionMatrix);
        gl.uniformMatrix3fv(programInfo.uniformLocations.view, false, viewMatrix);

        // Draw Platforms
        gameState.platforms.forEach(platform => {
            const modelMatrix = createModelMatrix(platform.position, 0, platform.scale);
            gl.uniformMatrix3fv(programInfo.uniformLocations.model, false, modelMatrix);
            gl.uniform4f(programInfo.uniformLocations.color, 0.4, 0.5, 0.4, 1.0);
            drawObject(gl, programInfo, platformBuffer, 6);
        });
        
        // Draw Player Sphere
        const player = gameState.player;
        const playerMatrix = createModelMatrix(player.position, player.rotation, [1, 1]); // Sphere model is already sized by radius
        gl.uniformMatrix3fv(programInfo.uniformLocations.model, false, playerMatrix);
        gl.uniform4f(programInfo.uniformLocations.color, 0.9, 0.2, 0.2, 1.0);
        drawObject(gl, programInfo, sphereBuffer, sphereBuffer.numVertices);
    }

    function drawObject(gl, programInfo, buffer, vertexCount) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, vertexCount);
    }

    // --- WebGL & Geometry Helper Functions ---
    // (createShaderProgram, loadShader, createCircleBuffer, createRectangleBuffer are unchanged)
    function createShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    function createCircleBuffer(gl, radius, segments) {
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        const vertices = [0.0, 0.0];
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * 2.0 * Math.PI;
            vertices.push(Math.cos(angle) * radius);
            vertices.push(Math.sin(angle) * radius);
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        buffer.numVertices = segments + 2;
        return buffer;
    }

    function createRectangleBuffer(gl) {
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        const vertices = [ 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        return buffer;
    }

    // --- NEW and MODIFIED Matrix Helper Functions ---

    // Renamed from createTransformMatrix to createModelMatrix for clarity
    function createModelMatrix(translation, rotation, scale) {
        const [tx, ty] = translation;
        const [sx, sy] = scale;
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        return [ c * sx, s * sx, 0, -s * sy, c * sy, 0, tx, ty, 1 ];
    }

    // NEW: Creates the camera's view matrix (inverse of camera's transform)
    function createViewMatrix(cameraPosition) {
        const [tx, ty] = cameraPosition;
        return [ 1, 0, 0, 0, 1, 0, -tx, -ty, 1 ];
    }
    
    // NEW: Creates a projection matrix to handle aspect ratio and zoom
    function createProjectionMatrix(zoom, aspect) {
        return [ zoom / aspect, 0, 0, 0, zoom, 0, 0, 0, 1 ];
    }

    function resizeCanvasToDisplaySize(canvas) {
        const displayWidth  = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            return true;
        }
        return false;
    }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer</title>
    <style>
        /* Basic styling to make the canvas and controls fill the screen */
        body { 
            margin: 0; 
            background-color: #000;
            overflow: hidden; /* Prevents scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }
        /* Styles for the on-screen touch controls */
        #touch-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            user-select: none; /* Prevents text selection on buttons */
        }
        .control-group {
            display: flex;
            gap: 20px;
        }
        .control-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
            font-family: sans-serif;
        }
        /* Style for when a button is being pressed */
        .control-button:active {
            background-color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <!-- The canvas where the game is rendered -->
    <canvas id="glCanvas"></canvas>

    <!-- HTML elements for the on-screen touch controls -->
    <div id="touch-controls">
        <div class="control-group">
            <div id="left-btn" class="control-button">◀</div>
            <div id="right-btn" class="control-button">▶</div>
        </div>
        <div class="control-group">
            <div id="action-btn" class="control-button">E</div>
            <div id="jump-btn" class="control-button">▲</div>
        </div>
    </div>

    <script>
        // Entry point
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                // Use a custom message box instead of alert
                const msgBox = document.createElement('div');
                msgBox.textContent = 'Unable to initialize WebGL. Your browser may not support it.';
                msgBox.style.position = 'fixed';
                msgBox.style.top = '50%';
                msgBox.style.left = '50%';
                msgBox.style.transform = 'translate(-50%, -50%)';
                msgBox.style.padding = '20px';
                msgBox.style.backgroundColor = 'red';
                msgBox.style.color = 'white';
                document.body.appendChild(msgBox);
                return;
            }

            // --- 1. Shaders (GLSL Code) ---
            const vsSource = `
                attribute vec4 aVertexPosition;
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 uObjectColor;
                void main() {
                    gl_FragColor = uObjectColor;
                }
            `;

            // --- 2. Shader Program Setup ---
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    objectColor: gl.getUniformLocation(shaderProgram, 'uObjectColor'),
                },
            };

            // --- 3. Geometry Buffer ---
            const squareBuffer = initBuffers(gl);

            // --- 4. Game State and Objects ---
            const player = {
                x: 100, y: 300, width: 30, height: 30,
                vx: 0, vy: 0,
                color: [1.0, 1.0, 1.0, 1.0], // White
                canJump: false,
                hasTrash: false
            };

            const trashCan = {
                x: 600, y: 100, width: 25, height: 40,
                color: [0.1, 0.8, 0.2, 1.0] // Green
            };

            const platforms = [
                { x: 0, y: 0, width: 800, height: 50, color: [0.5, 0.5, 0.5, 1.0] }, // Floor
                { x: 200, y: 150, width: 150, height: 20, color: [0.5, 0.5, 0.5, 1.0] },
                { x: 450, y: 250, width: 200, height: 20, color: [0.5, 0.5, 0.5, 1.0] },
                { x: 50, y: 350, width: 100, height: 20, color: [0.5, 0.5, 0.5, 1.0] }
            ];

            // --- 5. Game Logic Variables ---
            const gravity = -0.5;
            const jumpStrength = 12;
            const moveSpeed = 5;
            let keys = {};

            // --- 6. Input Handling ---
            // Keyboard events
            window.addEventListener('keydown', (e) => { keys[e.key] = true; });
            window.addEventListener('keyup', (e) => { keys[e.key] = false; });
            
            // NEW: Touch control setup
            setupTouchControls();

            // --- 7. Main Game Loop ---
            let lastTime = 0;
            function gameLoop(currentTime) {
                currentTime *= 0.001; // convert to seconds
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                update(deltaTime);
                drawScene(gl, programInfo, squareBuffer);

                requestAnimationFrame(gameLoop);
            }

            // --- 8. Update Function ---
            function update(deltaTime) {
                // Store previous position for collision resolution
                const prevPlayerY = player.y;

                // Horizontal movement (checks for both keyboard and touch)
                player.vx = 0;
                if (keys['a'] || keys['ArrowLeft']) {
                    player.vx = -moveSpeed;
                }
                if (keys['d'] || keys['ArrowRight']) {
                    player.vx = moveSpeed;
                }
                player.x += player.vx;

                // Jumping (checks for both keyboard and touch)
                if ((keys['w'] || keys['ArrowUp'] || keys[' ']) && player.canJump) {
                    player.vy = jumpStrength;
                    player.canJump = false;
                }
                
                // Interaction (pickup/drop, checks for both keyboard and touch)
                if (keys['e']) {
                    const dist = Math.sqrt(Math.pow(player.x - trashCan.x, 2) + Math.pow(player.y - trashCan.y, 2));
                    if (dist < 50 && !player.hasTrash) {
                        player.hasTrash = true;
                    } else if (player.hasTrash) {
                        player.hasTrash = false;
                        trashCan.x = player.x + player.width; // Drop it to the side
                    }
                    keys['e'] = false; // Prevent holding down key, important for touch
                }

                // Apply gravity
                player.vy += gravity;
                player.y += player.vy;

                // Collision detection with platforms (IMPROVED)
                player.canJump = false;
                for (const platform of platforms) {
                    if (isColliding(player, platform)) {
                        // Check if player was above the platform in the previous frame
                        if (player.vy <= 0 && prevPlayerY >= (platform.y + platform.height)) {
                           player.y = platform.y + platform.height; // Snap to top of platform
                           player.vy = 0;
                           player.canJump = true;
                           break; // Exit loop after resolving one collision
                        }
                        // Optional: Add checks for hitting from below or sides if needed
                    }
                }
                
                // Update trash can position if held
                if (player.hasTrash) {
                    trashCan.x = player.x;
                    trashCan.y = player.y + player.height;
                }
            }

            // --- 9. Drawing Function ---
            function drawScene(gl, programInfo, buffer) {
                resizeCanvasToDisplaySize(gl.canvas);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.clearColor(0.1, 0.1, 0.2, 1.0); // Dark blue background
                gl.clear(gl.COLOR_BUFFER_BIT);

                const projectionMatrix = mat4.create();
                mat4.ortho(projectionMatrix, 0, gl.canvas.width, 0, gl.canvas.height, -1, 1);

                gl.useProgram(programInfo.program);
                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);

                platforms.forEach(p => drawObject(gl, programInfo, buffer, p));
                drawObject(gl, programInfo, buffer, trashCan);
                drawObject(gl, programInfo, buffer, player);
            }

            // --- NEW: Function to set up touch event listeners ---
            function setupTouchControls() {
                const leftBtn = document.getElementById('left-btn');
                const rightBtn = document.getElementById('right-btn');
                const jumpBtn = document.getElementById('jump-btn');
                const actionBtn = document.getElementById('action-btn');

                // Left Button
                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowLeft'] = true; }, { passive: false });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowLeft'] = false; }, { passive: false });
                
                // Right Button
                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['ArrowRight'] = true; }, { passive: false });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['ArrowRight'] = false; }, { passive: false });

                // Jump Button
                jumpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[' '] = true; }, { passive: false });
                jumpBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys[' '] = false; }, { passive: false });

                // Action Button
                actionBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys['e'] = true; }, { passive: false });
                // Note: 'e' key is set to false immediately after use in update(), so touchend is not strictly necessary here.
                actionBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys['e'] = false; }, { passive: false });
            }

            // Start the game
            requestAnimationFrame(gameLoop);
        }

        // ===================================================================
        //                      HELPER FUNCTIONS
        // ===================================================================

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Shader program link error:', gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [ 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5 ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return positionBuffer;
        }

        function drawObject(gl, programInfo, buffer, object) {
            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [object.x + object.width / 2, object.y + object.height / 2, 0]);
            mat4.scale(modelViewMatrix, modelViewMatrix, [object.width, object.height, 1]);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
            gl.uniform4fv(programInfo.uniformLocations.objectColor, object.color);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        const mat4 = {
          create: function() { return new Float32Array(16); },
          ortho: function(out, left, right, bottom, top, near, far) {
            let lr = 1 / (left - right); let bt = 1 / (bottom - top); let nf = 1 / (near - far);
            out[0] = -2 * lr; out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = -2 * bt; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = 2 * nf; out[11] = 0;
            out[12] = (left + right) * lr; out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf; out[15] = 1;
            return out;
          },
          translate: function(out, a, v) {
            let x = v[0], y = v[1];
            out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
            out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
            out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
            out[12] = a[0] * x + a[4] * y + a[8] * v[2] + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * v[2] + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * v[2] + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * v[2] + a[15];
            return out;
          },
          scale: function(out, a, v) {
            out[0] = a[0] * v[0]; out[1] = a[1] * v[0]; out[2] = a[2] * v[0]; out[3] = a[3] * v[0];
            out[4] = a[4] * v[1]; out[5] = a[5] * v[1]; out[6] = a[6] * v[1]; out[7] = a[7] * v[1];
            out[8] = a[8] * v[2]; out[9] = a[9] * v[2]; out[10] = a[10] * v[2]; out[11] = a[11] * v[2];
            out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            return out;
          }
        };
    </script>
</body>
</html>

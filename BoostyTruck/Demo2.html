<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Boosty: Mobile Gas Station Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none; /* Let touches pass through if not on buttons */
            z-index: 10;
        }
        h1 { margin: 0 0 10px 0; font-size: 20px; color: #00d2ff; }
        #health-bar {
            width: 200px;
            height: 20px;
            background: #444;
            border: 2px solid #fff;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background: #0f0;
            transition: width 0.2s, background 0.2s;
        }

        /* Mobile Controls Styling */
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            z-index: 20;
            user-select: none;
        }
        .btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 24px;
            text-align: center;
            line-height: 50px;
            cursor: pointer;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active, .btn.pressed {
            background: rgba(0, 210, 255, 0.5);
            border-color: #00d2ff;
        }
        #btn-up { top: 0; left: 50px; }
        #btn-down { bottom: 0; left: 50px; }
        #btn-left { top: 50px; left: 0; }
        #btn-right { top: 50px; right: 0; }

        @media (max-width: 600px) {
            #ui {
                width: calc(100% - 40px);
                box-sizing: border-box;
                font-size: 14px;
            }
            #health-bar { width: 100%; }
        }
    </style>
</head>
<body>

<div id="ui">
    <h1>Boosty Simulator 2025</h1>
    <div>Hull Integrity:</div>
    <div id="health-bar"><div id="health-fill"></div></div>
    <p>Use <b>Arrow Keys</b> or <b>Buttons</b> to drive.</p>
    <p id="status">Delivering Gas...</p>
</div>

<div id="controls">
    <div class="btn" id="btn-up">▲</div>
    <div class="btn" id="btn-left">◀</div>
    <div class="btn" id="btn-right">▶</div>
    <div class="btn" id="btn-down">▼</div>
</div>

<canvas id="glcanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    
    uniform vec2 u_resolution;
    uniform vec2 u_translation;
    uniform vec2 u_scale;
    
    void main() {
        vec2 position = a_position * u_scale;
        position = position + u_translation;
        vec2 zeroToOne = position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
/**
 * ENGINE SETUP
 */
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) { alert("WebGL not supported"); }

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

const vsSource = document.getElementById("vs").text;
const fsSource = document.getElementById("fs").text;
const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
const colorLocation = gl.getUniformLocation(program, "u_color");
const translationLocation = gl.getUniformLocation(program, "u_translation");
const scaleLocation = gl.getUniformLocation(program, "u_scale");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1,
]), gl.STATIC_DRAW);

/**
 * GAME LOGIC
 */

const TILE_SIZE = 50;
const MAP_WIDTH = 20;
const MAP_HEIGHT = 15;
const MAX_HEALTH = 5;

let keys = {};
let lastTime = 0;
let gameOver = false;
let shakeTime = 0;

const boosty = {
    x: 100, y: 100, w: 40, h: 60,
    vx: 0, vy: 0, speed: 300,
    color: [0.0, 0.8, 1.0, 1.0], 
    health: MAX_HEALTH
};

const particles = [];
const traffic = [];
const buildings = [];

// Map Generation
const mapGrid = [];
for(let y=0; y<MAP_HEIGHT; y++) {
    const row = [];
    for(let x=0; x<MAP_WIDTH; x++) {
        if(x % 4 === 0 || y % 4 === 0) {
            row.push(0); 
        } else {
            row.push(1); 
            buildings.push({
                x: x * TILE_SIZE,
                y: y * TILE_SIZE,
                w: TILE_SIZE,
                h: TILE_SIZE,
                color: [0.5, 0.5, 0.5, 1.0]
            });
        }
    }
    mapGrid.push(row);
}

// Spawn Traffic
for(let i=0; i<8; i++) {
    let rx, ry;
    do {
        rx = Math.floor(Math.random() * MAP_WIDTH);
        ry = Math.floor(Math.random() * MAP_HEIGHT);
    } while(mapGrid[ry][rx] !== 0);

    traffic.push({
        x: rx * TILE_SIZE + 5,
        y: ry * TILE_SIZE + 5,
        w: 30, h: 30,
        vx: (Math.random() > 0.5 ? 100 : -100) * (Math.random() > 0.5 ? 1 : 0),
        vy: (Math.random() > 0.5 ? 100 : -100) * (Math.random() > 0.5 ? 0 : 1),
        color: [1.0, 0.2, 0.2, 1.0] 
    });
}

// Keyboard Input
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// Touch Input Handler
function setupTouchButton(id, keyCode) {
    const btn = document.getElementById(id);
    const start = (e) => {
        e.preventDefault(); // Prevent scrolling/zooming
        keys[keyCode] = true;
        btn.classList.add('pressed');
    };
    const end = (e) => {
        e.preventDefault();
        keys[keyCode] = false;
        btn.classList.remove('pressed');
    };

    btn.addEventListener('touchstart', start, {passive: false});
    btn.addEventListener('touchend', end, {passive: false});
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseout', end);
}

setupTouchButton('btn-up', 'ArrowUp');
setupTouchButton('btn-down', 'ArrowDown');
setupTouchButton('btn-left', 'ArrowLeft');
setupTouchButton('btn-right', 'ArrowRight');


function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h || 
             r2.y + r2.h < r1.y);
}

function spawnExplosion(x, y) {
    for(let i=0; i<50; i++) {
        particles.push({
            x: x + 20, y: y + 30,
            vx: (Math.random() - 0.5) * 500,
            vy: (Math.random() - 0.5) * 500,
            life: 1.0 + Math.random(),
            w: 10, h: 10,
            color: [1.0, 0.5 + Math.random()*0.5, 0.0, 1.0]
        });
    }
}

function update(dt) {
    if (gameOver) {
        particles.forEach(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.life -= dt;
        });
        return;
    }

    boosty.vx = 0;
    boosty.vy = 0;
    if (keys['ArrowUp']) boosty.vy = -boosty.speed;
    if (keys['ArrowDown']) boosty.vy = boosty.speed;
    if (keys['ArrowLeft']) boosty.vx = -boosty.speed;
    if (keys['ArrowRight']) boosty.vx = boosty.speed;

    let nextX = boosty.x + boosty.vx * dt;
    let nextY = boosty.y + boosty.vy * dt;

    if (nextX < 0) nextX = 0;
    if (nextX > canvas.width - boosty.w) nextX = canvas.width - boosty.w;
    if (nextY < 0) nextY = 0;
    if (nextY > canvas.height - boosty.h) nextY = canvas.height - boosty.h;

    let collided = false;
    let testRectX = { x: nextX, y: boosty.y, w: boosty.w, h: boosty.h };
    for (let b of buildings) {
        if (rectIntersect(testRectX, b)) {
            nextX = boosty.x; 
            collided = true;
            break;
        }
    }
    let testRectY = { x: nextX, y: nextY, w: boosty.w, h: boosty.h };
    for (let b of buildings) {
        if (rectIntersect(testRectY, b)) {
            nextY = boosty.y; 
            collided = true;
            break;
        }
    }

    boosty.x = nextX;
    boosty.y = nextY;

    for(let car of traffic) {
        car.x += car.vx * dt;
        car.y += car.vy * dt;

        if(car.x <= 0 || car.x >= canvas.width - car.w) car.vx *= -1;
        if(car.y <= 0 || car.y >= canvas.height - car.h) car.vy *= -1;

        for(let b of buildings) {
            if(rectIntersect(car, b)) {
                car.vx *= -1;
                car.vy *= -1;
                car.x += car.vx * dt * 2;
                car.y += car.vy * dt * 2;
            }
        }

        if(rectIntersect(boosty, car)) {
            collided = true;
            boosty.x -= boosty.vx * dt * 5;
            boosty.y -= boosty.vy * dt * 5;
            car.vx *= -1;
            car.vy *= -1;
        }
    }

    if (collided) {
        handleDamage();
    }

    if(shakeTime > 0) shakeTime -= dt;
}

function handleDamage() {
    if(shakeTime <= 0) {
        boosty.health--;
        shakeTime = 0.5; 
        updateUI();
        
        if (boosty.health <= 0) {
            explodeBoosty();
        }
    }
}

function explodeBoosty() {
    gameOver = true;
    document.getElementById("status").innerText = "BOOSTY HAS EXPLODED!";
    document.getElementById("status").style.color = "red";
    spawnExplosion(boosty.x, boosty.y);
    boosty.w = 0; 
}

function updateUI() {
    const fill = document.getElementById("health-fill");
    const pct = (boosty.health / MAX_HEALTH) * 100;
    fill.style.width = pct + "%";
    if(pct < 30) fill.style.background = "red";
    else if(pct < 60) fill.style.background = "orange";
}

function drawRect(x, y, w, h, color) {
    gl.uniform2f(translationLocation, x, y);
    gl.uniform2f(scaleLocation, w, h);
    gl.uniform4fv(colorLocation, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function render() {
    if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    gl.clearColor(0.15, 0.15, 0.15, 1.0); 
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(program);
    gl.enableVertexAttribArray(positionLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

    let shakeX = 0, shakeY = 0;
    if(shakeTime > 0) {
        shakeX = (Math.random() - 0.5) * 20;
        shakeY = (Math.random() - 0.5) * 20;
    }

    for (let b of buildings) {
        drawRect(b.x + shakeX, b.y + shakeY, b.w, b.h, b.color);
    }

    for (let car of traffic) {
        drawRect(car.x + shakeX, car.y + shakeY, car.w, car.h, car.color);
    }

    if (boosty.health > 0) {
        drawRect(boosty.x + shakeX, boosty.y + shakeY, boosty.w, boosty.h, boosty.color);
        drawRect(boosty.x + 5 + shakeX, boosty.y + 5 + shakeY, boosty.w - 10, boosty.h - 20, [1.0, 1.0, 1.0, 0.5]);
    }

    for (let p of particles) {
        if (p.life > 0) {
            drawRect(p.x, p.y, p.w, p.h, p.color);
        }
    }
}

function loop(timestamp) {
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if(dt > 0.1) dt = 0.1; 

    update(dt);
    render();
    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

</script>
</body>
</html>

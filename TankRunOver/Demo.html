<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL RTS: Tank vs Soldiers</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            user-select: none;
        }
        h1 { margin: 0 0 5px 0; font-size: 20px; }
    </style>
</head>
<body>

<div id="ui">
    <h1>RTS Tank Commander</h1>
    <p>Right-Click to Move</p>
    <p>Score: <span id="score">0</span></p>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- Global Variables ---
    let scene, camera, renderer;
    let tank, ground;
    let soldiers = [];
    let raycaster, mouse;
    let targetPosition = new THREE.Vector3();
    let isMoving = false;
    let score = 0;
    
    const TANK_SPEED = 0.15;
    const TURN_SPEED = 0.1;
    const SOLDIER_COUNT = 20;

    // --- Initialization ---
    function init() {
        // 1. Setup Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        // 2. Setup Camera (Isometric view)
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);

        // 3. Setup Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 4. Lighting
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        scene.add(dirLight);

        // 5. Create Game Objects
        createGround();
        createTank();
        spawnSoldiers();

        // 6. Interaction
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Prevent context menu on right click
        window.addEventListener('contextmenu', event => event.preventDefault());
        window.addEventListener('pointerdown', onMouseClick);
        window.addEventListener('resize', onWindowResize);

        // 7. Start Loop
        animate();
    }

    // --- Object Creation ---

    function createGround() {
        const geometry = new THREE.PlaneGeometry(100, 100);
        const material = new THREE.MeshStandardMaterial({ color: 0x3b7d3b }); // Dark Green
        ground = new THREE.Mesh(geometry, material);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
    }

    function createTank() {
        tank = new THREE.Group();

        // Tank Body
        const bodyGeo = new THREE.BoxGeometry(2, 1, 3);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2E4053 }); // Dark Slate
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.5;
        body.castShadow = true;
        tank.add(body);

        // Turret
        const turretGeo = new THREE.BoxGeometry(1.2, 0.8, 1.5);
        const turretMat = new THREE.MeshStandardMaterial({ color: 0x5D6D7E });
        const turret = new THREE.Mesh(turretGeo, turretMat);
        turret.position.y = 1.4;
        turret.castShadow = true;
        tank.add(turret);

        // Barrel
        const barrelGeo = new THREE.CylinderGeometry(0.2, 0.2, 2.5);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x1B2631 });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 1.4, 1.5); // Stick out front
        tank.add(barrel);

        scene.add(tank);
        
        // Initial position
        tank.position.set(0, 0, 0);
        targetPosition.copy(tank.position);
    }

    function spawnSoldiers() {
        const geometry = new THREE.CapsuleGeometry(0.3, 1, 4, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0x922B21 }); // Red

        for (let i = 0; i < SOLDIER_COUNT; i++) {
            const soldier = new THREE.Mesh(geometry, material.clone());
            
            // Random position
            const x = (Math.random() - 0.5) * 40;
            const z = (Math.random() - 0.5) * 40;
            
            soldier.position.set(x, 0.8, z);
            soldier.castShadow = true;
            
            // Custom properties for game logic
            soldier.userData = {
                alive: true,
                walkSpeed: 0.02 + Math.random() * 0.03,
                walkDir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize()
            };

            scene.add(soldier);
            soldiers.push(soldier);
        }
    }

    // --- Game Logic ---

    function onMouseClick(event) {
        // Only react to Right Click (button 2)
        if (event.button !== 2) return;

        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObject(ground);

        if (intersects.length > 0) {
            targetPosition.copy(intersects[0].point);
            isMoving = true;
            
            // Add a small visual marker at target
            createClickMarker(targetPosition);
        }
    }

    function createClickMarker(pos) {
        const geo = new THREE.RingGeometry(0.5, 0.6, 32);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        const marker = new THREE.Mesh(geo, mat);
        marker.position.copy(pos);
        marker.position.y = 0.05; // Slightly above ground
        marker.rotation.x = -Math.PI / 2;
        scene.add(marker);

        // Remove marker after 1 second
        setTimeout(() => { scene.remove(marker); geo.dispose(); mat.dispose(); }, 500);
    }

    function moveTank() {
        if (!isMoving) return;

        const direction = new THREE.Vector3().subVectors(targetPosition, tank.position);
        direction.y = 0; // Keep movement on flat plane
        const distance = direction.length();

        if (distance < 0.2) {
            isMoving = false;
            return;
        }

        direction.normalize();

        // Smooth rotation using quaternions
        const targetRotation = new THREE.Quaternion();
        const lookMatrix = new THREE.Matrix4().lookAt(tank.position, targetPosition, tank.up);
        targetRotation.setFromRotationMatrix(lookMatrix);
        tank.quaternion.slerp(targetRotation, TURN_SPEED);

        // Move
        tank.position.add(direction.multiplyScalar(TANK_SPEED));
    }

    function updateSoldiers() {
        soldiers.forEach(soldier => {
            if (!soldier.userData.alive) return;

            // 1. AI Movement (Wander)
            soldier.position.add(soldier.userData.walkDir.clone().multiplyScalar(soldier.userData.walkSpeed));
            
            // Turn around if hitting bounds
            if (Math.abs(soldier.position.x) > 25 || Math.abs(soldier.position.z) > 25) {
                soldier.userData.walkDir.multiplyScalar(-1);
            }
            
            // Random direction change
            if (Math.random() < 0.02) {
                 soldier.userData.walkDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            }

            // 2. Collision Detection with Tank
            const dist = tank.position.distanceTo(soldier.position);
            
            // If tank is close enough (simple radius check)
            if (dist < 1.5) {
                crushSoldier(soldier);
            }
        });
    }

    function crushSoldier(soldier) {
        soldier.userData.alive = false;
        
        // Visual effect: Flatten the soldier
        soldier.scale.set(1.5, 0.1, 1.5);
        soldier.position.y = 0.1; // Move to ground level
        soldier.material.color.setHex(0x550000); // Dark blood red

        // Update score
        score++;
        document.getElementById('score').innerText = score;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        moveTank();
        updateSoldiers();
        
        // Camera follow tank (optional, gives RTS feel)
        // camera.position.x = tank.position.x;
        // camera.position.z = tank.position.z + 20;

        renderer.render(scene, camera);
    }

    // Boot
    init();

</script>
</body>
</html>

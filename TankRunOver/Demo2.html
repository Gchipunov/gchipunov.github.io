<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL RTS: Tank Mobile Controls</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #ui, #controls {
            position: absolute;
            color: white;
            padding: 10px;
            pointer-events: none; /* Allows clicks to pass through to canvas if needed */
            user-select: none;
        }

        /* Info UI */
        #ui {
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        h1 { margin: 0 0 5px 0; font-size: 20px; }

        /* Mobile Controls UI */
        #controls {
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: all; /* Important: Allows buttons to be touched */
            max-width: 400px; /* Limit width on desktop for better visibility */
            margin: 0 auto;
        }

        .dpad-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(50, 50, 50, 0.7);
            color: white;
            font-size: 20px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.5);
            touch-action: manipulation; /* Prevents default browser actions */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Layout for Left Stick (Turning) */
        #turn-controls {
            display: flex;
            gap: 10px;
        }

        /* Layout for Right Stick (Movement) */
        #move-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #move-controls .dpad-button:last-child {
            margin-top: 10px;
        }

    </style>
</head>
<body>

<div id="ui">
    <h1>RTS Tank Commander</h1>
    <p>Tap/Right-Click: Target Move</p>
    <p>Score: <span id="score">0</span></p>
</div>

<div id="controls">
    <div id="turn-controls">
        <button id="turn-left" class="dpad-button">↶</button>
        <button id="turn-right" class="dpad-button">↷</button>
    </div>
    <div id="move-controls">
        <button id="move-forward" class="dpad-button">▲</button>
        <button id="move-backward" class="dpad-button">▼</button>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- Global Variables ---
    let scene, camera, renderer;
    let tank, ground;
    let soldiers = [];
    let raycaster, mouse;
    let targetPosition = new THREE.Vector3();
    let isMovingRTS = false; // Tracks if tank is moving to a click target
    let score = 0;
    
    // --- New Mobile Control State Variables ---
    let isForwardPressed = false;
    let isBackwardPressed = false;
    let isTurningLeft = false;
    let isTurningRight = false;

    const TANK_SPEED = 0.15;
    const TURN_SPEED = 0.05; // Reduced turn speed for direct control
    const SOLDIER_COUNT = 20;

    // --- Initialization ---
    function init() {
        // 1. Setup Scene, Camera, Renderer (Same as before)
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 20);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 2. Lighting, Objects (Same as before)
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        scene.add(dirLight);

        createGround();
        createTank();
        spawnSoldiers();

        // 3. Interaction Setup
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Desktop/Tap-to-move listener
        window.addEventListener('contextmenu', event => event.preventDefault());
        window.addEventListener('pointerdown', onGroundClick);
        window.addEventListener('resize', onWindowResize);

        // 4. Mobile Button Listeners (New)
        setupTouchControls();

        // 5. Start Loop
        animate();
    }

    // --- Object Creation (Same as before) ---
    function createGround() {
        const geometry = new THREE.PlaneGeometry(100, 100);
        const material = new THREE.MeshStandardMaterial({ color: 0x3b7d3b });
        ground = new THREE.Mesh(geometry, material);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
    }

    function createTank() {
        tank = new THREE.Group();
        const bodyGeo = new THREE.BoxGeometry(2, 1, 3);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2E4053 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.5;
        body.castShadow = true;
        tank.add(body);
        const turretGeo = new THREE.BoxGeometry(1.2, 0.8, 1.5);
        const turretMat = new THREE.MeshStandardMaterial({ color: 0x5D6D7E });
        const turret = new THREE.Mesh(turretGeo, turretMat);
        turret.position.y = 1.4;
        turret.castShadow = true;
        tank.add(turret);
        const barrelGeo = new THREE.CylinderGeometry(0.2, 0.2, 2.5);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x1B2631 });
        const barrel = new THREE.Mesh(barrelGeo, barrelMat);
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 1.4, 1.5);
        tank.add(barrel);
        scene.add(tank);
        tank.position.set(0, 0, 0);
        targetPosition.copy(tank.position);
    }

    function spawnSoldiers() {
        const geometry = new THREE.CapsuleGeometry(0.3, 1, 4, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0x922B21 });
        for (let i = 0; i < SOLDIER_COUNT; i++) {
            const soldier = new THREE.Mesh(geometry, material.clone());
            const x = (Math.random() - 0.5) * 40;
            const z = (Math.random() - 0.5) * 40;
            soldier.position.set(x, 0.8, z);
            soldier.castShadow = true;
            soldier.userData = {
                alive: true,
                walkSpeed: 0.02 + Math.random() * 0.03,
                walkDir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize()
            };
            scene.add(soldier);
            soldiers.push(soldier);
        }
    }

    // --- Input Handlers ---

    function setupTouchControls() {
        const controlsMap = {
            'move-forward': () => isForwardPressed = true,
            'move-backward': () => isBackwardPressed = true,
            'turn-left': () => isTurningLeft = true,
            'turn-right': () => isTurningRight = true,
        };

        const releaseMap = {
            'move-forward': () => isForwardPressed = false,
            'move-backward': () => isBackwardPressed = false,
            'turn-left': () => isTurningLeft = false,
            'turn-right': () => isTurningRight = false,
        };

        Object.keys(controlsMap).forEach(id => {
            const button = document.getElementById(id);
            if (button) {
                // Use touch events for mobile
                button.addEventListener('touchstart', (e) => { e.preventDefault(); controlsMap[id](); isMovingRTS = false; });
                button.addEventListener('touchend', (e) => { e.preventDefault(); releaseMap[id](); });
                
                // Use mouse events for desktop testing
                button.addEventListener('mousedown', controlsMap[id]);
                button.addEventListener('mouseup', releaseMap[id]);
                button.addEventListener('mouseleave', releaseMap[id]); // Release if mouse slides off
            }
        });
    }

    // Original RTS-style click/tap movement
    function onGroundClick(event) {
        // Handle desktop right-click or mobile tap on canvas (button 2 is right-click)
        if (event.button !== 2 && event.type !== 'pointerdown') return;

        // Ignore if the click originated from the controls UI
        if (event.target.classList.contains('dpad-button')) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground);

        if (intersects.length > 0) {
            targetPosition.copy(intersects[0].point);
            isMovingRTS = true;
            
            // Cancel directional controls if a target is set
            isForwardPressed = isBackwardPressed = isTurningLeft = isTurningRight = false;
            
            createClickMarker(targetPosition);
        }
    }

    function createClickMarker(pos) {
        const geo = new THREE.RingGeometry(0.5, 0.6, 32);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        const marker = new THREE.Mesh(geo, mat);
        marker.position.copy(pos);
        marker.position.y = 0.05;
        marker.rotation.x = -Math.PI / 2;
        scene.add(marker);
        setTimeout(() => { scene.remove(marker); geo.dispose(); mat.dispose(); }, 500);
    }

    // --- Game Logic ---

    function moveTank() {
        const isManualControl = isForwardPressed || isBackwardPressed || isTurningLeft || isTurningRight;

        if (isManualControl) {
            // **Action Style Direct Control**
            isMovingRTS = false; // Override RTS movement
            
            // Turning
            if (isTurningLeft) {
                tank.rotation.y += TURN_SPEED;
            } else if (isTurningRight) {
                tank.rotation.y -= TURN_SPEED;
            }

            // Movement
            if (isForwardPressed) {
                tank.translateZ(TANK_SPEED); // Move along local Z axis
            } else if (isBackwardPressed) {
                tank.translateZ(-TANK_SPEED); // Move along local Z axis
            }
        
        } else if (isMovingRTS) {
            // **RTS Style Click-to-Move Control**
            const direction = new THREE.Vector3().subVectors(targetPosition, tank.position);
            direction.y = 0;
            const distance = direction.length();

            if (distance < 0.2) {
                isMovingRTS = false;
                return;
            }

            direction.normalize();

            // Smooth rotation towards target
            const targetRotation = new THREE.Quaternion();
            const lookMatrix = new THREE.Matrix4().lookAt(tank.position, targetPosition, tank.up);
            targetRotation.setFromRotationMatrix(lookMatrix);
            tank.quaternion.slerp(targetRotation, 0.1);

            // Move
            tank.position.add(direction.multiplyScalar(TANK_SPEED));
        }
    }

    function updateSoldiers() {
        soldiers.forEach(soldier => {
            if (!soldier.userData.alive) return;

            // AI Movement (Wander)
            soldier.position.add(soldier.userData.walkDir.clone().multiplyScalar(soldier.userData.walkSpeed));
            if (Math.abs(soldier.position.x) > 25 || Math.abs(soldier.position.z) > 25) {
                soldier.userData.walkDir.multiplyScalar(-1);
            }
            if (Math.random() < 0.02) {
                 soldier.userData.walkDir = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            }

            // Collision Detection with Tank
            const dist = tank.position.distanceTo(soldier.position);
            
            if (dist < 1.5) {
                crushSoldier(soldier);
            }
        });
    }

    function crushSoldier(soldier) {
        soldier.userData.alive = false;
        soldier.scale.set(1.5, 0.1, 1.5);
        soldier.position.y = 0.1;
        soldier.material.color.setHex(0x550000);
        score++;
        document.getElementById('score').innerText = score;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        moveTank();
        updateSoldiers();

        renderer.render(scene, camera);
    }

    // Boot
    init();

</script>
</body>
</html>

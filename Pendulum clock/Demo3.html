<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Perfect Sync WebGL Clock</title>
    <style>
        body { margin: 0; background: #111; color: #eee; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h2>Physics Clock: Fixed Sync</h2>
        <p>Gears and Pendulum now sharing a unified coordinate system.</p>
    </div>
    <canvas id="glCanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform mat3 u_matrix;
    void main() {
        gl_Position = vec4((u_matrix * vec3(a_position, 1.0)).xy, 0.0, 1.0);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
const m3 = {
    projection: (w, h) => [2/w, 0, 0, 0, -2/h, 0, -1, 1, 1],
    translate: (m, tx, ty) => m3.multiply(m, [1, 0, 0, 0, 1, 0, tx, ty, 1]),
    rotate: (m, rad) => {
        let c = Math.cos(rad), s = Math.sin(rad);
        return m3.multiply(m, [c, s, 0, -s, c, 0, 0, 0, 1]);
    },
    scale: (m, sx, sy) => m3.multiply(m, [sx, 0, 0, 0, sy, 0, 0, 0, 1]),
    multiply: (a, b) => {
        let a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
        let b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
        return [
            b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22
        ];
    }
};

/** PHYSICS ENGINE **/
class Pendulum {
    constructor() {
        this.L = 0.8; 
        this.theta = 0.3; 
        this.omega = 0;
        this.damping = 0.02;
    }
    update(dt) {
        let alpha = (-9.81 / this.L) * Math.sin(this.theta);
        this.omega += alpha * dt;
        this.omega *= (1 - this.damping * dt);
        this.theta += this.omega * dt;
    }
}

class EscapeWheel {
    constructor() {
        this.theta = 0;
        this.omega = 0;
        this.teeth = 30;
        this.locked = true;
    }
    update(dt) {
        if (!this.locked) {
            this.omega += 15.0 * dt; // Torque impulse
            this.theta += this.omega * dt;
        } else { this.omega = 0; }
    }
}

const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

function createShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    return s;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
gl.linkProgram(program);
gl.useProgram(program);

const posLoc = gl.getAttribLocation(program, "a_position");
const matLoc = gl.getUniformLocation(program, "u_matrix");
const colLoc = gl.getUniformLocation(program, "u_color");

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.5,-0.5, 0.5,-0.5, -0.5,0.5, -0.5,0.5, 0.5,-0.5, 0.5,0.5]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const pendulum = new Pendulum();
const wheel = new EscapeWheel();

function drawInstance(matrix, color) {
    gl.uniformMatrix3fv(matLoc, false, matrix);
    gl.uniform4fv(colLoc, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

let lastTime = 0;
function loop(time) {
    let dt = Math.min((time - lastTime) / 1000, 0.02);
    lastTime = time;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // --- Physics ---
    pendulum.update(dt);
    let step = (Math.PI * 2) / wheel.teeth;
    if (Math.abs(pendulum.theta) > 0.15) {
        if (wheel.locked) {
            wheel.locked = false;
            pendulum.omega += (pendulum.theta > 0 ? 0.08 : -0.08);
        }
    } else {
        if (!wheel.locked) {
            wheel.locked = true;
            wheel.theta = Math.round(wheel.theta / step) * step;
        }
    }
    wheel.update(dt);

    const proj = m3.projection(canvas.width, canvas.height);
    const cx = canvas.width / 2;
    const cy = canvas.height / 3;

    // --- Draw Gear ---
    let gearBase = m3.translate(proj, cx, cy);
    let gearRot = m3.rotate(gearBase, wheel.theta);
    // Draw 30 teeth
    for(let i=0; i<wheel.teeth; i++) {
        let tooth = m3.rotate(gearRot, i * step);
        tooth = m3.translate(tooth, 0, -45);
        drawInstance(m3.scale(tooth, 10, 20), [0.8, 0.6, 0.2, 1]);
    }
    drawInstance(m3.scale(gearRot, 80, 80), [0.5, 0.4, 0.2, 1]);

    // --- Draw Pendulum (Perfectly Anchored) ---
    // Everything below is relative to the Pivot
    let pivot = m3.translate(proj, cx, cy - 40); 
    let pRot = m3.rotate(pivot, pendulum.theta);

    // Rod: we translate down by half its length so the TOP of the rod is at the pivot
    let rodLen = 300;
    let rodMat = m3.translate(pRot, 0, rodLen/2);
    drawInstance(m3.scale(rodMat, 6, rodLen), [0.6, 0.6, 0.6, 1]);

    // Bob: relative to the rod bottom
    let bobMat = m3.translate(pRot, 0, rodLen);
    drawInstance(m3.scale(bobMat, 50, 50), [0.8, 0.2, 0.2, 1]);

    // Anchor: relative to the same pivot
    let anchorBar = m3.scale(pRot, 120, 15);
    drawInstance(anchorBar, [0.4, 0.4, 0.4, 1]);

    // Pallets: Attached to the ends of the anchor bar
    let leftPallet = m3.translate(pRot, -60, 20);
    drawInstance(m3.scale(m3.rotate(leftPallet, 0.5), 15, 40), [0.3, 0.3, 0.3, 1]);

    let rightPallet = m3.translate(pRot, 60, 20);
    drawInstance(m3.scale(m3.rotate(rightPallet, -0.5), 15, 40), [0.3, 0.3, 0.3, 1]);

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

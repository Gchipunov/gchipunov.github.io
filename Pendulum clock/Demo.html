<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Physics Pendulum Clock</title>
    <style>
        body { margin: 0; background: #1a1a1a; color: white; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Pendulum Clock</h1>
        <p>Physics: Rotational Dynamics + Anchor Escapement</p>
        <p>Units: SI (Meters, Kg, Newtons)</p>
    </div>
    <canvas id="glCanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform mat3 u_matrix;
    void main() {
        gl_Position = vec4((u_matrix * vec3(a_position, 1.0)).xy, 0.0, 1.0);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
/** * MATH UTILS 
 */
const m3 = {
    identity: () => [1, 0, 0, 0, 1, 0, 0, 0, 1],
    projection: (w, h) => [2/w, 0, 0, 0, -2/h, 0, -1, 1, 1],
    translate: (m, tx, ty) => m3.multiply(m, [1, 0, 0, 0, 1, 0, tx, ty, 1]),
    rotate: (m, rad) => {
        let c = Math.cos(rad), s = Math.sin(rad);
        return m3.multiply(m, [c, s, 0, -s, c, 0, 0, 0, 1]);
    },
    scale: (m, sx, sy) => m3.multiply(m, [sx, 0, 0, 0, sy, 0, 0, 0, 1]),
    multiply: (a, b) => {
        let a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
        let b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
        return [
            b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22
        ];
    }
};

/**
 * PHYSICS CONSTANTS (SI UNITS)
 */
const G = 9.81;
const PIXELS_PER_METRE = 300; 

class Pendulum {
    constructor(length, mass) {
        this.L = length;
        this.m = mass;
        this.theta = 0.2; // Initial angle (radians)
        this.omega = 0.0; // Angular velocity
        this.I = mass * length * length; // Moment of inertia
        this.damping = 0.015;
    }

    update(dt) {
        // Torque due to gravity: T = -m * g * L * sin(theta)
        let torqueGrav = -this.m * G * this.L * Math.sin(this.theta);
        let torqueDamp = -this.omega * this.damping;
        
        let alpha = (torqueGrav + torqueDamp) / this.I;
        this.omega += alpha * dt;
        this.theta += this.omega * dt;
    }
}

class EscapeWheel {
    constructor(teethCount) {
        this.theta = 0;
        this.omega = 0;
        this.teeth = teethCount;
        this.driveTorque = 0.5; // Simulates the falling weight
        this.I = 0.05;
        this.locked = true;
    }

    update(dt) {
        if (!this.locked) {
            let alpha = this.driveTorque / this.I;
            this.omega += alpha * dt;
            this.theta += this.omega * dt;
        } else {
            this.omega = 0;
        }
    }
}

/**
 * WEBGL SETUP
 */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

function createShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    return s;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
gl.linkProgram(program);
gl.useProgram(program);

const posLoc = gl.getAttribLocation(program, "a_position");
const matLoc = gl.getUniformLocation(program, "u_matrix");
const colLoc = gl.getUniformLocation(program, "u_color");

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
// Simple unit square centered at (0.5, 0.5) for generic drawing
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.5,-0.5, 0.5,-0.5, -0.5,0.5, -0.5,0.5, 0.5,-0.5, 0.5,0.5]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

/**
 * SIMULATION INSTANCES
 */
const pendulum = new Pendulum(0.8, 1.5); // 80cm, 1.5kg
const wheel = new EscapeWheel(30);

function drawRect(x, y, w, h, rot, color) {
    let m = m3.projection(canvas.width, canvas.height);
    m = m3.translate(m, x, y);
    m = m3.rotate(m, rot);
    m = m3.scale(m, w, h);
    gl.uniformMatrix3fv(matLoc, false, m);
    gl.uniform4fv(colLoc, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

let lastTime = 0;
const releaseThreshold = 0.08; // Escapement logic threshold

function loop(time) {
    let dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    /** PHYSICS LOGIC **/
    // 1. Update Pendulum
    pendulum.update(dt);

    // 2. Escapement Mechanism (Simplified logic from article's concepts)
    // The anchor blocks the wheel. When theta > threshold, release one tooth.
    let stepAngle = (Math.PI * 2) / wheel.teeth;
    
    // Check if pendulum is at the 'tick' or 'tock' point
    if (Math.abs(pendulum.theta) > releaseThreshold) {
        if (wheel.locked) {
            wheel.locked = false;
            // Impulse: The gear pushes the pendulum slightly
            pendulum.omega += (pendulum.theta > 0 ? 0.05 : -0.05);
        }
    } else {
        // Lock wheel when anchor returns to center
        if (!wheel.locked) {
            wheel.locked = true;
            // Snap wheel to nearest tooth alignment
            wheel.theta = Math.round(wheel.theta / stepAngle) * stepAngle;
        }
    }
    
    wheel.update(dt);

    /** RENDERING **/
    const cx = canvas.width / 2;
    const cy = canvas.height / 3;

    // Draw Escape Wheel (The "Gear")
    for (let i = 0; i < wheel.teeth; i++) {
        let angle = wheel.theta + (i * stepAngle);
        drawRect(cx, cy, 10, 40, angle, [0.8, 0.6, 0.2, 1]); // Teeth
    }
    drawRect(cx, cy, 60, 60, wheel.theta, [0.6, 0.4, 0.1, 1]); // Wheel hub

    // Draw Anchor (attached to pendulum top)
    let anchorY = cy - 20;
    drawRect(cx, anchorY, 100, 10, pendulum.theta, [0.7, 0.7, 0.7, 1]); // Top bar
    // Pallets (The parts that catch the teeth)
    let px = Math.sin(pendulum.theta);
    let py = Math.cos(pendulum.theta);
    drawRect(cx - 50 * py, anchorY + 50 * px, 10, 30, pendulum.theta + 0.5, [0.5, 0.5, 0.5, 1]);
    drawRect(cx + 50 * py, anchorY - 50 * px, 10, 30, pendulum.theta - 0.5, [0.5, 0.5, 0.5, 1]);

    // Draw Pendulum Rod
    let rodLen = pendulum.L * PIXELS_PER_METRE;
    let bobX = cx + Math.sin(pendulum.theta) * rodLen;
    let bobY = anchorY + Math.cos(pendulum.theta) * rodLen;
    
    // Draw Rod
    drawRect(cx + (Math.sin(pendulum.theta) * rodLen/2), 
             anchorY + (Math.cos(pendulum.theta) * rodLen/2), 
             4, rodLen, pendulum.theta, [0.8, 0.8, 0.8, 1]);
    
    // Draw Bob (Weight)
    drawRect(bobX, bobY, 40, 40, pendulum.theta, [0.9, 0.2, 0.2, 1]);

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fixed WebGL Physics Pendulum Clock</title>
    <style>
        body { margin: 0; background: #121212; color: #eee; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; border: 1px solid #444; }
        h1 { margin: 0 0 10px 0; font-size: 18px; color: #ffcc00; }
        p { margin: 5px 0; font-size: 13px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Pendulum Clock (Fixed Axis)</h1>
        <p>• Physics: Torque & Moment of Inertia</p>
        <p>• Projection: Flipped Y-Axis (Screen Space)</p>
        <p>• Mechanism: Anchor Escapement</p>
    </div>
    <canvas id="glCanvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
    attribute vec2 a_position;
    uniform mat3 u_matrix;
    void main() {
        // Multiply matrix by the 2D position
        gl_Position = vec4((u_matrix * vec3(a_position, 1.0)).xy, 0.0, 1.0);
    }
</script>

<script id="fs" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
</script>

<script>
/** * MATH UTILS - Corrected for Screen Space
 */
const m3 = {
    // Standard 2D Projection: maps 0..width to -1..1 and 0..height to 1..-1 (flips Y)
    projection: (w, h) => [
        2/w, 0, 0,
        0, -2/h, 0,
        -1, 1, 1
    ],
    translate: (m, tx, ty) => m3.multiply(m, [1, 0, 0, 0, 1, 0, tx, ty, 1]),
    rotate: (m, rad) => {
        let c = Math.cos(rad), s = Math.sin(rad);
        // Corrected rotation matrix for screen-space clockwise behavior
        return m3.multiply(m, [c, s, 0, -s, c, 0, 0, 0, 1]);
    },
    scale: (m, sx, sy) => m3.multiply(m, [sx, 0, 0, 0, sy, 0, 0, 0, 1]),
    multiply: (a, b) => {
        let a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
        let b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
        return [
            b00 * a00 + b01 * a10 + b02 * a20, b00 * a01 + b01 * a11 + b02 * a21, b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20, b10 * a01 + b11 * a11 + b12 * a21, b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20, b20 * a01 + b21 * a11 + b22 * a21, b20 * a02 + b21 * a12 + b22 * a22
        ];
    }
};

/**
 * PHYSICS CLASSES
 */
const G = 9.81;
const PIXELS_PER_METRE = 350; 

class Pendulum {
    constructor(length, mass) {
        this.L = length;
        this.m = mass;
        this.theta = 0.25; 
        this.omega = 0.0; 
        this.I = mass * length * length; 
        this.damping = 0.02;
    }
    update(dt) {
        // Torque = r x F -> -mgL sin(theta)
        let torqueGrav = -this.m * G * this.L * Math.sin(this.theta);
        let torqueDamp = -this.omega * this.damping;
        let alpha = (torqueGrav + torqueDamp) / this.I;
        this.omega += alpha * dt;
        this.theta += this.omega * dt;
    }
}

class EscapeWheel {
    constructor(teethCount) {
        this.theta = 0;
        this.omega = 0;
        this.teeth = teethCount;
        this.driveTorque = 0.6; 
        this.I = 0.08;
        this.locked = true;
    }
    update(dt) {
        if (!this.locked) {
            let alpha = this.driveTorque / this.I;
            this.omega += alpha * dt;
            this.theta += this.omega * dt;
        } else {
            this.omega = 0;
        }
    }
}

/**
 * WEBGL INITIALIZATION
 */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

function createShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    return s;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').text));
gl.linkProgram(program);
gl.useProgram(program);

const posLoc = gl.getAttribLocation(program, "a_position");
const matLoc = gl.getUniformLocation(program, "u_matrix");
const colLoc = gl.getUniformLocation(program, "u_color");

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
// Unit square centered at origin
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-0.5,-0.5, 0.5,-0.5, -0.5,0.5, -0.5,0.5, 0.5,-0.5, 0.5,0.5]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const pendulum = new Pendulum(0.85, 2.0);
const wheel = new EscapeWheel(30);

function drawRect(x, y, w, h, rot, color) {
    let m = m3.projection(canvas.width, canvas.height);
    m = m3.translate(m, x, y);
    m = m3.rotate(m, rot);
    m = m3.scale(m, w, h);
    gl.uniformMatrix3fv(matLoc, false, m);
    gl.uniform4fv(colLoc, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

let lastTime = 0;
const releaseThreshold = 0.12; 

function loop(time) {
    let dt = Math.min((time - lastTime) / 1000, 0.02); // Cap dt for stability
    lastTime = time;

    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    gl.clearColor(0.07, 0.07, 0.07, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // --- PHYSICS ---
    pendulum.update(dt);
    
    let stepAngle = (Math.PI * 2) / wheel.teeth;
    if (Math.abs(pendulum.theta) > releaseThreshold) {
        if (wheel.locked) {
            wheel.locked = false;
            // Push the pendulum (impulse)
            pendulum.omega += (pendulum.theta > 0 ? 0.06 : -0.06);
        }
    } else {
        if (!wheel.locked) {
            wheel.locked = true;
            wheel.theta = Math.round(wheel.theta / stepAngle) * stepAngle;
        }
    }
    wheel.update(dt);

    // --- DRAWING ---
    const cx = canvas.width / 2;
    const cy = canvas.height / 3;

    // 1. Draw Escape Wheel
    for (let i = 0; i < wheel.teeth; i++) {
        let angle = wheel.theta + (i * stepAngle);
        drawRect(cx, cy, 8, 45, angle, [0.8, 0.5, 0.2, 1]); 
    }
    drawRect(cx, cy, 60, 60, wheel.theta, [0.5, 0.3, 0.1, 1]);

    // 2. Draw Pendulum Pivot & Rod
    const pivotY = cy - 30;
    const rodLen = pendulum.L * PIXELS_PER_METRE;
    
    // Calculate bob position based on correct rotation
    let bx = cx + Math.sin(pendulum.theta) * rodLen;
    let by = pivotY + Math.cos(pendulum.theta) * rodLen;

    // Rod
    drawRect(cx + Math.sin(pendulum.theta) * rodLen/2, 
             pivotY + Math.cos(pendulum.theta) * rodLen/2, 
             6, rodLen, pendulum.theta, [0.6, 0.6, 0.6, 1]);

    // Bob
    drawRect(bx, by, 50, 50, pendulum.theta, [0.8, 0.2, 0.2, 1]);

    // 3. Draw Anchor (attached to the rod at the pivot)
    drawRect(cx, pivotY, 110, 12, pendulum.theta, [0.4, 0.4, 0.4, 1]);
    
    // Anchor Pallets (The "teeth" of the anchor)
    let palletDist = 55;
    let leftPalletX = cx + Math.cos(pendulum.theta) * -palletDist - Math.sin(pendulum.theta) * 0;
    let leftPalletY = pivotY + Math.sin(pendulum.theta) * -palletDist + Math.cos(pendulum.theta) * 0;
    drawRect(leftPalletX, leftPalletY + 20, 12, 40, pendulum.theta + 0.4, [0.3, 0.3, 0.3, 1]);

    let rightPalletX = cx + Math.cos(pendulum.theta) * palletDist;
    let rightPalletY = pivotY + Math.sin(pendulum.theta) * palletDist;
    drawRect(rightPalletX, rightPalletY + 20, 12, 40, pendulum.theta - 0.4, [0.3, 0.3, 0.3, 1]);

    requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>

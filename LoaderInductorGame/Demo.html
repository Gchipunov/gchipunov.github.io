<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Induction Loader</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .msg { font-size: 24px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <div class="msg">Score: <span id="score">0</span></div>
    <p>Click/Tap packages when they hit the <span style="color: #ffeb3b;">Yellow Induction Zone</span>!</p>
</div>
<canvas id="glCanvas"></canvas>

<script>
    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) { alert("WebGL not supported"); }

    // --- Shaders ---
    const vsSource = `
        attribute vec2 aPosition;
        uniform vec2 uResolution;
        uniform vec2 uTranslation;
        uniform vec2 uScale;
        void main() {
            vec2 position = aPosition * uScale + uTranslation;
            vec2 zeroToOne = position / uResolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
    `;

    const fsSource = `
        precision mediump float;
        uniform vec4 uColor;
        void main() {
            gl_FragColor = uColor;
        }
    `;

    // Initialize shaders
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    }

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
    gl.linkProgram(program);
    gl.useProgram(program);

    // --- Data Buffers ---
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    // Unit square vertices
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,  1, 0,  0, 1,
        0, 1,  1, 0,  1, 1
    ]), gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, "aPosition");
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    const resLoc = gl.getUniformLocation(program, "uResolution");
    const transLoc = gl.getUniformLocation(program, "uTranslation");
    const scaleLoc = gl.getUniformLocation(program, "uScale");
    const colorLoc = gl.getUniformLocation(program, "uColor");

    // --- Game Logic ---
    let score = 0;
    let packages = [];
    const beltY = 300;
    const inductionX = 600; // The goal zone
    let lastSpawn = 0;

    function spawnPackage() {
        packages.push({
            x: -100,
            y: beltY + 10,
            width: 60,
            height: 40,
            speed: 3 + Math.random() * 2,
            active: true
        });
    }

    function update() {
        const now = Date.now();
        if (now - lastSpawn > 1500) {
            spawnPackage();
            lastSpawn = now;
        }

        packages.forEach(pkg => {
            pkg.x += pkg.speed;
            if (pkg.x > canvas.width) pkg.active = false;
        });
        packages = packages.filter(p => p.active);
    }

    function drawRect(x, y, w, h, color) {
        gl.uniform2f(resLoc, canvas.width, canvas.height);
        gl.uniform2f(transLoc, x, y);
        gl.uniform2f(scaleLoc, w, h);
        gl.uniform4fv(colorLoc, color);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function render() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.1, 0.1, 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        update();

        // Draw Conveyor
        drawRect(0, beltY, canvas.width, 60, [0.3, 0.3, 0.3, 1]);
        
        // Draw Induction Zone
        drawRect(inductionX, beltY - 10, 80, 80, [1, 0.9, 0, 0.3]);

        // Draw Packages
        packages.forEach(pkg => {
            drawRect(pkg.x, pkg.y, pkg.width, pkg.height, [0.6, 0.4, 0.2, 1]);
        });

        requestAnimationFrame(render);
    }

    // Interaction
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        packages.forEach(pkg => {
            // Check if package is inside induction zone AND clicked
            if (pkg.x > inductionX && pkg.x < inductionX + 80) {
                pkg.active = false;
                score += 10;
                document.getElementById('score').innerText = score;
            }
        });
    });

    render();
</script>
</body>
</html>

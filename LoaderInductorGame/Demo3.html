<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGL Induction Loader - Mobile Ready</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .msg { font-size: 24px; font-weight: bold; }
        
        /* Mobile Controls */
        #controls {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: space-evenly; align-items: center;
            pointer-events: none;
        }
        .btn {
            pointer-events: auto; width: 80px; height: 80px;
            background: rgba(255, 255, 255, 0.2); border: 2px solid white;
            border-radius: 50%; color: white; display: flex;
            align-items: center; justify-content: center;
            font-weight: bold; font-size: 14px; touch-action: manipulation;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.95); }
        #induct-btn { background: rgba(255, 235, 59, 0.3); border-color: #ffeb3b; width: 100px; height: 100px; font-size: 18px; }
    </style>
</head>
<body>

<div id="ui">
    <div class="msg">Score: <span id="score">0</span></div>
    <p>Tap packages or use the <b>INDUCT</b> button!</p>
</div>

<div id="controls">
    <div class="btn" id="speed-btn">SPEED</div>
    <div class="btn" id="induct-btn">INDUCT</div>
    <div class="btn" id="pause-btn">PAUSE</div>
</div>

<canvas id="glCanvas"></canvas>

<script>
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    if (!gl) { alert("WebGL not supported"); }

    // --- Shaders (Same as previous) ---
    const vsSource = `
        attribute vec2 aPosition;
        uniform vec2 uResolution;
        uniform vec2 uTranslation;
        uniform vec2 uScale;
        void main() {
            vec2 position = aPosition * uScale + uTranslation;
            vec2 zeroToOne = position / uResolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
    `;
    const fsSource = `precision mediump float; uniform vec4 uColor; void main() { gl_FragColor = uColor; }`;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    }

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, "aPosition");
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    const resLoc = gl.getUniformLocation(program, "uResolution");
    const transLoc = gl.getUniformLocation(program, "uTranslation");
    const scaleLoc = gl.getUniformLocation(program, "uScale");
    const colorLoc = gl.getUniformLocation(program, "uColor");

    // --- Game Logic ---
    let score = 0;
    let packages = [];
    let isPaused = false;
    let speedMultiplier = 1.0;
    const beltY = 250; 
    const beltHeight = 100;
    const inductionX = 400; 
    const inductionWidth = 300; 
    let lastSpawn = 0;

    function spawnPackage() {
        const pWidth = 50 + Math.random() * 70;
        const pHeight = 40 + Math.random() * 40;
        const pY = beltY + (beltHeight / 2) - (pHeight / 2);

        packages.push({
            x: -150,
            y: pY,
            width: pWidth,
            height: pHeight,
            speed: (2 + Math.random() * 3) * speedMultiplier,
            active: true,
            color: [0.6 + Math.random() * 0.2, 0.45, 0.3, 1.0]
        });
    }

    function checkInduction(clickX, clickY, isButtonPress = false) {
        packages.forEach(pkg => {
            if (!pkg.active) return;
            
            const pkgMidX = pkg.x + (pkg.width / 2);
            const inZone = pkgMidX > inductionX && pkgMidX < (inductionX + inductionWidth);
            
            if (inZone) {
                // If using the button, any package in the zone is cleared
                // If tapping, must hit the specific package coordinates
                if (isButtonPress) {
                    pkg.active = false;
                    updateScore(10);
                } else if (clickX >= pkg.x && clickX <= pkg.x + pkg.width &&
                           clickY >= pkg.y && clickY <= pkg.y + pkg.height) {
                    pkg.active = false;
                    updateScore(10);
                }
            }
        });
    }

    function updateScore(pts) {
        score += pts;
        document.getElementById('score').innerText = score;
    }

    function update() {
        if (isPaused) return;
        const now = Date.now();
        if (now - lastSpawn > 1500 / speedMultiplier) {
            spawnPackage();
            lastSpawn = now;
        }

        packages.forEach(pkg => {
            pkg.x += pkg.speed;
            if (pkg.x > canvas.width) pkg.active = false;
        });
        packages = packages.filter(p => p.active);
    }

    function drawRect(x, y, w, h, color) {
        gl.uniform2f(resLoc, canvas.width, canvas.height);
        gl.uniform2f(transLoc, x, y);
        gl.uniform2f(scaleLoc, w, h);
        gl.uniform4fv(colorLoc, color);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function render() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.1, 0.1, 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        update();

        // Draw Belt & Zone
        drawRect(0, beltY, canvas.width, beltHeight, [0.2, 0.2, 0.2, 1]);
        drawRect(inductionX, beltY - 10, inductionWidth, beltHeight + 20, [1, 0.9, 0, 0.2]);

        // Draw Packages
        packages.forEach(pkg => {
            drawRect(pkg.x, pkg.y, pkg.width, pkg.height, pkg.color);
        });

        requestAnimationFrame(render);
    }

    // --- Input Handlers ---
    const handleInput = (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
        const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
        checkInduction(x, y, false);
    };

    canvas.addEventListener('mousedown', handleInput);
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleInput(e);
    }, { passive: false });

    // Button Logic
    document.getElementById('induct-btn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        checkInduction(0, 0, true);
    });
    
    document.getElementById('speed-btn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        speedMultiplier = speedMultiplier === 1.0 ? 2.5 : 1.0;
        document.getElementById('speed-btn').style.borderColor = speedMultiplier > 1 ? "#ff5722" : "white";
    });

    document.getElementById('pause-btn').addEventListener('touchstart', (e) => {
        e.preventDefault();
        isPaused = !isPaused;
        document.getElementById('pause-btn').innerText = isPaused ? "RESUME" : "PAUSE";
    });

    render();
</script>
</body>
</html>

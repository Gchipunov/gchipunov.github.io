<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Induction Loader - Varied Packages</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .msg { font-size: 24px; font-weight: bold; }
        .hint { color: #ccc; font-size: 14px; }
    </style>
</head>
<body>

<div id="ui">
    <div class="msg">Score: <span id="score">0</span></div>
    <p>Induct packages within the <span style="color: #ffeb3b;">Yellow Zone</span>!</p>
    <p class="hint">Packages now come in various shapes and sizes.</p>
</div>
<canvas id="glCanvas"></canvas>

<script>
    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');

    if (!gl) { alert("WebGL not supported"); }

    const vsSource = `
        attribute vec2 aPosition;
        uniform vec2 uResolution;
        uniform vec2 uTranslation;
        uniform vec2 uScale;
        void main() {
            vec2 position = aPosition * uScale + uTranslation;
            vec2 zeroToOne = position / uResolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
    `;

    const fsSource = `
        precision mediump float;
        uniform vec4 uColor;
        void main() {
            gl_FragColor = uColor;
        }
    `;

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    }

    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
    gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
    gl.linkProgram(program);
    gl.useProgram(program);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,  1, 0,  0, 1,
        0, 1,  1, 0,  1, 1
    ]), gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, "aPosition");
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    const resLoc = gl.getUniformLocation(program, "uResolution");
    const transLoc = gl.getUniformLocation(program, "uTranslation");
    const scaleLoc = gl.getUniformLocation(program, "uScale");
    const colorLoc = gl.getUniformLocation(program, "uColor");

    // --- Game Logic & Configuration ---
    let score = 0;
    let packages = [];
    const beltY = 350;
    const beltHeight = 80;
    
    // MODIFIED: Wider induction zone
    const inductionX = 500; 
    const inductionWidth = 250; 
    
    let lastSpawn = 0;

    function spawnPackage() {
        // MODIFIED: Random width and height
        const pWidth = 40 + Math.random() * 80;
        const pHeight = 30 + Math.random() * 40;
        
        // Center package vertically on the belt
        const pY = beltY + (beltHeight / 2) - (pHeight / 2);

        packages.push({
            x: -150,
            y: pY,
            width: pWidth,
            height: pHeight,
            speed: 2 + Math.random() * 4,
            active: true,
            // Add slight color variation for visual interest
            color: [0.5 + Math.random() * 0.2, 0.4, 0.2, 1.0]
        });
    }

    function update() {
        const now = Date.now();
        // Slightly faster spawn rate to accommodate the wider table
        if (now - lastSpawn > 1200) {
            spawnPackage();
            lastSpawn = now;
        }

        packages.forEach(pkg => {
            pkg.x += pkg.speed;
            if (pkg.x > canvas.width) pkg.active = false;
        });
        packages = packages.filter(p => p.active);
    }

    function drawRect(x, y, w, h, color) {
        gl.uniform2f(resLoc, canvas.width, canvas.height);
        gl.uniform2f(transLoc, x, y);
        gl.uniform2f(scaleLoc, w, h);
        gl.uniform4fv(colorLoc, color);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function render() {
        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.15, 0.15, 0.15, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        update();

        // Draw Conveyor Belt
        drawRect(0, beltY, canvas.width, beltHeight, [0.25, 0.25, 0.25, 1]);
        
        // Draw Wider Induction Zone
        // Visual cue: slightly taller than the belt
        drawRect(inductionX, beltY - 10, inductionWidth, beltHeight + 20, [1, 0.8, 0, 0.25]);

        // Draw Packages
        packages.forEach(pkg => {
            drawRect(pkg.x, pkg.y, pkg.width, pkg.height, pkg.color);
        });

        requestAnimationFrame(render);
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Check for hits
        packages.forEach(pkg => {
            // Check if package center is within the wider induction zone
            const pkgMidX = pkg.x + (pkg.width / 2);
            if (pkgMidX > inductionX && pkgMidX < inductionX + inductionWidth) {
                // Check if the click was actually on the package
                if (mouseX >= pkg.x && mouseX <= pkg.x + pkg.width &&
                    mouseY >= pkg.y && mouseY <= pkg.y + pkg.height) {
                    
                    pkg.active = false;
                    score += 10;
                    document.getElementById('score').innerText = score;
                }
            }
        });
    });

    render();
</script>
</body>
</html>

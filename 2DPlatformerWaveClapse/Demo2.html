<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer - Wave Clasps Touch</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui { 
            position: absolute; top: 20px; left: 20px; color: white; 
            pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); 
        }

        /* Mobile Controls */
        .controls {
            position: absolute; bottom: 30px; left: 20px; right: 20px;
            display: flex; justify-content: space-between; align-items: flex-end;
            pointer-events: none;
        }
        .btn-group { display: flex; gap: 20px; }
        .btn {
            width: 70px; height: 70px; background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 24px;
            user-select: none; pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.9); }
        .jump-btn { width: 90px; height: 90px; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Wave Clasps</h1>
        <p>AD / Arrows | Touch Buttons to Play</p>
    </div>

    <div class="controls">
        <div class="btn-group">
            <div class="btn" id="btnLeft">←</div>
            <div class="btn" id="btnRight">→</div>
        </div>
        <div class="btn" id="btnJump" class="jump-btn">↑</div>
    </div>

    <canvas id="glCanvas"></canvas>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

if (!gl) { alert('WebGL not supported'); }

// --- SHADERS ---
const vsSource = `
    attribute vec2 aPosition;
    uniform vec2 uResolution;
    uniform vec2 uTranslation;
    uniform vec2 uScale;
    void main() {
        vec2 position = (aPosition * uScale + uTranslation) / uResolution * 2.0 - 1.0;
        gl_Position = vec4(position * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 uColor;
    void main() {
        gl_FragColor = uColor;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

const uRes = gl.getUniformLocation(program, 'uResolution');
const uTrans = gl.getUniformLocation(program, 'uTranslation');
const uScale = gl.getUniformLocation(program, 'uScale');
const uColor = gl.getUniformLocation(program, 'uColor');

// --- GAME STATE ---
const player = {
    x: 100, y: 300,
    width: 30, height: 30,
    vx: 0, vy: 0,
    speed: 6,
    jumpForce: -13,
    gravity: 0.65,
    jumps: 0,
    maxJumps: 2
};

const platforms = [];
const levelWidth = 8000;

function generateLevel() {
    platforms.push({ x: 0, y: 500, w: 400, h: 50 });
    
    for (let x = 450; x < levelWidth; x += 280) {
        const waveHeight = Math.sin(x * 0.004) * 160 + 400;
        const width = 140 + Math.random() * 80;
        
        platforms.push({
            x: x, y: waveHeight,
            w: width, h: 30,
            color: [0.3, 0.7, 0.9, 1.0]
        });

        if (x % 560 === 0) {
            platforms.push({
                x: x + 60, y: waveHeight - 160,
                w: 70, h: 20,
                color: [0.9, 0.4, 0.4, 1.0]
            });
        }
    }
}
generateLevel();

// --- INPUT HANDLING ---
const keys = {};

function handleJump() {
    if (player.jumps < player.maxJumps) {
        player.vy = player.jumpForce;
        player.jumps++;
    }
}

// Keyboard
window.onkeydown = (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') handleJump();
    keys[e.code] = true;
};
window.onkeyup = (e) => keys[e.code] = false;

// Touch Buttons
const btnLeft = document.getElementById('btnLeft');
const btnRight = document.getElementById('btnRight');
const btnJump = document.getElementById('btnJump');

const bindTouch = (el, key) => {
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
    // Support mouse testing on desktop too
    el.addEventListener('mousedown', (e) => { keys[key] = true; });
    el.addEventListener('mouseup', (e) => { keys[key] = false; });
};

bindTouch(btnLeft, 'KeyA');
bindTouch(btnRight, 'KeyD');

btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); });
btnJump.addEventListener('mousedown', (e) => { handleJump(); });

// --- UPDATE & DRAW ---
function update() {
    if (keys['KeyA'] || keys['ArrowLeft']) player.vx = -player.speed;
    else if (keys['KeyD'] || keys['ArrowRight']) player.vx = player.speed;
    else player.vx *= 0.85;

    player.x += player.vx;
    player.vy += player.gravity;
    player.y += player.vy;

    // Collision
    platforms.forEach(p => {
        if (player.x < p.x + p.w && player.x + player.width > p.x &&
            player.y < p.y + p.h && player.y + player.height > p.y) {
            
            if (player.vy > 0 && player.y + player.height - player.vy <= p.y) {
                player.y = p.y - player.height;
                player.vy = 0;
                player.jumps = 0;
            }
        }
    });

    if (player.y > canvas.height + 600) {
        player.x = 100; player.y = 300; player.vy = 0;
    }
}

function draw() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.08, 0.08, 0.08, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform2f(uRes, canvas.width, canvas.height);
    const camX = player.x - canvas.width / 3;

    platforms.forEach(p => {
        gl.uniform4f(uColor, ...(p.color || [0.4, 0.4, 0.4, 1.0]));
        gl.uniform2f(uTrans, p.x - camX, p.y);
        gl.uniform2f(uScale, p.w, p.h);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    });

    gl.uniform4f(uColor, 1.0, 0.84, 0.0, 1.0);
    gl.uniform2f(uTrans, player.x - camX, player.y);
    gl.uniform2f(uScale, player.width, player.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    update();
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>

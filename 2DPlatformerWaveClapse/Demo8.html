<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>The Gauntlet: Fixed Collision & Inventory</title>
    <style>
        * {
            user-select: none; -webkit-user-select: none; 
            -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; 
            touch-action: none; 
        }
        body { 
            margin: 0; overflow: hidden; background: #020205; 
            font-family: 'Segoe UI', sans-serif; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0ff; pointer-events: none; text-shadow: 2px 2px #000; z-index: 10; }
        
        .inventory { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 100; }
        .slot { 
            width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #555; 
            color: white; display: flex; align-items: center; justify-content: center; 
            font-size: 10px; font-weight: bold; cursor: pointer; border-radius: 8px;
        }
        .slot.active { border-color: #f0f; box-shadow: 0 0 10px #f0f; background: rgba(255, 0, 255, 0.2); }

        .controls { position: absolute; bottom: 30px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 100; }
        .btn-group { display: flex; gap: 15px; pointer-events: none; }
        .btn { 
            width: 75px; height: 75px; background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; 
            border-radius: 50%; display: flex; align-items: center; justify-content: center; 
            color: #0ff; font-weight: bold; pointer-events: auto; backdrop-filter: blur(4px); 
        }
        .btn:active { background: rgba(0, 255, 255, 0.4); }
    </style>
</head>
<body>
    <div id="ui">
        <h1 style="margin:0; font-size: 18px;">GAUNTLET: BREAKOUT</h1>
        <p id="camStatus" style="margin:5px 0;">Tool: <span id="toolName">HAMMER</span></p>
    </div>

    <div class="inventory">
        <div class="slot active" id="slotHammer">HAMMER</div>
        <div class="slot" id="slotKick">KICK</div>
        <div class="slot" id="regenBtn" style="border-color: #0f0; color: #0f0;">REGEN</div>
    </div>
    
    <div class="controls">
        <div class="btn-group">
            <div class="btn" id="btnLeft">L</div>
            <div class="btn" id="btnRight">R</div>
        </div>
        <div class="btn" id="btnJump" style="width:100px; border-radius: 15px;">JUMP / HIT</div>
    </div>

    <canvas id="glCanvas"></canvas>

<script>
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

const vsSource = `
    attribute vec2 aPos;
    uniform vec2 uRes, uTrans, uScale;
    uniform float uRot;
    void main() {
        float s = sin(uRot), c = cos(uRot);
        mat2 rot = mat2(c, s, -s, c);
        vec2 p = (aPos - 0.5) * uScale;
        p = rot * p + 0.5 * uScale + uTrans;
        gl_Position = vec4((p / uRes * 2.0 - 1.0) * vec2(1, -1), 0, 1);
    }
`;
const fsSource = `precision mediump float; uniform vec4 uCol; void main() { gl_FragColor = uCol; }`;

function mkShdr(t, s) { const sh = gl.createShader(t); gl.shaderSource(sh, s); gl.compileShader(sh); return sh; }
const prog = gl.createProgram();
gl.attachShader(prog, mkShdr(gl.VERTEX_SHADER, vsSource));
gl.attachShader(prog, mkShdr(gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(prog); gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const uRes = gl.getUniformLocation(prog, 'uRes'), uTrans = gl.getUniformLocation(prog, 'uTrans'),
      uScale = gl.getUniformLocation(prog, 'uScale'), uRot = gl.getUniformLocation(prog, 'uRot'), uCol = gl.getUniformLocation(prog, 'uCol');

// --- GAME STATE ---
let player = { x: 150, y: 300, w: 25, h: 25, vx: 0, vy: 0, jumps: 0, tool: 'hammer' };
let world = [], enemies = [], stars = [];
let camX = 0, targetCamX = 0;
const LVL_WIDTH = 12000;

function spawn(x, y, w, h, type, color, hp = 1) {
    world.push({ x, y, w, h, type, color, rot: 0, hp, maxHp: hp, speed: (type === 'conveyer' ? 3 : 0) });
}

function generate() {
    world = []; enemies = []; stars = [];
    player.x = 150; player.y = 300; player.vx = 0; player.vy = 0;
    for(let i=0; i<150; i++) stars.push({ x: Math.random() * 2000, y: Math.random() * 800, s: 2+Math.random()*3, d: 0.1+Math.random()*0.4 });
    
    spawn(0, 0, LVL_WIDTH, 40, 'wall', [0.1, 0.1, 0.15, 1]); // Top
    spawn(0, 800, LVL_WIDTH, 60, 'wall', [0.1, 0.1, 0.15, 1]); // Bottom

    for (let x = 0; x < LVL_WIDTH; x += 800) {
        spawn(x, 40, 40, 760, 'wall', [0.2, 0.2, 0.2, 1]); // Room Dividers
        let ry = 300 + Math.random() * 300;
        spawn(x + 200, ry, 300, 30, 'conveyer', [0.2, 0.4, 0.8, 1]);
        
        // Add a breakable block on the path
        spawn(x + 500, ry - 100, 40, 100, 'breakable', [0.8, 0.4, 0.2, 1], 100);
        
        enemies.push({ x: x + 300, y: ry - 40, w: 30, h: 30, vx: 0, timer: 0 });
    }
}

// --- INPUTS ---
const keys = {};
const hammerSlot = document.getElementById('slotHammer');
const kickSlot = document.getElementById('slotKick');

function selectTool(tool) {
    player.tool = tool;
    document.getElementById('toolName').innerText = tool.toUpperCase();
    hammerSlot.classList.toggle('active', tool === 'hammer');
    kickSlot.classList.toggle('active', tool === 'kick');
}

hammerSlot.onmousedown = () => selectTool('hammer');
kickSlot.onmousedown = () => selectTool('kick');
document.getElementById('regenBtn').onmousedown = generate;

const handleJump = () => {
    // Jump if grounded, otherwise "Hit" in the air
    if(player.jumps < 2) { player.vy = -11; player.jumps++; }
};

const setupBtn = (id, key) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; }, {passive: false});
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, {passive: false});
    el.onmousedown = () => keys[key] = true; el.onmouseup = () => keys[key] = false;
};

setupBtn('btnLeft', 'KeyA'); setupBtn('btnRight', 'KeyD');
document.getElementById('btnJump').addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); }, {passive: false});
document.getElementById('btnJump').onmousedown = handleJump;

window.onkeydown = e => { keys[e.code] = true; if(e.code==='Space') handleJump(); };
window.onkeyup = e => keys[e.code] = false;

// --- PHYSICS ENGINE ---
function update() {
    if (keys.KeyA) player.vx = -6.5;
    else if (keys.KeyD) player.vx = 6.5;
    else player.vx *= 0.8;

    // Phase 1: Horizontal Movement & Collision
    player.x += player.vx;
    resolveCollision('x');

    // Phase 2: Vertical Movement & Collision
    player.vy += 0.55;
    player.y += player.vy;
    resolveCollision('y');

    // Camera
    camX += (player.x - canvas.width / 3 - camX) * 0.1;

    // Enemies
    enemies.forEach(e => {
        e.timer++; e.x += Math.sin(e.timer * 0.05) * 2;
        if(Math.abs(player.x - e.x) < 25 && Math.abs(player.y - e.y) < 25) generate();
    });

    if(player.y > 1500) generate();
}

function resolveCollision(axis) {
    world.forEach((o, idx) => {
        if(player.x < o.x + o.w && player.x + player.w > o.x && 
           player.y < o.y + o.h && player.y + player.h > o.y) {
            
            // Interaction logic for breakable walls
            if(o.type === 'breakable') {
                let damage = (player.tool === 'hammer') ? 5 : 1;
                // Only damage if we are moving against it or jumping into it
                if(Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.1) {
                    o.hp -= damage;
                    // Change color based on damage
                    o.color[3] = o.hp / o.maxHp; 
                }
                if(o.hp <= 0) { world.splice(idx, 1); return; }
            }

            if(axis === 'x') {
                if(player.vx > 0) player.x = o.x - player.w;
                else if(player.vx < 0) player.x = o.x + o.w;
                player.vx = 0;
            } else {
                if(player.vy > 0) {
                    player.y = o.y - player.h; player.vy = 0; player.jumps = 0;
                    if(o.type === 'conveyer') player.x += o.speed;
                } else if(player.vy < 0) {
                    player.y = o.y + o.h; player.vy = 0;
                }
            }
        }
    });
}

function draw() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(uRes, canvas.width, canvas.height);

    const render = (x, y, w, h, col, r=0, sf=1) => {
        gl.uniform2f(uTrans, x - camX * sf, y); gl.uniform2f(uScale, w, h);
        gl.uniform1f(uRot, r); gl.uniform4f(uCol, ...col);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    };

    stars.forEach(s => render(s.x, s.y, s.s, s.s, [1,1,1,s.d], 0, s.d));
    world.forEach(o => render(o.x, o.y, o.w, o.h, o.color, 0, 1));
    enemies.forEach(e => render(e.x, e.y, e.w, e.h, [1,0,0,1], 0, 1));
    render(player.x, player.y, player.w, player.h, [0,1,1,1], 0, 1);

    update();
    requestAnimationFrame(draw);
}

generate();
draw();
</script>
</body>
</html>

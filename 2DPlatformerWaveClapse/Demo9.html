<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Gauntlet: Verticality & Particles</title>
    <style>
        * {
            user-select: none; -webkit-user-select: none; 
            -webkit-touch-callout: none; -webkit-tap-highlight-color: transparent; 
            touch-action: none; 
        }
        body { 
            margin: 0; overflow: hidden; background: #020205; 
            font-family: 'Segoe UI', sans-serif; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0ff; pointer-events: none; text-shadow: 2px 2px #000; z-index: 10; }
        
        .inventory { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 100; }
        .slot { 
            width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #555; 
            color: white; display: flex; align-items: center; justify-content: center; 
            font-size: 10px; font-weight: bold; cursor: pointer; border-radius: 8px;
        }
        .slot.active { border-color: #f0f; box-shadow: 0 0 10px #f0f; background: rgba(255, 0, 255, 0.2); }

        .controls { position: absolute; bottom: 30px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 100; }
        .btn-group { display: flex; gap: 15px; pointer-events: none; }
        .btn { 
            width: 70px; height: 70px; background: rgba(0, 255, 255, 0.1); border: 2px solid #0ff; 
            border-radius: 50%; display: flex; align-items: center; justify-content: center; 
            color: #0ff; font-weight: bold; pointer-events: auto; backdrop-filter: blur(4px); 
        }
        .btn:active { background: rgba(0, 255, 255, 0.4); }
        #btnAttack { background: rgba(255, 0, 0, 0.1); border-color: #f44; color: #f44; width: 85px; height: 85px; }
    </style>
</head>
<body>
    <div id="ui">
        <h1 style="margin:0; font-size: 18px;">GAUNTLET: BREAKOUT</h1>
        <p id="camStatus" style="margin:5px 0;">Tool: <span id="toolName">HAMMER</span></p>
    </div>

    <div class="inventory">
        <div class="slot active" id="slotHammer">HAMMER</div>
        <div class="slot" id="slotKick">KICK</div>
        <div class="slot" id="regenBtn" style="border-color: #0f0; color: #0f0;">REGEN</div>
    </div>
    
    <div class="controls">
        <div class="btn-group">
            <div class="btn" id="btnLeft">L</div>
            <div class="btn" id="btnRight">R</div>
        </div>
        <div class="btn-group">
            <div class="btn" id="btnAttack">ATTACK</div>
            <div class="btn" id="btnJump">JUMP</div>
        </div>
    </div>

    <canvas id="glCanvas"></canvas>

<script>
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

const vsSource = `
    attribute vec2 aPos;
    uniform vec2 uRes, uTrans, uScale;
    uniform float uRot;
    void main() {
        float s = sin(uRot), c = cos(uRot);
        mat2 rot = mat2(c, s, -s, c);
        vec2 p = (aPos - 0.5) * uScale;
        p = rot * p + 0.5 * uScale + uTrans;
        gl_Position = vec4((p / uRes * 2.0 - 1.0) * vec2(1, -1), 0, 1);
    }
`;
const fsSource = `precision mediump float; uniform vec4 uCol; void main() { gl_FragColor = uCol; }`;

function mkShdr(t, s) { const sh = gl.createShader(t); gl.shaderSource(sh, s); gl.compileShader(sh); return sh; }
const prog = gl.createProgram();
gl.attachShader(prog, mkShdr(gl.VERTEX_SHADER, vsSource));
gl.attachShader(prog, mkShdr(gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(prog); gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.enableVertexAttribArray(aPos);
gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

const uRes = gl.getUniformLocation(prog, 'uRes'), uTrans = gl.getUniformLocation(prog, 'uTrans'),
      uScale = gl.getUniformLocation(prog, 'uScale'), uRot = gl.getUniformLocation(prog, 'uRot'), uCol = gl.getUniformLocation(prog, 'uCol');

// --- GAME STATE ---
let player = { x: 150, y: 300, w: 25, h: 25, vx: 0, vy: 0, jumps: 0, tool: 'hammer', isAttacking: false };
let world = [], enemies = [], stars = [], particles = [];
let camX = 0, camY = 0;
const LVL_WIDTH = 12000;

function spawn(x, y, w, h, type, color, hp = 1) {
    world.push({ x, y, w, h, type, color, rot: 0, hp, maxHp: hp, speed: (type === 'conveyer' ? 3 : 0) });
}

function createParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*10,
            vy: (Math.random()-0.5)*10,
            life: 1.0,
            col: [color[0], color[1], color[2], 1.0],
            size: 3 + Math.random()*5
        });
    }
}

function generate() {
    world = []; enemies = []; stars = []; particles = [];
    player.x = 150; player.y = 300; player.vx = 0; player.vy = 0;
    for(let i=0; i<150; i++) stars.push({ x: Math.random() * 2000, y: Math.random() * 1200, s: 2+Math.random()*3, d: 0.1+Math.random()*0.4 });
    
    spawn(0, -1000, LVL_WIDTH, 60, 'wall', [0.1, 0.1, 0.15, 1]); // Sky boundary
    spawn(0, 1200, LVL_WIDTH, 100, 'wall', [0.1, 0.1, 0.15, 1]); // Deep Floor

    for (let x = 0; x < LVL_WIDTH; x += 800) {
        // Room Dividers are now BREAKABLE walls so you don't get trapped
        spawn(x, -500, 40, 1700, 'breakable', [0.4, 0.4, 0.4, 1], 150); 
        
        let ry = 200 + Math.random() * 600;
        spawn(x + 200, ry, 400, 30, 'conveyer', [0.2, 0.4, 0.8, 1]);
        
        if (Math.random() > 0.3) {
            spawn(x + 400, ry - 150, 60, 150, 'breakable', [0.7, 0.3, 0.1, 1], 80);
        }
        
        enemies.push({ x: x + 300, y: ry - 40, w: 30, h: 30, vx: 0, timer: 0 });
    }
}

// --- INPUTS ---
const keys = {};
const handleJump = () => { if(player.jumps < 2) { player.vy = -12; player.jumps++; } };
const handleAttack = () => { player.isAttacking = true; setTimeout(() => player.isAttacking = false, 150); };

const setupBtn = (id, key, callback) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); if(callback) callback(); else keys[key] = true; }, {passive: false});
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, {passive: false});
    el.onmousedown = () => { if(callback) callback(); else keys[key] = true; };
    el.onmouseup = () => keys[key] = false;
};

setupBtn('btnLeft', 'KeyA'); setupBtn('btnRight', 'KeyD');
setupBtn('btnJump', null, handleJump);
setupBtn('btnAttack', null, handleAttack);

document.getElementById('slotHammer').onclick = () => { player.tool = 'hammer'; document.getElementById('toolName').innerText='HAMMER'; };
document.getElementById('slotKick').onclick = () => { player.tool = 'kick'; document.getElementById('toolName').innerText='KICK'; };
document.getElementById('regenBtn').onclick = generate;

window.onkeydown = e => { 
    keys[e.code] = true; 
    if(e.code==='Space') handleJump(); 
    if(e.code==='KeyF' || e.code==='ShiftLeft') handleAttack(); 
};
window.onkeyup = e => keys[e.code] = false;

// --- PHYSICS & COLLISION ---
function update() {
    if (keys.KeyA) player.vx = -7;
    else if (keys.KeyD) player.vx = 7;
    else player.vx *= 0.8;

    player.x += player.vx;
    resolveCollision('x');
    player.vy += 0.6;
    player.y += player.vy;
    resolveCollision('y');

    // Camera with Vertical Following
    let targetX = player.x - canvas.width / 3;
    let targetY = player.y - canvas.height / 2;
    camX += (targetX - camX) * 0.1;
    camY += (targetY - camY) * 0.05; // Smoother vertical follow

    // Particles logic
    particles = particles.filter(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02;
        p.col[3] = p.life;
        return p.life > 0;
    });

    enemies.forEach(e => {
        e.timer++; e.x += Math.sin(e.timer * 0.05) * 2;
        if(Math.abs(player.x - e.x) < 25 && Math.abs(player.y - e.y) < 25) generate();
    });
}

function resolveCollision(axis) {
    world.forEach((o, idx) => {
        if(player.x < o.x + o.w && player.x + player.w > o.x && 
           player.y < o.y + o.h && player.y + player.h > o.y) {
            
            if(o.type === 'breakable') {
                if(player.isAttacking) {
                    let damage = (player.tool === 'hammer') ? 10 : 3;
                    o.hp -= damage;
                    createParticles(player.x + player.w/2, player.y + player.h/2, o.color);
                    if(o.hp <= 0) { world.splice(idx, 1); return; }
                }
            }

            if(axis === 'x') {
                if(player.vx > 0) player.x = o.x - player.w;
                else if(player.vx < 0) player.x = o.x + o.w;
                player.vx = 0;
            } else {
                if(player.vy > 0) {
                    player.y = o.y - player.h; player.vy = 0; player.jumps = 0;
                    if(o.type === 'conveyer') player.x += o.speed;
                } else if(player.vy < 0) {
                    player.y = o.y + o.h; player.vy = 0;
                }
            }
        }
    });
}

function draw() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.01, 0.01, 0.03, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(uRes, canvas.width, canvas.height);

    const render = (x, y, w, h, col, r=0, sf=1) => {
        gl.uniform2f(uTrans, x - camX * sf, y - camY * sf); 
        gl.uniform2f(uScale, w, h);
        gl.uniform1f(uRot, r); gl.uniform4f(uCol, ...col);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    };

    stars.forEach(s => render(s.x, s.y, s.s, s.s, [1,1,1,s.d], 0, s.d));
    world.forEach(o => render(o.x, o.y, o.w, o.h, o.color, 0, 1));
    particles.forEach(p => render(p.x, p.y, p.size, p.size, p.col, 0, 1));
    enemies.forEach(e => render(e.x, e.y, e.w, e.h, [1,0,0,1], 0, 1));
    
    // Player color flash when attacking
    let pCol = player.isAttacking ? [1, 1, 1, 1] : [0, 1, 1, 1];
    render(player.x, player.y, player.w, player.h, pCol, 0, 1);

    update();
    requestAnimationFrame(draw);
}

generate();
draw();
</script>
</body>
</html>

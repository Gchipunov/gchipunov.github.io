<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WebGL 2D Platformer - Walls & WFC</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        .gen-btn { position: absolute; top: 20px; right: 20px; padding: 10px 20px; background: #ffcc00; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; pointer-events: auto; z-index: 10; }
        .controls { position: absolute; bottom: 30px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-end; pointer-events: none; }
        .btn-group { display: flex; gap: 20px; }
        .btn { width: 70px; height: 70px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 24px; user-select: none; pointer-events: auto; backdrop-filter: blur(5px); }
        .btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.9); }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Wave Collapse + Walls</h1>
        <p>AD / Arrows | Space to Double Jump</p>
    </div>

    <button class="gen-btn" id="regenBtn">GENERATE NEW LEVEL</button>

    <div class="controls">
        <div class="btn-group">
            <div class="btn" id="btnLeft">←</div>
            <div class="btn" id="btnRight">→</div>
        </div>
        <div class="btn" id="btnJump" style="width: 90px; height: 90px;">↑</div>
    </div>

    <canvas id="glCanvas"></canvas>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

if (!gl) { alert('WebGL not supported'); }

const vsSource = `
    attribute vec2 aPosition;
    uniform vec2 uResolution;
    uniform vec2 uTranslation;
    uniform vec2 uScale;
    void main() {
        vec2 position = (aPosition * uScale + uTranslation) / uResolution * 2.0 - 1.0;
        gl_Position = vec4(position * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 uColor;
    void main() { gl_FragColor = uColor; }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

const uRes = gl.getUniformLocation(program, 'uResolution');
const uTrans = gl.getUniformLocation(program, 'uTranslation');
const uScale = gl.getUniformLocation(program, 'uScale');
const uColor = gl.getUniformLocation(program, 'uColor');

// --- GAME STATE ---
const player = {
    x: 100, y: 300,
    width: 25, height: 25,
    vx: 0, vy: 0,
    speed: 6, jumpForce: -13, gravity: 0.65,
    jumps: 0, maxJumps: 2
};

let objects = []; // Now contains both platforms and walls
const levelWidth = 10000;

function generateLevel() {
    objects = [];
    player.x = 100; player.y = 300; player.vx = 0; player.vy = 0;

    const rules = { 0: [0, 1], 1: [0, 1, 2], 2: [1, 2] };
    let currentX = 0;
    let currentHeightIdx = 1;

    // Start Platform
    objects.push({ x: 0, y: 500, w: 400, h: 40, type: 'platform', color: [0.4, 0.4, 0.4, 1.0] });
    currentX = 450;

    while (currentX < levelWidth) {
        const possible = rules[currentHeightIdx];
        currentHeightIdx = possible[Math.floor(Math.random() * possible.length)];
        
        const yPos = [550, 400, 250][currentHeightIdx];
        const width = 150 + Math.random() * 200;
        const gap = 130 + Math.random() * 100;

        // Add Platform
        objects.push({
            x: currentX, y: yPos, w: width, h: 30,
            type: 'platform', color: [0.3, 0.6, 0.9, 1.0]
        });

        // Chance to add a Wall on the platform
        if (Math.random() > 0.6) {
            objects.push({
                x: currentX + width/2, y: yPos - 100, w: 20, h: 100,
                type: 'wall', color: [0.7, 0.7, 0.7, 1.0]
            });
        }

        currentX += width + gap;
    }
}

document.getElementById('regenBtn').onclick = generateLevel;
generateLevel();

// --- INPUTS ---
const keys = {};
function handleJump() { if (player.jumps < player.maxJumps) { player.vy = player.jumpForce; player.jumps++; } }
window.onkeydown = (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') handleJump(); keys[e.code] = true; };
window.onkeyup = (e) => keys[e.code] = false;

const bindTouch = (id, key) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
    el.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
    el.addEventListener('mousedown', () => keys[key] = true);
    el.addEventListener('mouseup', () => keys[key] = false);
};
bindTouch('btnLeft', 'KeyA'); bindTouch('btnRight', 'KeyD');
document.getElementById('btnJump').addEventListener('touchstart', (e) => { e.preventDefault(); handleJump(); });
document.getElementById('btnJump').addEventListener('mousedown', handleJump);

// --- PHYSICS & COLLISION ---
function update() {
    if (keys['KeyA'] || keys['ArrowLeft']) player.vx = -player.speed;
    else if (keys['KeyD'] || keys['ArrowRight']) player.vx = player.speed;
    else player.vx *= 0.85;

    // Apply X first to check wall collisions
    player.x += player.vx;
    checkCollisions('horizontal');

    // Apply Y next to check floor collisions
    player.vy += player.gravity;
    player.y += player.vy;
    checkCollisions('vertical');

    if (player.y > canvas.height + 800) { player.x = 100; player.y = 300; player.vy = 0; }
}

function checkCollisions(axis) {
    objects.forEach(obj => {
        // Simple AABB check
        if (player.x < obj.x + obj.w && player.x + player.width > obj.x &&
            player.y < obj.y + obj.h && player.y + player.height > obj.y) {
            
            if (axis === 'horizontal' && obj.type === 'wall') {
                if (player.vx > 0) player.x = obj.x - player.width;
                else if (player.vx < 0) player.x = obj.x + obj.w;
                player.vx = 0;
            }

            if (axis === 'vertical') {
                // Land on top
                if (player.vy > 0 && player.y + player.height - player.vy <= obj.y) {
                    player.y = obj.y - player.height;
                    player.vy = 0;
                    player.jumps = 0;
                } 
                // Hit head on wall/platform bottom
                else if (player.vy < 0 && obj.type === 'wall') {
                    player.y = obj.y + obj.h;
                    player.vy = 0;
                }
            }
        }
    });
}

function draw() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform2f(uRes, canvas.width, canvas.height);
    const camX = player.x - canvas.width / 3;

    objects.forEach(obj => {
        gl.uniform4f(uColor, ...obj.color);
        gl.uniform2f(uTrans, obj.x - camX, obj.y);
        gl.uniform2f(uScale, obj.w, obj.h);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    });

    gl.uniform4f(uColor, 1.0, 0.8, 0.0, 1.0);
    gl.uniform2f(uTrans, player.x - camX, player.y);
    gl.uniform2f(uScale, player.width, player.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    update();
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>

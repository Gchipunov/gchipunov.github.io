<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL 2D Platformer - Wave Clasps</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Wave Clasps</h1>
        <p>AD / Arrows to Move | Space to Double Jump</p>
    </div>
    <canvas id="glCanvas"></canvas>

<script>
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl');

if (!gl) { alert('WebGL not supported'); }

// --- SHADERS ---
const vsSource = `
    attribute vec2 aPosition;
    uniform vec2 uResolution;
    uniform vec2 uTranslation;
    uniform vec2 uScale;
    void main() {
        vec2 position = (aPosition * uScale + uTranslation) / uResolution * 2.0 - 1.0;
        gl_Position = vec4(position * vec2(1, -1), 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 uColor;
    void main() {
        gl_FragColor = uColor;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

// --- GEOMETRY (Unit Square) ---
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

const uRes = gl.getUniformLocation(program, 'uResolution');
const uTrans = gl.getUniformLocation(program, 'uTranslation');
const uScale = gl.getUniformLocation(program, 'uScale');
const uColor = gl.getUniformLocation(program, 'uColor');

// --- GAME STATE ---
const player = {
    x: 100, y: 300,
    width: 30, height: 30,
    vx: 0, vy: 0,
    speed: 5,
    jumpForce: -12,
    gravity: 0.6,
    jumps: 0,
    maxJumps: 2,
    grounded: false
};

const platforms = [];
const levelWidth = 5000;

// --- WAVE CLASPS GENERATION ---
// Generates a rhythmic pattern of platforms using overlapping sine waves
function generateLevel() {
    platforms.push({ x: 0, y: 500, w: 400, h: 50 }); // Start platform
    
    for (let x = 450; x < levelWidth; x += 250) {
        // The "Wave Clasp": calculating height based on a sine function
        const waveHeight = Math.sin(x * 0.005) * 150 + 400;
        const width = 120 + Math.random() * 80;
        
        platforms.push({
            x: x,
            y: waveHeight,
            w: width,
            h: 30,
            color: [0.3, 0.7, 0.9, 1.0] // Blue-ish platforms
        });

        // Add a "clasp" (smaller platform above)
        if (x % 500 === 0) {
            platforms.push({
                x: x + 50,
                y: waveHeight - 150,
                w: 60,
                h: 20,
                color: [0.9, 0.4, 0.4, 1.0]
            });
        }
    }
}
generateLevel();

const keys = {};
window.onkeydown = (e) => {
    if (e.code === 'Space' && player.jumps < player.maxJumps) {
        player.vy = player.jumpForce;
        player.jumps++;
        player.grounded = false;
    }
    keys[e.code] = true;
};
window.onkeyup = (e) => keys[e.code] = false;

// --- MAIN LOOP ---
function update() {
    // Horizontal Movement
    if (keys['KeyA'] || keys['ArrowLeft']) player.vx = -player.speed;
    else if (keys['KeyD'] || keys['ArrowRight']) player.vx = player.speed;
    else player.vx *= 0.8;

    player.x += player.vx;
    
    // Vertical Movement / Gravity
    player.vy += player.gravity;
    player.y += player.vy;
    player.grounded = false;

    // Collision Detection
    platforms.forEach(p => {
        if (player.x < p.x + p.w && player.x + player.width > p.x &&
            player.y < p.y + p.h && player.y + player.height > p.y) {
            
            // Resolve collision from top
            if (player.vy > 0 && player.y + player.height - player.vy <= p.y) {
                player.y = p.y - player.height;
                player.vy = 0;
                player.jumps = 0;
                player.grounded = true;
            }
        }
    });

    // Reset if fall
    if (player.y > canvas.height + 500) {
        player.x = 100; player.y = 300; player.vy = 0;
    }
}

function draw() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform2f(uRes, canvas.width, canvas.height);

    // Camera follow
    const camX = player.x - canvas.width / 4;

    // Draw Platforms
    platforms.forEach(p => {
        const color = p.color || [0.4, 0.4, 0.4, 1.0];
        gl.uniform4f(uColor, ...color);
        gl.uniform2f(uTrans, p.x - camX, p.y);
        gl.uniform2f(uScale, p.w, p.h);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    });

    // Draw Player
    gl.uniform4f(uColor, 1.0, 0.8, 0.0, 1.0); // Gold color
    gl.uniform2f(uTrans, player.x - camX, player.y);
    gl.uniform2f(uScale, player.width, player.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    update();
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>

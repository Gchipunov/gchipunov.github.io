<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multi-Lane Factory Simulator</title>
    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Set up the container for the 3D canvas */
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0d1117; }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        /* Custom CSS for a cool 3D feeling UI */
        .card-glass {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Style for the packaging button when it's active */
        #package-button:not(:disabled) {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
            animation: pulse-blue 1.5s infinite;
        }
        @keyframes pulse-blue {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <!-- 3D Canvas will be injected here -->
    <div id="game-container"></div>

    <!-- UI Overlay (Tailwind CSS) -->
    <div id="ui-overlay" class="absolute inset-0 z-20 pointer-events-none p-4 md:p-8">
        
        <!-- Score and Stats -->
        <div class="flex justify-between items-start">
            <div class="card-glass text-white p-4 rounded-xl pointer-events-auto">
                <div class="text-xs uppercase opacity-75">Total Shipped Value</div>
                <div id="score" class="text-4xl font-extrabold text-green-400">$0</div>
            </div>
            <div id="message-box" class="text-white text-lg font-semibold card-glass p-3 rounded-xl opacity-0 transition-opacity duration-300 pointer-events-none text-center">
                
            </div>
        </div>

        <!-- Interactive Button Area (Bottom Center) -->
        <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-4 pointer-events-auto">
            <button id="package-button" 
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition duration-150 ease-in-out transform hover:scale-105 disabled:bg-gray-700 disabled:cursor-not-allowed">
                ðŸ“¦ Package Next Item
            </button>
        </div>

    </div>

    <script>
        // --- Global Variables and Constants ---
        const BASE_GAME_SPEED = 0.005; 
        const STATION_X = 0; // X position of the packaging station
        const FC_X = 10; // X position of the Fulfillment Center drop-off
        const SPAWN_X = -15; // X position where materials spawn
        const MATERIAL_Z_OFFSET = 0.5; // Base Z position (height) of the materials
        const CONVEYOR_WIDTH = 1.5;
        
        // Key change: Increased range for packaging to improve mobile playability
        // An item is ready when its X is between STATION_X +/- this range
        const PACKAGING_RANGE = 2.0; 

        // Configuration for four distinct lanes (Y position and item properties)
        const LANES = [
            // Lane 1: Small/Fast - Quick items, smaller window
            { id: 0, y: -4.5, size: 0.6, speedFactor: 1.5, interval: 2000, color: 0x8B4513, value: 50, range: 1.5 },
            // Lane 2: Medium/Standard - Balanced flow
            { id: 1, y: -1.5, size: 0.8, speedFactor: 1.0, interval: 3000, color: 0x6E4A28, value: 100, range: 2.0 },
            // Lane 3: Large/Slow - Highest profit, slow but requires precise timing
            { id: 2, y: 1.5, size: 1.2, speedFactor: 0.7, interval: 5000, color: 0x4B3A2C, value: 250, range: 2.5 },
            // Lane 4: XL/Challenge - High value, faster, tricky
            { id: 3, y: 4.5, size: 1.5, speedFactor: 1.2, interval: 4000, color: 0x2A1C15, value: 300, range: 2.0 }
        ];

        let scene, camera, renderer;
        let materials = [];
        let score = 0;
        let lastSpawnTimes = LANES.map(() => 0); // Tracks last spawn time for each lane
        let itemToPackage = null; // Reference to the item ready for packaging

        const uiScore = document.getElementById('score');
        const uiButton = document.getElementById('package-button');
        const uiMessage = document.getElementById('message-box');
        
        // Custom Material Class to manage state and mesh
        class FactoryItem {
            constructor(laneConfig) {
                this.laneConfig = laneConfig;
                this.type = 'raw'; // 'raw' or 'packaged'
                this.isAtStation = false;
                this.isShipped = false;
                
                let geometry, material;

                // Raw Material (Color based on lane config)
                const size = laneConfig.size;
                geometry = new THREE.BoxGeometry(size, size, size);
                material = new THREE.MeshLambertMaterial({ color: laneConfig.color });
                
                this.mesh = new THREE.Mesh(geometry, material);
                // Position Y is the belt height + half the size of the item
                this.mesh.position.set(SPAWN_X, MATERIAL_Z_OFFSET + size / 2, laneConfig.y);
            }

            // Converts the raw item into a packaged item
            convertToPackage() {
                if (this.type !== 'raw') return;

                this.type = 'packaged';
                
                // Change appearance to a white, packaged look
                const packagedSize = this.laneConfig.size * 1.1; // Slightly bigger when packaged
                
                // Dispose and replace geometry/material to save memory
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                this.mesh.geometry = new THREE.BoxGeometry(packagedSize, packagedSize, packagedSize);
                this.mesh.material = new THREE.MeshLambertMaterial({ color: 0xf5f5f5 }); // Light gray/white package
                
                // Remove the glow
                this.mesh.material.emissive.setHex(0x000000);

                // Add tape/label visualization
                const tapeMaterial = new THREE.MeshLambertMaterial({ color: 0xffa500 }); 
                const tapeGeometry = new THREE.BoxGeometry(packagedSize, 0.1, packagedSize * 0.8);
                const tapeMesh = new THREE.Mesh(tapeGeometry, tapeMaterial);
                tapeMesh.position.y = (packagedSize / 2) + 0.06;
                this.mesh.add(tapeMesh);
            }

            update(deltaTime) {
                if (this.isShipped) return;

                // Speed is based on base speed * lane factor
                this.mesh.position.x += BASE_GAME_SPEED * this.laneConfig.speedFactor * deltaTime;
                
                // Check if the item is in the expanded Packaging Range
                if (this.type === 'raw') {
                    const range = this.laneConfig.range;
                    const minX = STATION_X - range;
                    const maxX = STATION_X + range;
                    
                    if (this.mesh.position.x >= minX && this.mesh.position.x <= maxX) {
                        this.isAtStation = true;
                    } else {
                        this.isAtStation = false;
                    }
                }

                // Check for shipping (reaching the FC)
                if (this.mesh.position.x >= FC_X) {
                    this.isShipped = true;
                    return true; // Signal that it was shipped
                }
                return false;
            }
        }


        // --- Utility Functions ---

        function showMessage(text, duration = 2000, isError = false) {
            uiMessage.textContent = text;
            // Use different background for errors
            uiMessage.className = `text-white text-lg font-semibold card-glass p-3 rounded-xl transition-opacity duration-300 pointer-events-none ${isError ? 'bg-red-700' : 'bg-transparent'}`;
            uiMessage.classList.remove('opacity-0');
            uiMessage.classList.add('opacity-100');
            clearTimeout(window.messageTimeout);
            window.messageTimeout = setTimeout(() => {
                uiMessage.classList.remove('opacity-100');
                uiMessage.classList.add('opacity-0');
            }, duration);
        }

        function updateScore(amount) {
            score += amount;
            uiScore.textContent = `$${score.toLocaleString()}`;
        }

        // --- Core Three.js Setup ---

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e); 

            // Camera (Adjusted Y position to view all four lanes)
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(-2, 10, 16); // Move back and up to see all lanes
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); 
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Create Factory Environment
            createGround();
            createConveyorBelt();
            createPackagingStation();
            createFulfillmentCenter();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            uiButton.addEventListener('click', packageItem);

            // Initial Material Spawns
            LANES.forEach((lane) => spawnMaterial(lane));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Factory Structure Creation ---

        function createGround() {
            // Expanded ground to cover all lanes (Z dimension is wider)
            const geometry = new THREE.PlaneGeometry(35, 15);
            const material = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            scene.add(ground);
        }

        function createConveyorBelt() {
            // Create 4 distinct conveyor belts based on LANES configuration
            LANES.forEach(lane => {
                const geometry = new THREE.BoxGeometry(30, 0.5, CONVEYOR_WIDTH);
                const material = new THREE.MeshLambertMaterial({ color: 0x5a6a7c });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(0, 0.25, lane.y);
                scene.add(mesh);
            });
        }
        
        function createPackagingStation() {
            // Packaging machine structure centered across all lanes
            const totalLaneWidth = LANES[LANES.length - 1].y - LANES[0].y + CONVEYOR_WIDTH;
            
            // Red Machine structure
            const geometry = new THREE.BoxGeometry(4, 3, totalLaneWidth + 1); // Wider Z
            const material = new THREE.MeshStandardMaterial({ color: 0xc0392b }); // Red machine
            const station = new THREE.Mesh(geometry, material);
            station.position.set(STATION_X, 1.5, 0);
            scene.add(station);

            // Packaging platform
            const platform = new THREE.BoxGeometry(4.5, 0.2, totalLaneWidth + 1);
            const platformMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7 }); // Silver platform
            const platMesh = new THREE.Mesh(platform, platformMat);
            platMesh.position.set(STATION_X, 0.5, 0);
            scene.add(platMesh);
        }

        function createFulfillmentCenter() {
            // FC drop-off point on the right (X=10), spanning all lanes
            const totalLaneWidth = LANES[LANES.length - 1].y - LANES[0].y + CONVEYOR_WIDTH;

            const geometry = new THREE.BoxGeometry(2, 3, totalLaneWidth + 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x27ae60, transparent: true, opacity: 0.6 }); // Green zone
            const fcZone = new THREE.Mesh(geometry, material);
            fcZone.position.set(FC_X, 1.5, 0);
            scene.add(fcZone);

            // Label for the FC zone
            const labelGeo = new THREE.BoxGeometry(2, 0.1, 1);
            const labelMat = new THREE.MeshBasicMaterial({ color: 0x2ecc71 });
            const labelMesh = new THREE.Mesh(labelGeo, labelMat);
            labelMesh.position.set(FC_X, 3.1, 0);
            scene.add(labelMesh);
        }
        
        // --- Game Logic Functions ---
        
        function spawnMaterial(laneConfig) {
            const newItem = new FactoryItem(laneConfig);
            scene.add(newItem.mesh);
            materials.push(newItem);
        }
        
        function packageItem() {
            if (!itemToPackage) {
                showMessage("Nothing ready! Wait for an item to reach the station.", 1500, true);
                return;
            }

            // Package the item found in the animate loop
            const item = itemToPackage;
            
            // Perform the packaging conversion
            item.convertToPackage();
            
            // Reset the ready state for the next frame
            itemToPackage = null; 

            // Update UI state
            uiButton.disabled = true;
            uiButton.textContent = `Item Packaged! Value: $${item.laneConfig.value}`;
            showMessage(`Package Complete! Lane ${item.laneConfig.id + 1}`, 1000);
        }
        
        let lastUpdateTime = performance.now();

        function animate(currentTime) {
            requestAnimationFrame(animate);

            const deltaTime = currentTime - lastUpdateTime;
            lastUpdateTime = currentTime;

            // 1. Spawning Logic (Check intervals for all lanes)
            LANES.forEach((lane, index) => {
                if (currentTime - lastSpawnTimes[index] > lane.interval) {
                    // Check if the lane is clear to prevent stacking items too close together
                    const laneIsClear = !materials.some(item => 
                        item.laneConfig.id === lane.id && 
                        item.mesh.position.x < SPAWN_X + 2.0);

                    if(laneIsClear) {
                        spawnMaterial(lane);
                        lastSpawnTimes[index] = currentTime;
                    }
                }
            });

            // 2. Movement and State Update
            itemToPackage = null; // Reset the ready item for this frame
            let itemsToRemove = [];
            let itemFound = false;

            materials.forEach(item => {
                const shipped = item.update(deltaTime);
                
                // If a raw item is at the station AND we haven't found an item yet this frame
                if (item.type === 'raw' && item.isAtStation && !itemFound) {
                    itemToPackage = item;
                    itemFound = true; // Flag to ensure only one item is ready at a time for the single button
                }
                
                if (shipped) {
                    // Item reached the FC (Fulfillment Center)
                    const itemValue = item.laneConfig.value;
                    
                    if (item.type === 'packaged') {
                        updateScore(itemValue);
                        showMessage(`+ $${itemValue} SHIPPED! Lane ${item.laneConfig.id + 1}`, 1000);
                    } else {
                        // Raw material reached the FC un-packaged (penalty)
                        const penalty = Math.round(itemValue / 2);
                        updateScore(-penalty);
                        showMessage(`-$${penalty} LOST! Unpackaged (Lane ${item.laneConfig.id + 1})`, 1500, true);
                    }
                    
                    itemsToRemove.push(item);
                }
                
                // If the item is raw but NOT the one currently ready, ensure its glow is off
                if (item.type === 'raw' && itemToPackage !== item) {
                    item.mesh.material.emissive.setHex(0x000000); 
                }
            });

            // 3. Cleanup Shipped Items
            itemsToRemove.forEach(item => {
                scene.remove(item.mesh);
                materials = materials.filter(i => i !== item);
            });
            
            // 4. UI Button State Management
            if (itemToPackage) {
                uiButton.disabled = false;
                uiButton.textContent = `ðŸ“¦ PACKAGE Lane ${itemToPackage.laneConfig.id + 1} ($${itemToPackage.laneConfig.value})`;
                // Add a visual indicator (glow) to the item currently ready
                itemToPackage.mesh.material.emissive.setHex(0x00ff00);
                itemToPackage.mesh.material.emissiveIntensity = 0.8;
            } else {
                uiButton.disabled = true;
                uiButton.textContent = "Waiting for Material...";
            }
            
            // 5. Camera Animation (Dynamic view)
            camera.position.x = Math.sin(currentTime * 0.00005) * 3 - 2;
            camera.position.z = 16 + Math.cos(currentTime * 0.00005) * 3;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }

        // Start the game once the window is loaded
        window.onload = function() {
            init();
            animate(performance.now()); // Start the animation loop
            updateScore(0); // Initialize score display
            showMessage("Four Lane Factory Online! Get Ready!", 3000);
        };

    </script>
</body>
</html>

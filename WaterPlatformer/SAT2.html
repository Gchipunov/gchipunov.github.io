<!DOCTYPE html>
<html>
<head>
    <title>WebGL Water Platformer + Touch</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; overflow: hidden; background: #222; font-family: sans-serif; 
            touch-action: none; /* Prevent browser zooming/scrolling */
            user-select: none; 
            -webkit-user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #controls-info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 4px;
            pointer-events: none; font-size: 14px;
        }

        /* --- TOUCH CONTROLS UI --- */
        .touch-layer {
            position: absolute; bottom: 20px; width: 100%; height: 150px;
            pointer-events: none; /* Let touches pass through gaps */
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
        }
        
        .dpad, .actions {
            pointer-events: auto;
            position: relative; width: 160px; height: 160px;
        }

        .btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white; font-weight: bold; font-size: 24px;
            display: flex; align-items: center; justify-content: center;
            touch-action: none;
            backdrop-filter: blur(2px);
        }
        .btn:active { background: rgba(255, 255, 255, 0.4); }

        /* D-Pad Placement */
        #btn-left { width: 60px; height: 60px; top: 50px; left: 0; }
        #btn-right { width: 60px; height: 60px; top: 50px; right: 0; }
        #btn-down { width: 60px; height: 60px; bottom: 0; left: 50px; }

        /* Actions Placement */
        #btn-jump { width: 70px; height: 70px; bottom: 20px; right: 0; background: rgba(50, 200, 50, 0.2); }
        #btn-slash { width: 60px; height: 60px; bottom: 0px; right: 80px; background: rgba(200, 50, 50, 0.2); font-size: 18px; }

        @media (min-width: 1024px) {
            /* Hide touch controls on large desktops if desired, 
               but kept visible here for testing */
            /* .touch-layer { display: none; } */
        }
    </style>
</head>
<body>

<div id="controls-info">
    <strong>Keyboard:</strong> Arrows/WASD, Space, Shift<br>
    <strong>Touch:</strong> On-screen buttons
</div>

<canvas id="glCanvas"></canvas>

<div class="touch-layer">
    <div class="dpad">
        <div class="btn" id="btn-left">←</div>
        <div class="btn" id="btn-right">→</div>
        <div class="btn" id="btn-down">↓</div>
    </div>
    <div class="actions">
        <div class="btn" id="btn-slash">⚔️</div>
        <div class="btn" id="btn-jump">↨</div>
    </div>
</div>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec4 a_color;
    uniform vec2 u_resolution;
    varying vec4 v_color;
    void main() {
        vec2 zeroToOne = a_position / u_resolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_color = a_color;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
</script>

<script>
/** * --- 1. VECTOR MATH --- 
 */
const Vec2 = {
    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
    dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
    normalize: (v) => {
        const len = Math.sqrt(v.x * v.x + v.y * v.y);
        return len === 0 ? {x:0, y:0} : { x: v.x / len, y: v.y / len };
    },
    perp: (v) => ({ x: -v.y, y: v.x })
};

/** * --- 2. PHYSICS (SAT & WATER) --- 
 */
function getAxes(vertices) {
    const axes = [];
    for (let i = 0; i < vertices.length; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % vertices.length];
        const edge = Vec2.sub(p2, p1);
        axes.push(Vec2.normalize(Vec2.perp(edge)));
    }
    return axes;
}

function project(vertices, axis) {
    let min = Vec2.dot(vertices[0], axis);
    let max = min;
    for (let i = 1; i < vertices.length; i++) {
        const p = Vec2.dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    return { min, max };
}

function checkSAT(polyA, polyB) {
    let overlap = Infinity;
    let smallestAxis = null;
    const axes = [...getAxes(polyA), ...getAxes(polyB)];

    for (let axis of axes) {
        const p1 = project(polyA, axis);
        const p2 = project(polyB, axis);
        if (p1.max < p2.min || p2.max < p1.min) return null;
        const o = Math.min(p1.max, p2.max) - Math.max(p1.min, p2.min);
        if (o < overlap) {
            overlap = o;
            smallestAxis = axis;
        }
    }
    const centerA = getCenter(polyA);
    const centerB = getCenter(polyB);
    const dir = Vec2.sub(centerA, centerB);
    
    if (Vec2.dot(dir, smallestAxis) < 0) {
        smallestAxis = { x: -smallestAxis.x, y: -smallestAxis.y };
    }
    return { x: smallestAxis.x * overlap, y: smallestAxis.y * overlap };
}

function getCenter(vertices) {
    let x = 0, y = 0;
    for (let v of vertices) { x += v.x; y += v.y; }
    return { x: x / vertices.length, y: y / vertices.length };
}

function createBoxPoly(x, y, w, h) {
    return [{x,y}, {x:x+w,y}, {x:x+w,y:y+h}, {x,y:y+h}];
}

class ParticleSystem {
    constructor() { this.particles = []; }
    spawn(x, y, count, type) {
        for(let i=0; i<count; i++) {
            this.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 1) * 6 - 2,
                life: 1.0,
                color: type === 'water' ? [0.6, 0.8, 1, 1] : [1, 1, 0.8, 1],
                size: Math.random() * 4 + 2
            });
        }
    }
    update() {
        for(let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.02;
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    }
}

class Water {
    constructor(x, y, width, height, segments) {
        this.x = x; this.y = y; this.width = width; this.height = height;
        this.baseHeight = y; this.springs = []; this.spacing = width / segments;
        this.k = 0.025; this.dampening = 0.025; this.spread = 0.25;
        for (let i = 0; i <= segments; i++) this.springs.push({ p: 0, v: 0 });
    }
    update() {
        for (let i = 0; i < this.springs.length; i++) {
            let s = this.springs[i];
            s.v += (-this.k * s.p - this.dampening * s.v);
            s.p += s.v;
        }
        const left = new Array(this.springs.length).fill(0);
        const right = new Array(this.springs.length).fill(0);
        for (let j = 0; j < 4; j++) {
            for (let i = 0; i < this.springs.length; i++) {
                if (i > 0) {
                    left[i] = this.spread * (this.springs[i].p - this.springs[i - 1].p);
                    this.springs[i - 1].v += left[i];
                }
                if (i < this.springs.length - 1) {
                    right[i] = this.spread * (this.springs[i].p - this.springs[i + 1].p);
                    this.springs[i + 1].v += right[i];
                }
            }
            for (let i = 0; i < this.springs.length; i++) {
                if (i > 0) this.springs[i - 1].p += left[i];
                if (i < this.springs.length - 1) this.springs[i + 1].p += right[i];
            }
        }
    }
    splash(xPos, speed) {
        let index = Math.floor((xPos - this.x) / this.spacing);
        if (index >= 0 && index < this.springs.length) this.springs[index].v = speed;
    }
}

/** * --- 3. WEBGL SETUP --- 
 */
const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl");

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null;
    }
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById("vertex-shader").text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fragment-shader").text));
gl.linkProgram(program);
gl.useProgram(program);

const positionLoc = gl.getAttribLocation(program, "a_position");
const colorLoc = gl.getAttribLocation(program, "a_color");
const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
const positionBuffer = gl.createBuffer();
const colorBuffer = gl.createBuffer();

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// --- Game State ---
const gravity = 0.5;
const water = new Water(100, 450, 700, 300, 100);
const particles = new ParticleSystem();

const platforms = [
    {x: 50, y: 350, w: 150, h: 30},
    {x: 750, y: 300, w: 150, h: 30},
    {x: 350, y: 200, w: 200, h: 30},
    {x: 0, y: 550, w: 200, h: 50}, 
    {x: 700, y: 550, w: 300, h: 50}
];

const player = {
    x: 100, y: 100, w: 30, h: 50,
    vx: 0, vy: 0, speed: 5, jump: -12,
    grounded: false, inWater: false, ducking: false,
    facingRight: true, attackTime: 0,
    color: [1, 0.2, 0.2, 1]
};

// --- INPUT HANDLING (Keyboard & Touch) ---
const keys = {};

// Keyboard
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

// Touch Helper
function bindTouch(id, keyCode) {
    const btn = document.getElementById(id);
    const handler = (state) => (e) => {
        if(e.cancelable) e.preventDefault(); // Stop scrolling
        keys[keyCode] = state;
    };
    btn.addEventListener('touchstart', handler(true), {passive: false});
    btn.addEventListener('touchend', handler(false), {passive: false});
    btn.addEventListener('mousedown', handler(true)); // Mouse fallback
    btn.addEventListener('mouseup', handler(false));
    btn.addEventListener('mouseleave', handler(false));
}

// Bind Buttons
bindTouch('btn-left', 'ArrowLeft');
bindTouch('btn-right', 'ArrowRight');
bindTouch('btn-down', 'ArrowDown');
bindTouch('btn-jump', 'Space');
bindTouch('btn-slash', 'KeyF');

// --- Drawing Helpers ---
let positions = [];
let colors = [];

function drawRect(x, y, w, h, col) {
    positions.push(x,y, x+w,y, x,y+h, x,y+h, x+w,y, x+w,y+h);
    for(let i=0; i<6; i++) colors.push(...col);
}

function render() {
    positions = []; colors = [];

    // Platforms
    for (let p of platforms) drawRect(p.x, p.y, p.w, p.h, [0.4, 0.4, 0.4, 1]);

    // Player
    drawRect(player.x, player.y, player.w, player.h, player.color);

    // Slash
    if (player.attackTime > 0) {
        let slashX = player.facingRight ? player.x + player.w : player.x - 50;
        let slashColor = [1, 1, 0.2, player.attackTime / 10]; 
        drawRect(slashX, player.y + 10, 50, 30, slashColor);
    }

    // Particles
    for (let p of particles.particles) drawRect(p.x, p.y, p.size, p.size, p.color);

    // Water
    for (let i = 0; i < water.springs.length - 1; i++) {
        let x1 = water.x + i * water.spacing;
        let y1 = water.baseHeight + water.springs[i].p;
        let x2 = water.x + (i + 1) * water.spacing;
        let y2 = water.baseHeight + water.springs[i + 1].p;
        let yB = water.baseHeight + water.height;
        positions.push(x1, y1, x2, y2, x1, yB, x1, yB, x2, y2, x2, yB);
        const tc = [0.2, 0.6, 0.9, 0.8], bc = [0.1, 0.3, 0.6, 0.9];
        colors.push(...tc, ...tc, ...bc, ...bc, ...tc, ...bc);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);
}

// --- Main Update ---
function update() {
    player.vx = 0;
    if (keys['ArrowLeft'] || keys['KeyA']) { player.vx = -player.speed; player.facingRight = false; }
    if (keys['ArrowRight'] || keys['KeyD']) { player.vx = player.speed; player.facingRight = true; }

    // Ducking
    if ((keys['ArrowDown'] || keys['KeyS']) && !player.inWater) {
        if(!player.ducking) { player.h = 25; player.y += 25; player.ducking = true; }
    } else if (player.ducking) {
        player.h = 50; player.y -= 25; player.ducking = false;
    }

    // Slashing
    if (player.attackTime > 0) player.attackTime--;
    if ((keys['ShiftLeft'] || keys['KeyF']) && player.attackTime === 0) {
        player.attackTime = 15;
        particles.spawn(player.facingRight ? player.x + player.w : player.x, player.y + 20, 5, 'spark');
    }

    // Water Logic
    const playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};
    const waterRect = {x: water.x, y: water.y + 20, w: water.width, h: water.height};
    const inWaterZone = (player.x < waterRect.x + waterRect.w && player.x + player.w > waterRect.x &&
                         player.y + player.h > waterRect.y && player.y < waterRect.y + waterRect.h);

    if (inWaterZone !== player.inWater) {
        water.splash(player.x + player.w/2, player.vy * 3);
        particles.spawn(player.x + player.w/2, water.baseHeight, 15, 'water');
    }
    player.inWater = inWaterZone;

    if (player.inWater) {
        player.vy += 0.2; 
        if(player.y > water.y + 30) player.vy -= 0.8; 
        if(player.vy > 3) player.vy = 3;
        if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) player.vy = -3;
        player.vx *= 0.85; player.vy *= 0.85;
    } else {
        player.vy += gravity;
        if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.grounded) {
            player.vy = player.jump;
            player.grounded = false;
        }
    }

    player.x += player.vx;
    player.y += player.vy;

    // SAT Collision
    player.grounded = false;
    const playerPoly = createBoxPoly(player.x, player.y, player.w, player.h);

    for (let p of platforms) {
        const platformPoly = createBoxPoly(p.x, p.y, p.w, p.h);
        const mtv = checkSAT(playerPoly, platformPoly);
        if (mtv) {
            player.x += mtv.x; player.y += mtv.y;
            if (mtv.y < 0) { player.vy = 0; player.grounded = true; }
            else if (mtv.y > 0) player.vy = 0;
            else if (mtv.x !== 0) player.vx = 0;
        }
    }

    if (player.x < 0) player.x = 0;
    if (player.x > canvas.width) player.x = canvas.width;
    if (player.y > canvas.height) { player.y = 0; player.vy = 0; }

    water.update();
    particles.update();
}

function loop() {
    update();
    render();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>WebGL Water Platformer + SAT & Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #controls {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
        }
    </style>
</head>
<body>

<div id="controls">
    <strong>Controls:</strong><br>
    ARROWS / WASD: Move & Duck<br>
    SPACE: Jump / Swim<br>
    SHIFT or F: <strong>Slash Attack</strong>
</div>
<canvas id="glCanvas"></canvas>

<script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    attribute vec4 a_color;
    
    uniform vec2 u_resolution;
    
    varying vec4 v_color;
    
    void main() {
        // Convert pixels to 0.0->1.0
        vec2 zeroToOne = a_position / u_resolution;
        // Convert to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;
        // Convert to -1->+1 (clip space)
        vec2 clipSpace = zeroToTwo - 1.0;
        
        // Flip Y axis
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_color = a_color;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
</script>

<script>
/**
 * MATH HELPERS (Vector Operations)
 */
const Vec2 = {
    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),
    dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
    normalize: (v) => {
        const len = Math.sqrt(v.x * v.x + v.y * v.y);
        return len === 0 ? {x:0, y:0} : { x: v.x / len, y: v.y / len };
    },
    perp: (v) => ({ x: -v.y, y: v.x }), // Perpendicular (Normal)
    len: (v) => Math.sqrt(v.x*v.x + v.y*v.y)
};

/**
 * SAT PHYSICS ENGINE
 * Separating Axis Theorem for Polygon Collision
 */
function getAxes(vertices) {
    const axes = [];
    for (let i = 0; i < vertices.length; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % vertices.length];
        const edge = Vec2.sub(p2, p1);
        axes.push(Vec2.normalize(Vec2.perp(edge)));
    }
    return axes;
}

function project(vertices, axis) {
    let min = Vec2.dot(vertices[0], axis);
    let max = min;
    for (let i = 1; i < vertices.length; i++) {
        const p = Vec2.dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    return { min, max };
}

// Returns Minimum Translation Vector (MTV) or null if no collision
function checkSAT(polyA, polyB) {
    let overlap = Infinity;
    let smallestAxis = null;

    const axes = [...getAxes(polyA), ...getAxes(polyB)];

    for (let axis of axes) {
        const p1 = project(polyA, axis);
        const p2 = project(polyB, axis);

        if (p1.max < p2.min || p2.max < p1.min) {
            return null; // Gap found, no collision
        }

        const o = Math.min(p1.max, p2.max) - Math.max(p1.min, p2.min);
        if (o < overlap) {
            overlap = o;
            smallestAxis = axis;
        }
    }

    // Ensure MTV points from B to A
    const centerA = getCenter(polyA);
    const centerB = getCenter(polyB);
    const dir = Vec2.sub(centerA, centerB);
    
    if (Vec2.dot(dir, smallestAxis) < 0) {
        smallestAxis = { x: -smallestAxis.x, y: -smallestAxis.y };
    }

    return { x: smallestAxis.x * overlap, y: smallestAxis.y * overlap };
}

function getCenter(vertices) {
    let x = 0, y = 0;
    for (let v of vertices) { x += v.x; y += v.y; }
    return { x: x / vertices.length, y: y / vertices.length };
}

function createBoxPoly(x, y, w, h) {
    return [
        { x: x, y: y },         // Top Left
        { x: x + w, y: y },     // Top Right
        { x: x + w, y: y + h }, // Bot Right
        { x: x, y: y + h }      // Bot Left
    ];
}

/**
 * PARTICLE SYSTEM
 */
class ParticleSystem {
    constructor() {
        this.particles = [];
    }
    
    spawn(x, y, count, type) {
        for(let i=0; i<count; i++) {
            this.particles.push({
                x: x, 
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 1) * 6 - 2, // Upward burst
                life: 1.0,
                color: type === 'water' ? [0.6, 0.8, 1, 1] : [1, 1, 0.8, 1],
                size: Math.random() * 4 + 2
            });
        }
    }
    
    update() {
        for(let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2; // Gravity
            p.life -= 0.02;
            
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    }
}

/**
 * WATER PHYSICS
 */
class Water {
    constructor(x, y, width, height, segments) {
        this.x = x; this.y = y; this.width = width; this.height = height;
        this.baseHeight = y;
        this.springs = [];
        this.spacing = width / segments;
        this.k = 0.025; this.dampening = 0.025; this.spread = 0.25;

        for (let i = 0; i <= segments; i++) {
            this.springs.push({ p: 0, v: 0 });
        }
    }

    update() {
        // Hooke's Law
        for (let i = 0; i < this.springs.length; i++) {
            let s = this.springs[i];
            s.v += (-this.k * s.p - this.dampening * s.v);
            s.p += s.v;
        }

        // Propagation
        const leftDeltas = new Array(this.springs.length).fill(0);
        const rightDeltas = new Array(this.springs.length).fill(0);

        for (let j = 0; j < 4; j++) {
            for (let i = 0; i < this.springs.length; i++) {
                if (i > 0) {
                    leftDeltas[i] = this.spread * (this.springs[i].p - this.springs[i - 1].p);
                    this.springs[i - 1].v += leftDeltas[i];
                }
                if (i < this.springs.length - 1) {
                    rightDeltas[i] = this.spread * (this.springs[i].p - this.springs[i + 1].p);
                    this.springs[i + 1].v += rightDeltas[i];
                }
            }
            for (let i = 0; i < this.springs.length; i++) {
                if (i > 0) this.springs[i - 1].p += leftDeltas[i];
                if (i < this.springs.length - 1) this.springs[i + 1].p += rightDeltas[i];
            }
        }
    }

    splash(xPos, speed) {
        let index = Math.floor((xPos - this.x) / this.spacing);
        if (index >= 0 && index < this.springs.length) {
            this.springs[index].v = speed;
        }
    }
}

/**
 * GAME ENGINE SETUP
 */
const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl");

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader); return null;
    }
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById("vertex-shader").text));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fragment-shader").text));
gl.linkProgram(program);
gl.useProgram(program);

const positionLoc = gl.getAttribLocation(program, "a_position");
const colorLoc = gl.getAttribLocation(program, "a_color");
const resolutionLoc = gl.getUniformLocation(program, "u_resolution");

const positionBuffer = gl.createBuffer();
const colorBuffer = gl.createBuffer();

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

// --- Game State ---
const gravity = 0.5;
const water = new Water(100, 450, 700, 300, 100);
const particles = new ParticleSystem();

const platforms = [
    {x: 50, y: 350, w: 150, h: 30},
    {x: 750, y: 300, w: 150, h: 30},
    {x: 350, y: 200, w: 200, h: 30},
    {x: 0, y: 550, w: 200, h: 50}, // Left edge
    {x: 700, y: 550, w: 300, h: 50} // Right edge
];

const player = {
    x: 100, y: 100, w: 30, h: 50,
    vx: 0, vy: 0,
    speed: 5, jump: -12,
    grounded: false, inWater: false, ducking: false,
    facingRight: true,
    attackTime: 0,
    color: [1, 0.2, 0.2, 1]
};

const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

// --- Drawing Helpers ---
let positions = [];
let colors = [];

function drawRect(x, y, w, h, col) {
    positions.push(x, y, x + w, y, x, y + h, x, y + h, x + w, y, x + w, y + h);
    for(let i=0; i<6; i++) colors.push(...col);
}

function render() {
    positions = []; colors = [];

    // Draw Platforms
    for (let p of platforms) drawRect(p.x, p.y, p.w, p.h, [0.4, 0.4, 0.4, 1]);

    // Draw Player
    drawRect(player.x, player.y, player.w, player.h, player.color);

    // Draw Slash
    if (player.attackTime > 0) {
        let slashX = player.facingRight ? player.x + player.w : player.x - 50;
        let slashColor = [1, 1, 0.2, player.attackTime / 10]; // Fade out
        drawRect(slashX, player.y + 10, 50, 30, slashColor);
    }

    // Draw Particles
    for (let p of particles.particles) {
        drawRect(p.x, p.y, p.size, p.size, p.color);
    }

    // Draw Water
    for (let i = 0; i < water.springs.length - 1; i++) {
        let x1 = water.x + i * water.spacing;
        let y1 = water.baseHeight + water.springs[i].p;
        let x2 = water.x + (i + 1) * water.spacing;
        let y2 = water.baseHeight + water.springs[i + 1].p;
        let yB = water.baseHeight + water.height;

        positions.push(x1, y1, x2, y2, x1, yB, x1, yB, x2, y2, x2, yB);
        const tc = [0.2, 0.6, 0.9, 0.8], bc = [0.1, 0.3, 0.6, 0.9];
        colors.push(...tc, ...tc, ...bc, ...bc, ...tc, ...bc);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(colorLoc);
    gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);
}

// --- Main Logic ---
function update() {
    // 1. Input
    player.vx = 0;
    if (keys['ArrowLeft'] || keys['KeyA']) { player.vx = -player.speed; player.facingRight = false; }
    if (keys['ArrowRight'] || keys['KeyD']) { player.vx = player.speed; player.facingRight = true; }

    // Ducking
    if ((keys['ArrowDown'] || keys['KeyS']) && !player.inWater) {
        if(!player.ducking) { player.h = 25; player.y += 25; player.ducking = true; }
    } else if (player.ducking) {
        player.h = 50; player.y -= 25; player.ducking = false;
    }

    // Slashing
    if (player.attackTime > 0) player.attackTime--;
    if ((keys['ShiftLeft'] || keys['KeyF']) && player.attackTime === 0) {
        player.attackTime = 15;
        // Effect
        particles.spawn(player.facingRight ? player.x + player.w : player.x, player.y + 20, 5, 'spark');
    }

    // 2. Physics Integration
    // Water Logic (AABB is fine for water trigger area)
    const playerRect = {x: player.x, y: player.y, w: player.w, h: player.h};
    const waterRect = {x: water.x, y: water.y + 20, w: water.width, h: water.height};
    
    // Check strict AABB for water
    const inWaterZone = (player.x < waterRect.x + waterRect.w && player.x + player.w > waterRect.x &&
                         player.y + player.h > waterRect.y && player.y < waterRect.y + waterRect.h);

    if (inWaterZone !== player.inWater) {
        // Splash trigger
        water.splash(player.x + player.w/2, player.vy * 3);
        particles.spawn(player.x + player.w/2, water.baseHeight, 15, 'water');
    }
    player.inWater = inWaterZone;

    if (player.inWater) {
        // Swimming
        player.vy += 0.2; 
        if(player.y > water.y + 30) player.vy -= 0.8; // Buoyancy
        if(player.vy > 3) player.vy = 3;

        if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) player.vy = -3;
        player.vx *= 0.85; player.vy *= 0.85;
    } else {
        // Air
        player.vy += gravity;
        if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.grounded) {
            player.vy = player.jump;
            player.grounded = false;
        }
    }

    player.x += player.vx;
    player.y += player.vy;

    // 3. SAT Collision Resolution (Solid Platforms)
    player.grounded = false;
    const playerPoly = createBoxPoly(player.x, player.y, player.w, player.h);

    for (let p of platforms) {
        const platformPoly = createBoxPoly(p.x, p.y, p.w, p.h);
        const mtv = checkSAT(playerPoly, platformPoly);

        if (mtv) {
            // Apply MTV (Minimum Translation Vector) to push player out
            player.x += mtv.x;
            player.y += mtv.y;

            // Resolve Velocity based on collision normal
            if (mtv.y < 0) { // Hit floor
                player.vy = 0;
                player.grounded = true;
            } else if (mtv.y > 0) { // Hit ceiling
                player.vy = 0;
            } else if (mtv.x !== 0) { // Hit wall
                player.vx = 0;
            }
        }
    }

    // Screen Bounds
    if (player.x < 0) player.x = 0;
    if (player.x > canvas.width) player.x = canvas.width;
    if (player.y > canvas.height) { player.y = 0; player.vy = 0; }

    water.update();
    particles.update();
}

function loop() {
    update();
    render();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

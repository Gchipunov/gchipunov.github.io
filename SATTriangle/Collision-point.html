<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Triangle Collision (SAT)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling on mobile */
            background-color: #1a202c; /* Dark background */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(45, 55, 72, 0.8);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            max-width: 320px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            pointer-events: none; /* Make sure it doesn't block canvas events */
        }
        #collision-status {
            font-weight: bold;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white">

    <div id="info-panel">
        <h1 class="text-lg font-bold mb-2">Triangle Collision</h1>
        <p class="mb-1"><b>Move:</b> Drag with one finger/mouse.</p>
        <p class="mb-1"><b>Rotate:</b> Twist with two fingers or use the mouse wheel.</p>
        <p class="mb-1 text-yellow-300">White dots show triangle origins.</p>
        <p class="mb-1 text-red-400">Red line shows collision normal (MTV).</p>
        <p>Status: <span id="collision-status" class="text-green-400">No Collision</span></p>
    </div>

    <canvas id="glCanvas"></canvas>

    <script>
        // --- Global Variables ---
        let gl;
        let shaderProgram;
        let triangle1Buffer, triangle2Buffer, pointBuffer, lineBuffer;
        let collisionResult = { colliding: false };
        
        // Triangle 1 (static, green) vertices
        const triangle1Vertices = [ -0.5, -0.25,  0.0, -0.75, -0.2,  0.2 ];

        // Triangle 2 (movable, blue) vertices (initial position)
        const triangle2BaseVertices = [ 0.5,  0.25, 0.0,  0.75, 0.2, -0.2 ];
        
        // State for movable triangle
        let triangle2State = { x: 0.0, y: 0.0, rotation: 0.0 };
        
        // Controls state
        let isDragging = false, isPinching = false;
        let lastTouch = { x: 0, y: 0 }, initialPinchAngle = 0;

        // Colors
        const collisionColor = [1.0, 1.0, 0.0, 1.0];
        const triangle1BaseColor = [0.1, 0.8, 0.3, 1.0];
        const triangle2BaseColor = [0.2, 0.5, 1.0, 1.0];
        const debugPointColor = [1.0, 1.0, 1.0, 1.0];
        const mtvLineColor = [1.0, 0.2, 0.2, 1.0];

        // --- Main execution ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');
            if (!gl) { alert('Unable to initialize WebGL.'); return; }
            
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            const vsSource = `
                attribute vec2 aVertexPosition;
                uniform vec2 u_translation;
                uniform float u_rotation;
                uniform float u_pointSize;
                void main(void) {
                    float s = sin(u_rotation);
                    float c = cos(u_rotation);
                    mat2 rotationMatrix = mat2(c, -s, s, c);
                    vec2 rotatedPosition = rotationMatrix * aVertexPosition;
                    gl_Position = vec4(rotatedPosition + u_translation, 0.0, 1.0);
                    gl_PointSize = u_pointSize;
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 u_color;
                void main(void) { gl_FragColor = u_color; }
            `;

            shaderProgram = initShaderProgram(vsSource, fsSource);
            gl.useProgram(shaderProgram);

            initBuffers();
            setupEventListeners(canvas);
            requestAnimationFrame(render);
        }

        // --- WebGL Initialization ---
        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program error: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            triangle1Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangle1Buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle1Vertices), gl.STATIC_DRAW);

            triangle2Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangle2Buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle2BaseVertices), gl.STATIC_DRAW);
            
            pointBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0]), gl.STATIC_DRAW);

            lineBuffer = gl.createBuffer(); // Will be updated dynamically
        }

        // --- Rendering Loop ---
        function render() {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0.1, 0.1, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            const triangle2CurrentVertices = getTransformedVertices(triangle2BaseVertices, triangle2State);
            collisionResult = checkCollision(triangle1Vertices, triangle2CurrentVertices);
            
            const statusElement = document.getElementById('collision-status');
            const isColliding = collisionResult.colliding;
            statusElement.textContent = isColliding ? 'Collision!' : 'No Collision';
            statusElement.className = isColliding ? 'text-red-400 font-bold' : 'text-green-400 font-bold';

            // Draw main shapes
            drawShape(triangle1Buffer, 3, gl.TRIANGLES, {x:0, y:0, rotation:0}, isColliding ? collisionColor : triangle1BaseColor);
            drawShape(triangle2Buffer, 3, gl.TRIANGLES, triangle2State, isColliding ? collisionColor : triangle2BaseColor);

            // Draw debug info
            drawShape(pointBuffer, 1, gl.POINTS, {x:0, y:0, rotation:0}, debugPointColor, 8.0);
            drawShape(pointBuffer, 1, gl.POINTS, triangle2State, debugPointColor, 8.0);
            if (isColliding) {
                drawDebugLine(collisionResult.mtv);
            }

            requestAnimationFrame(render);
        }
        
        // --- Drawing Functions ---
        function drawShape(buffer, vertexCount, mode, state, color, pointSize = 1.0) {
            const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            const translationLoc = gl.getUniformLocation(shaderProgram, 'u_translation');
            const rotationLoc = gl.getUniformLocation(shaderProgram, 'u_rotation');
            const colorLoc = gl.getUniformLocation(shaderProgram, 'u_color');
            const pointSizeLoc = gl.getUniformLocation(shaderProgram, 'u_pointSize');

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexPosition);

            gl.uniform2f(translationLoc, state.x, state.y);
            gl.uniform1f(rotationLoc, state.rotation);
            gl.uniform4fv(colorLoc, color);
            gl.uniform1f(pointSizeLoc, pointSize);

            gl.drawArrays(mode, 0, vertexCount);
        }

        function drawDebugLine(mtv) {
            // The MTV shows the vector to resolve collision. We draw it from triangle 2's center.
            const startX = triangle2State.x;
            const startY = triangle2State.y;
            // The MTV vector is axis * overlap.
            const endX = startX + mtv.axis.x * mtv.overlap;
            const endY = startY + mtv.axis.y * mtv.overlap;

            const lineVertices = new Float32Array([startX, startY, endX, endY]);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, lineVertices, gl.DYNAMIC_DRAW);
            
            // Draw the line with rotation 0 and translation 0, as vertices are already in world space.
            drawShape(lineBuffer, 2, gl.LINES, {x:0, y:0, rotation:0}, mtvLineColor);
        }

        // --- Collision Detection (Separating Axis Theorem) ---
        function checkCollision(verts1, verts2) {
            const axes = getAxes(verts1).concat(getAxes(verts2));
            let minOverlap = Infinity;
            let mtvAxis = null;

            for (let i = 0; i < axes.length; i++) {
                const axis = axes[i];
                const p1 = project(verts1, axis);
                const p2 = project(verts2, axis);

                if (p1.max < p2.min || p2.max < p1.min) {
                    return { colliding: false }; // Found a separating axis
                } else {
                    // Calculate overlap
                    const overlap = Math.min(p1.max, p2.max) - Math.max(p1.min, p2.min);
                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        mtvAxis = axis;
                    }
                }
            }
            
            // Ensure MTV axis points from shape 2 to shape 1
            const center1 = getCenter(verts1);
            const center2 = getCenter(verts2);
            let direction = { x: center1.x - center2.x, y: center1.y - center2.y };
            if (dotProduct(direction, mtvAxis) < 0) {
                mtvAxis.x *= -1;
                mtvAxis.y *= -1;
            }

            return { colliding: true, mtv: { axis: mtvAxis, overlap: minOverlap } };
        }

        function getAxes(vertices) {
            const axes = [];
            for (let i = 0; i < vertices.length; i += 2) {
                const p1 = { x: vertices[i], y: vertices[i + 1] };
                const p2 = { x: vertices[(i + 2) % vertices.length], y: vertices[(i + 3) % vertices.length] };
                const edge = { x: p1.x - p2.x, y: p1.y - p2.y };
                const normal = { x: -edge.y, y: edge.x };
                axes.push(normalize(normal));
            }
            return axes;
        }

        function project(vertices, axis) {
            let min = dotProduct({x: vertices[0], y: vertices[1]}, axis);
            let max = min;
            for (let i = 2; i < vertices.length; i += 2) {
                const p = dotProduct({x: vertices[i], y: vertices[i+1]}, axis);
                if (p < min) min = p;
                else if (p > max) max = p;
            }
            return { min, max };
        }
        
        // --- Touch & Mouse Controls ---
        function setupEventListeners(canvas) {
            canvas.addEventListener('mousedown', (e) => handleDragStart(e.clientX, e.clientY));
            canvas.addEventListener('mousemove', (e) => handleDragMove(e.clientX, e.clientY, e.buttons === 1));
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('mouseleave', handleDragEnd);
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);
        }

        function handleDragStart(x, y) { isDragging = true; lastTouch = { x, y }; }
        function handleDragMove(x, y, isDown) {
            if (!isDragging || !isDown) return;
            const dx = x - lastTouch.x;
            const dy = y - lastTouch.y;
            triangle2State.x += (dx / gl.canvas.width) * 2;
            triangle2State.y -= (dy / gl.canvas.height) * 2;
            lastTouch = { x, y };
        }
        function handleDragEnd() { isDragging = false; }
        function handleWheel(e) { e.preventDefault(); triangle2State.rotation += e.deltaY * -0.005; }
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                isPinching = false;
                handleDragStart(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2) {
                isDragging = false; isPinching = true;
                initialPinchAngle = getPinchAngle(e.touches);
            }
        }
        function handleTouchMove(e) {
            e.preventDefault();
            if (isPinching && e.touches.length === 2) {
                const currentAngle = getPinchAngle(e.touches);
                triangle2State.rotation += currentAngle - initialPinchAngle;
                initialPinchAngle = currentAngle;
            } else if (isDragging && e.touches.length === 1) {
                handleDragMove(e.touches[0].clientX, e.touches[0].clientY, true);
            }
        }
        function handleTouchEnd(e) {
            if (e.touches.length < 2) isPinching = false;
            if (e.touches.length < 1) isDragging = false;
        }
        function getPinchAngle(touches) { return Math.atan2(touches[1].clientY - touches[0].clientY, touches[1].clientX - touches[0].clientX); }

        // --- Utility & Math Functions ---
        function getTransformedVertices(baseVertices, state) {
            const transformed = [];
            const s = Math.sin(state.rotation);
            const c = Math.cos(state.rotation);
            for (let i = 0; i < baseVertices.length; i += 2) {
                const x = baseVertices[i], y = baseVertices[i + 1];
                const rotatedX = x * c - y * s;
                const rotatedY = x * s + y * c;
                transformed.push(rotatedX + state.x, rotatedY + state.y);
            }
            return transformed;
        }
        function getCenter(vertices) {
            let cx = 0, cy = 0;
            for (let i = 0; i < vertices.length; i += 2) {
                cx += vertices[i];
                cy += vertices[i + 1];
            }
            const count = vertices.length / 2;
            return { x: cx / count, y: cy / count };
        }
        function dotProduct(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
        function normalize(v) {
            const len = Math.sqrt(v.x * v.x + v.y * v.y);
            if (len > 0) return { x: v.x / len, y: v.y / len };
            return { x: 0, y: 0 };
        }
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }
    </script>
</body>
</html>

Code in webgl showing triangle to triangle collision using seperate axis Theorem make mobile touch controls for one of the triangles so they light up on collision
Of course. I'll create a WebGL application that demonstrates the Separating Axis Theorem for triangle-to-triangle collision.

Here is a complete, self-contained HTML file. It includes the WebGL setup, the collision detection logic, and touch controls that allow you to drag one of the triangles on your phone or with your mouse. When the two triangles intersect, they will both light up in yellow.
WebGL Triangle Collision with Debug Visuals
Aug 21 at 9:11 PM

This code sets up a full-screen WebGL canvas and draws two triangles. The core logic for collision detection is in the checkCollision, getAxes, and project functions, which together implement the Separating Axis Theorem.

The touch and mouse event listeners update the position of the blue triangle, and the render loop continuously checks for a collision on every frame, updating the colors and the status text accordingly.

Works good , can you add rotating the triangle , code : <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Triangle Collision (SAT)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling on mobile */
            background-color: #1a202c; /* Dark background */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(45, 55, 72, 0.8);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
        }
        #collision-status {
            font-weight: bold;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white">

    <div id="info-panel">
        <h1 class="text-lg font-bold mb-2">Triangle Collision</h1>
        <p class="mb-1">Drag the blue triangle with your finger or mouse.</p>
        <p>Collision Status: <span id="collision-status" class="text-green-400">No Collision</span></p>
    </div>

    <canvas id="glCanvas"></canvas>

    <script>
        // --- Global Variables ---
        let gl;
        let shaderProgram;
        let triangle1Buffer, triangle2Buffer;
        
        // Triangle 1 (static, green) vertices
        const triangle1Vertices = [
            -0.5, -0.25,
             0.0, -0.75,
            -0.2,  0.2
        ];

        // Triangle 2 (movable, blue) vertices (initial position)
        const triangle2BaseVertices = [
             0.5,  0.25,
             0.0,  0.75,
             0.2, -0.2
        ];
        
        // State for movable triangle
        let triangle2Position = { x: 0.0, y: 0.0 };
        let isDragging = false;
        let lastTouch = { x: 0, y: 0 };

        // Colors
        const noCollisionColor = [0.8, 0.8, 0.8, 1.0]; // Off-white
        const collisionColor = [1.0, 1.0, 0.0, 1.0];   // Yellow
        const triangle1BaseColor = [0.1, 0.8, 0.3, 1.0]; // Green
        const triangle2BaseColor = [0.2, 0.5, 1.0, 1.0]; // Blue

        // --- Main execution ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }
            
            // Resize canvas to fill browser window dynamically
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // Vertex and fragment shaders
            const vsSource = `
                attribute vec2 aVertexPosition;
                uniform vec2 u_translation;
                void main(void) {
                    gl_Position = vec4(aVertexPosition + u_translation, 0.0, 1.0);
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 u_color;
                void main(void) {
                    gl_FragColor = u_color;
                }
            `;

            shaderProgram = initShaderProgram(vsSource, fsSource);
            gl.useProgram(shaderProgram);

            initBuffers();
            setupEventListeners(canvas);

            requestAnimationFrame(render);
        }

        // --- WebGL Initialization ---

        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            triangle1Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangle1Buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle1Vertices), gl.STATIC_DRAW);

            triangle2Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangle2Buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle2BaseVertices), gl.STATIC_DRAW);
        }

        // --- Rendering Loop ---

        function render() {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0.1, 0.1, 0.2, 1.0); // Dark blue background
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Get current vertices for the movable triangle
            const triangle2CurrentVertices = getTransformedVertices(triangle2BaseVertices, triangle2Position);

            // Perform collision detection
            const collision = checkCollision(triangle1Vertices, triangle2CurrentVertices);
            
            // Update UI
            const statusElement = document.getElementById('collision-status');
            if (collision) {
                statusElement.textContent = 'Collision!';
                statusElement.classList.remove('text-green-400');
                statusElement.classList.add('text-red-400');
            } else {
                statusElement.textContent = 'No Collision';
                statusElement.classList.remove('text-red-400');
                statusElement.classList.add('text-green-400');
            }

            // Draw triangles
            drawTriangle(triangle1Buffer, {x: 0, y: 0}, collision ? collisionColor : triangle1BaseColor);
            drawTriangle(triangle2Buffer, triangle2Position, collision ? collisionColor : triangle2BaseColor);

            requestAnimationFrame(render);
        }

        function drawTriangle(buffer, translation, color) {
            const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            const translationLocation = gl.getUniformLocation(shaderProgram, 'u_translation');
            const colorLocation = gl.getUniformLocation(shaderProgram, 'u_color');

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexPosition);

            gl.uniform2f(translationLocation, translation.x, translation.y);
            gl.uniform4fv(colorLocation, color);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        // --- Collision Detection (Separating Axis Theorem) ---

        function checkCollision(verts1, verts2) {
            const axes = getAxes(verts1).concat(getAxes(verts2));

            for (let i = 0; i < axes.length; i++) {
                const axis = axes[i];
                const p1 = project(verts1, axis);
                const p2 = project(verts2, axis);

                // If there is no overlap on this axis, they are not colliding
                if (p1.max < p2.min || p2.max < p1.min) {
                    return false;
                }
            }
            // If we found an overlap on all axes, they are colliding
            return true;
        }

        /**
         * Calculates the axes to test, which are perpendicular to the triangle's edges.
         * @param {number[]} vertices - Flat array of vertices [x1, y1, x2, y2, ...]
         * @returns {object[]} Array of axis vectors [{x, y}, ...]
         */
        function getAxes(vertices) {
            const axes = [];
            for (let i = 0; i < vertices.length; i += 2) {
                const p1 = { x: vertices[i], y: vertices[i + 1] };
                const p2 = { x: vertices[(i + 2) % vertices.length], y: vertices[(i + 3) % vertices.length] };
                
                const edge = { x: p1.x - p2.x, y: p1.y - p2.y };
                
                // Get a perpendicular vector (the axis)
                const normal = { x: -edge.y, y: edge.x };
                axes.push(normalize(normal));
            }
            return axes;
        }

        /**
         * Projects a polygon's vertices onto a given axis.
         * @param {number[]} vertices - Flat array of vertices
         * @param {object} axis - The axis vector {x, y}
         * @returns {object} An object with min and max projection values {min, max}
         */
        function project(vertices, axis) {
            let min = dotProduct({x: vertices[0], y: vertices[1]}, axis);
            let max = min;

            for (let i = 2; i < vertices.length; i += 2) {
                const p = dotProduct({x: vertices[i], y: vertices[i+1]}, axis);
                if (p < min) {
                    min = p;
                } else if (p > max) {
                    max = p;
                }
            }
            return { min: min, max: max };
        }
        
        // --- Touch & Mouse Controls ---
        
        function setupEventListeners(canvas) {
            // Mouse events
            canvas.addEventListener('mousedown', (e) => handleDragStart(e.clientX, e.clientY));
            canvas.addEventListener('mousemove', (e) => handleDragMove(e.clientX, e.clientY, e.buttons === 1));
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('mouseleave', handleDragEnd);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Important to prevent page scrolling
                const touch = e.touches[0];
                handleDragStart(touch.clientX, touch.clientY);
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                handleDragMove(touch.clientX, touch.clientY, true);
            }, { passive: false });

            canvas.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('touchcancel', handleDragEnd);
        }

        function handleDragStart(x, y) {
            isDragging = true;
            lastTouch = { x, y };
        }

        function handleDragMove(x, y, isDown) {
            if (!isDragging || !isDown) return;

            const dx = x - lastTouch.x;
            const dy = y - lastTouch.y;

            // Convert pixel movement to WebGL clip space movement
            // Clip space ranges from -1 to 1.
            const clipX = (dx / gl.canvas.width) * 2;
            const clipY = -(dy / gl.canvas.height) * 2; // Y is inverted

            triangle2Position.x += clipX;
            triangle2Position.y += clipY;

            lastTouch = { x, y };
        }

        function handleDragEnd() {
            isDragging = false;
        }

        // --- Utility & Math Functions ---

        function getTransformedVertices(baseVertices, translation) {
            const transformed = [];
            for (let i = 0; i < baseVertices.length; i += 2) {
                transformed.push(baseVertices[i] + translation.x);
                transformed.push(baseVertices[i + 1] + translation.y);
            }
            return transformed;
        }
        
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }
        
        function normalize(v) {
            const len = Math.sqrt(v.x * v.x + v.y * v.y);
            if (len > 0) {
                return { x: v.x / len, y: v.y / len };
            }
            return { x: 0, y: 0 };
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

    </script>
</body>
</html>
Of course. I've updated the code to include rotation for the movable triangle.

To handle this, I've made changes to the vertex shader to apply rotation, updated the JavaScript logic to calculate the rotated vertex positions for collision detection, and added new controls.

New Controls:

Touch: Use a two-finger twisting gesture to rotate the blue triangle. One-finger drag still moves it.

Mouse: Use your mouse's scroll wheel to rotate the blue triangle.

Here is the updated code:

please help fix the webgl code, after rotating the rotated triangle is still using old collision model so in OpenGL the highlight is not working right and if possible for you add the collision point and init point on screen, im trying to learn to make my own physics game system, code: <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Triangle Collision (SAT)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrolling on mobile */
            background-color: #1a202c; /* Dark background */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(45, 55, 72, 0.8);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            pointer-events: none; /* Make sure it doesn't block canvas events */
        }
        #collision-status {
            font-weight: bold;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white">

    <div id="info-panel">
        <h1 class="text-lg font-bold mb-2">Triangle Collision</h1>
        <p class="mb-1"><b>Move:</b> Drag with one finger/mouse.</p>
        <p class="mb-1"><b>Rotate:</b> Twist with two fingers or use the mouse wheel.</p>
        <p>Collision Status: <span id="collision-status" class="text-green-400">No Collision</span></p>
    </div>

    <canvas id="glCanvas"></canvas>

    <script>
        // --- Global Variables ---
        let gl;
        let shaderProgram;
        let triangle1Buffer, triangle2Buffer;
        
        // Triangle 1 (static, green) vertices
        const triangle1Vertices = [
            -0.5, -0.25,
             0.0, -0.75,
            -0.2,  0.2
        ];

        // Triangle 2 (movable, blue) vertices (initial position)
        const triangle2BaseVertices = [
             0.5,  0.25,
             0.0,  0.75,
             0.2, -0.2
        ];
        
        // State for movable triangle
        let triangle2Position = { x: 0.0, y: 0.0 };
        let triangle2Rotation = 0.0; // In radians
        let isDragging = false;
        let isPinching = false;
        let lastTouch = { x: 0, y: 0 };
        let initialPinchAngle = 0;


        // Colors
        const collisionColor = [1.0, 1.0, 0.0, 1.0];   // Yellow
        const triangle1BaseColor = [0.1, 0.8, 0.3, 1.0]; // Green
        const triangle2BaseColor = [0.2, 0.5, 1.0, 1.0]; // Blue

        // --- Main execution ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl');

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser may not support it.');
                return;
            }
            
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // Updated Vertex Shader to include rotation
            const vsSource = `
                attribute vec2 aVertexPosition;
                uniform vec2 u_translation;
                uniform float u_rotation;

                void main(void) {
                    float s = sin(u_rotation);
                    float c = cos(u_rotation);
                    mat2 rotationMatrix = mat2(c, -s, s, c);
                    vec2 rotatedPosition = rotationMatrix * aVertexPosition;
                    gl_Position = vec4(rotatedPosition + u_translation, 0.0, 1.0);
                }
            `;
            const fsSource = `
                precision mediump float;
                uniform vec4 u_color;
                void main(void) {
                    gl_FragColor = u_color;
                }
            `;

            shaderProgram = initShaderProgram(vsSource, fsSource);
            gl.useProgram(shaderProgram);

            initBuffers();
            setupEventListeners(canvas);

            requestAnimationFrame(render);
        }

        // --- WebGL Initialization ---

        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            triangle1Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangle1Buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle1Vertices), gl.STATIC_DRAW);

            triangle2Buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, triangle2Buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangle2BaseVertices), gl.STATIC_DRAW);
        }

        // --- Rendering Loop ---

        function render() {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.clearColor(0.1, 0.1, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Get current vertices for the movable triangle, now with rotation
            const triangle2CurrentVertices = getTransformedVertices(triangle2BaseVertices, triangle2Position, triangle2Rotation);

            // Perform collision detection
            const collision = checkCollision(triangle1Vertices, triangle2CurrentVertices);
            
            // Update UI
            const statusElement = document.getElementById('collision-status');
            if (collision) {
                statusElement.textContent = 'Collision!';
                statusElement.classList.remove('text-green-400');
                statusElement.classList.add('text-red-400');
            } else {
                statusElement.textContent = 'No Collision';
                statusElement.classList.remove('text-red-400');
                statusElement.classList.add('text-green-400');
            }

            // Draw triangles, passing rotation angle
            drawTriangle(triangle1Buffer, {x: 0, y: 0}, 0.0, collision ? collisionColor : triangle1BaseColor);
            drawTriangle(triangle2Buffer, triangle2Position, triangle2Rotation, collision ? collisionColor : triangle2BaseColor);

            requestAnimationFrame(render);
        }

        function drawTriangle(buffer, translation, rotation, color) {
            const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
            const translationLocation = gl.getUniformLocation(shaderProgram, 'u_translation');
            const rotationLocation = gl.getUniformLocation(shaderProgram, 'u_rotation');
            const colorLocation = gl.getUniformLocation(shaderProgram, 'u_color');

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexPosition);

            gl.uniform2f(translationLocation, translation.x, translation.y);
            gl.uniform1f(rotationLocation, rotation);
            gl.uniform4fv(colorLocation, color);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
        }

        // --- Collision Detection (Separating Axis Theorem) ---

        function checkCollision(verts1, verts2) {
            const axes = getAxes(verts1).concat(getAxes(verts2));
            for (let i = 0; i < axes.length; i++) {
                const axis = axes[i];
                const p1 = project(verts1, axis);
                const p2 = project(verts2, axis);
                if (p1.max < p2.min || p2.max < p1.min) {
                    return false;
                }
            }
            return true;
        }

        function getAxes(vertices) {
            const axes = [];
            for (let i = 0; i < vertices.length; i += 2) {
                const p1 = { x: vertices[i], y: vertices[i + 1] };
                const p2 = { x: vertices[(i + 2) % vertices.length], y: vertices[(i + 3) % vertices.length] };
                const edge = { x: p1.x - p2.x, y: p1.y - p2.y };
                const normal = { x: -edge.y, y: edge.x };
                axes.push(normalize(normal));
            }
            return axes;
        }

        function project(vertices, axis) {
            let min = dotProduct({x: vertices[0], y: vertices[1]}, axis);
            let max = min;
            for (let i = 2; i < vertices.length; i += 2) {
                const p = dotProduct({x: vertices[i], y: vertices[i+1]}, axis);
                if (p < min) min = p;
                else if (p > max) max = p;
            }
            return { min, max };
        }
        
        // --- Touch & Mouse Controls ---
        
        function setupEventListeners(canvas) {
            // Mouse
            canvas.addEventListener('mousedown', (e) => handleDragStart(e.clientX, e.clientY));
            canvas.addEventListener('mousemove', (e) => handleDragMove(e.clientX, e.clientY, e.buttons === 1));
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('mouseleave', handleDragEnd);
            canvas.addEventListener('wheel', handleWheel, { passive: false });

            // Touch
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);
        }

        function handleDragStart(x, y) {
            isDragging = true;
            lastTouch = { x, y };
        }

        function handleDragMove(x, y, isDown) {
            if (!isDragging || !isDown) return;
            const dx = x - lastTouch.x;
            const dy = y - lastTouch.y;
            triangle2Position.x += (dx / gl.canvas.width) * 2;
            triangle2Position.y -= (dy / gl.canvas.height) * 2;
            lastTouch = { x, y };
        }

        function handleDragEnd() {
            isDragging = false;
        }
        
        function handleWheel(e) {
            e.preventDefault();
            triangle2Rotation += e.deltaY * -0.005;
        }

        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                isPinching = false;
                const touch = e.touches[0];
                handleDragStart(touch.clientX, touch.clientY);
            } else if (e.touches.length === 2) {
                isDragging = false;
                isPinching = true;
                initialPinchAngle = getPinchAngle(e.touches);
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (isPinching && e.touches.length === 2) {
                const currentAngle = getPinchAngle(e.touches);
                const angleDiff = currentAngle - initialPinchAngle;
                triangle2Rotation += angleDiff;
                initialPinchAngle = currentAngle; // Update for continuous rotation
            } else if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                handleDragMove(touch.clientX, touch.clientY, true);
            }
        }

        function handleTouchEnd(e) {
            if (e.touches.length < 2) isPinching = false;
            if (e.touches.length < 1) isDragging = false;
        }

        function getPinchAngle(touches) {
            const t1 = touches[0];
            const t2 = touches[1];
            return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        }

        // --- Utility & Math Functions ---

        function getTransformedVertices(baseVertices, translation, rotation) {
            const transformed = [];
            const s = Math.sin(rotation);
            const c = Math.cos(rotation);
            for (let i = 0; i < baseVertices.length; i += 2) {
                const x = baseVertices[i];
                const y = baseVertices[i + 1];
                // Apply rotation first
                const rotatedX = x * c - y * s;
                const rotatedY = x * s + y * c;
                // Then apply translation
                transformed.push(rotatedX + translation.x);
                transformed.push(rotatedY + translation.y);
            }
            return transformed;
        }
        
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }
        
        function normalize(v) {
            const len = Math.sqrt(v.x * v.x + v.y * v.y);
            if (len > 0) return { x: v.x / len, y: v.y / len };
            return { x: 0, y: 0 };
        }

        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

    </script>
</body>
</html>
Of course! It's a great idea to visualize the collision details when building a physics system. You've run into a very common point of confusion. The collision code was actually working correctly, but the Separating Axis Theorem (SAT) is very precise. A collision is flagged even if the triangles overlap by the tiniest amount, which can be hard to see.

I've updated the code to help you visualize what's happening. Here are the key improvements:

Collision Vector (MTV): When a collision occurs, I now draw a red line. This line represents the "Minimum Translation Vector" (MTV). In a physics engine, this is the shortest path and direction you would move one of the triangles to resolve the collision. It's the most important piece of information SAT can give you.

Object Origins: I've added a small white dot at the center (origin) of each triangle so you can better see their positions and how they relate to each other.

Code Cleanup: The collision detection logic has been enhanced to calculate the MTV, and I've added new functions to handle drawing the debug visuals (the dots and the line).

This should make it much clearer why a collision is being detected.

It seems something is wrong ether aspect ratio or still rotation not synced with the cameras , when I rotate it shows wrong points and wrong collision by highlight, and I’m wondering how to do this in 3D with spheres and OBb and rotated aabb and maybe more odd shapes like capsules and adding physics
You've made an excellent observation! You're absolutely right. The problem isn't with the rotation logic itself, but with the aspect ratio of the canvas. It's a classic WebGL issue.

Here's the breakdown:

The Problem: WebGL's coordinate system (clip space) is a perfect square (-1 to 1 on both axes). Your screen, however, is a rectangle. When we draw directly to the rectangular canvas without correcting for this, the coordinate system gets stretched. This means a movement of 0.1 units horizontally doesn't look the same as a movement of 0.1 units vertically. The collision math is happening in the "correct" square space, but you're seeing it in the stretched, rectangular space, which is why it looks out of sync.

The Fix: We need to "normalize" the coordinate space. The solution is to calculate the canvas's aspect ratio (width / height) and use it to scale the coordinates in the vertex shader. This will effectively "squish" the wider axis to match the shorter one, making our mathematical space match the visual space.

I've fixed this in the code below. I've also kept the debug visuals (the origin points and the red collision vector) as they are crucial for building a physics system.

Moving to 3D and Physics

That's a fantastic goal! Moving from 2D SAT to a 3D physics system is a big and rewarding step. Here’s a conceptual roadmap of how these ideas expand into 3D.

3D Collision Shapes

The core idea is the same: for any two shapes, can you find a "separating axis" (which becomes a "separating plane" in 3D)? The complexity just changes based on the shape.

Sphere vs. Sphere: This is the easiest and fastest check.

How it works: Calculate the distance between the centers of the two spheres. If that distance is less than the sum of their radii, they are colliding.

Advantage: It's just one distance calculation. It's incredibly fast and doesn't care about rotation at all.

AABB vs. AABB (Axis-Aligned Bounding Box): These are boxes that are never rotated relative to the world (their sides are always parallel to the X, Y, and Z axes).

How it works: You just check for overlap on each axis independently. For the X-axis, you check if the range (minX1, maxX1) overlaps with (minX2, maxX2). Do this for Y and Z. If they overlap on all three axes, they are colliding.

Advantage: Very fast, only a few comparisons. Great for static objects or as a first-pass "broad phase" check to see if more complex shapes are even close enough to bother checking.

OBB vs. OBB (Oriented Bounding Box): This is the direct 3D version of what we just did with triangles. These boxes can be rotated freely.

How it works: You use the 3D Separating Axis Theorem. It's more complex because you have more axes to test. For two OBBs, there are 15 potential separating axes to check:

3 face normals from Box A.

3 face normals from Box B.

9 axes generated from the cross product of each edge of Box A with each edge of Box B.

Advantage: It's a precise, pixel-perfect collision check for rotated boxes, which are very common in physics engines.

Capsules, Cylinders, etc.:

How it works: These are often handled by calculating the shortest distance between their core defining features. For two capsules, you find the shortest distance between the two line segments that define their axes. If that distance is less than the sum of their radii, they collide.

Advantage: Capsules are excellent for representing characters and limbs because their rounded ends prevent snagging on corners.

Adding Physics (Collision Response)

What we've implemented is collision detection. The next step is collision response.

The Minimum Translation Vector (MTV): The red line I added is the most important result from SAT. It's the MTV—the smallest distance and direction you need to move one object to resolve the collision.

Step 1: Resolving Penetration: The simplest response is to move one of the objects back along the MTV by the overlap distance. This is what stops objects from sinking into each other.

Step 2: Calculating the Impulse: To make objects react realistically (i.e., bounce), you apply an impulse. An impulse is a large force applied over a very short time. Calculating it involves:

Mass (Inertia): Heavier objects are harder to move.

Velocity: How fast were the objects moving at the point of contact?

Coefficient of Restitution: A value from 0 to 1 that defines "bounciness." (0 = sticks together, 1 = perfectly elastic bounce).

Collision Normal: The direction of the force (which is the axis of the MTV).

You use these factors in an impulse equation to calculate the change in linear velocity (movement) and angular velocity (spin) for each object. This is the core of what makes a physics engine feel "real."

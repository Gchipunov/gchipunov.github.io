<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Off-Road Cargo Trailer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
            user-select: none;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            pointer-events: none;
        }
        .control-group { display: flex; gap: 20px; pointer-events: auto; }
        .btn {
            width: 80px; height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex; align-items: center; justify-content: center;
            user-select: none; touch-action: manipulation; cursor: pointer;
        }
        .btn:active { background: rgba(255, 255, 255, 0.8); color: black; transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="info">
        ⚠️ DANGER: CLIFFS & ROCKS ⚠️<br>
        Avoid Potholes | Don't fall off the edge!
    </div>

    <div id="controls">
        <div class="control-group">
            <div id="btnLeft" class="btn">←</div>
            <div id="btnRight" class="btn">→</div>
        </div>
        <div class="control-group">
            <div id="btnDown" class="btn">↓</div>
            <div id="btnUp" class="btn">↑</div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. Scene & Environment ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 30, 120);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, -30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(60, 100, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // --- 2. Terrain Generation (Cliffs & Potholes) ---
        const mapSize = 200; // The plateau size (from -100 to 100)
        
        // The Ground (Plateau)
        // We use a Box geometry to give the cliff thickness
        const groundGeo = new THREE.BoxGeometry(mapSize, 40, mapSize);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 1.0 }); // Dark Earth
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.position.y = -20; // Top face is at y=0
        ground.receiveShadow = true;
        scene.add(ground);

        // Grass Top Layer (Visual)
        const grassGeo = new THREE.PlaneGeometry(mapSize, mapSize);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x3a5f0b }); // Darker Green
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = 0.01; // Slightly above ground to prevent z-fighting
        grass.receiveShadow = true;
        scene.add(grass);

        // Obstacles Arrays
        const rocks = [];
        const potholes = [];

        // Generate Rocks
        const rockGeo = new THREE.DodecahedronGeometry(1.5, 0); // Low poly look
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8 });

        for(let i=0; i<25; i++) {
            const rock = new THREE.Mesh(rockGeo, rockMat);
            
            // Random position, avoiding center spawn area
            let x = (Math.random() - 0.5) * 160;
            let z = (Math.random() - 0.5) * 160;
            if (Math.abs(x) < 10 && Math.abs(z) < 10) x += 20; // Move away from spawn

            rock.position.set(x, 1, z);
            
            // Random scale and rotation for variety
            const scale = 0.8 + Math.random();
            rock.scale.set(scale, scale, scale);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            // Store collision data
            rock.userData = { radius: 1.5 * scale };
            
            scene.add(rock);
            rocks.push(rock);
        }

        // Generate Potholes
        // Visualized as dark flat circles on the ground
        const holeGeo = new THREE.CircleGeometry(2, 32);
        const holeMat = new THREE.MeshBasicMaterial({ color: 0x2a1d15 }); // Very dark brown

        for(let i=0; i<15; i++) {
            const hole = new THREE.Mesh(holeGeo, holeMat);
            
            let x = (Math.random() - 0.5) * 160;
            let z = (Math.random() - 0.5) * 160;
            if (Math.abs(x) < 10 && Math.abs(z) < 10) x -= 20; 

            hole.rotation.x = -Math.PI / 2;
            hole.position.set(x, 0.02, z); // Just above grass

            hole.userData = { radius: 2 };
            scene.add(hole);
            potholes.push(hole);
        }

        // --- 3. Truck & Trailer (Same as before) ---
        function createTruck() {
            const group = new THREE.Group();
            
            // Body
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 4), new THREE.MeshStandardMaterial({ color: 0xcc0000 }));
            chassis.position.y = 1; chassis.castShadow = true; group.add(chassis);
            
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0xff3333 }));
            cabin.position.set(0, 2, 1); cabin.castShadow = true; group.add(cabin);

            // Wheels
            const wGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x222 });
            [[-1.1,0.6,1.5], [1.1,0.6,1.5], [-1.1,0.6,-1.5], [1.1,0.6,-1.5]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI/2; w.position.set(...p); w.castShadow = true; group.add(w);
            });
            
            return group;
        }

        function createTrailer() {
            const group = new THREE.Group();
            
            const bed = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.5, 5), new THREE.MeshStandardMaterial({ color: 0x556B2F }));
            bed.position.y = 1; bed.castShadow = true; group.add(bed);
            
            const crate = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.8, 1.8), new THREE.MeshStandardMaterial({ color: 0xD2691E }));
            crate.position.set(0, 2.15, 0); crate.castShadow = true; group.add(crate);

            const wGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const wMat = new THREE.MeshStandardMaterial({ color: 0x222 });
            [[-1.2,0.6,-1], [1.2,0.6,-1]].forEach(p => {
                const w = new THREE.Mesh(wGeo, wMat);
                w.rotation.z = Math.PI/2; w.position.set(...p); w.castShadow = true; group.add(w);
            });
            
            // Tongue
            const tongue = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 2), new THREE.MeshStandardMaterial({ color: 0x333 }));
            tongue.position.set(0, 1, 3); group.add(tongue);

            return group;
        }

        const truck = createTruck();
        scene.add(truck);
        const trailer = createTrailer();
        scene.add(trailer);


        // --- 4. Controls & Inputs ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        
        document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        function attachTouch(id, k) {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys[k]=true; }, {passive:false});
            el.addEventListener('touchend', (e)=>{ e.preventDefault(); keys[k]=false; }, {passive:false});
            el.addEventListener('mousedown', ()=>{ keys[k]=true; });
            el.addEventListener('mouseup', ()=>{ keys[k]=false; });
        }
        attachTouch('btnUp', 'ArrowUp'); attachTouch('btnDown', 'ArrowDown');
        attachTouch('btnLeft', 'ArrowLeft'); attachTouch('btnRight', 'ArrowRight');

        // --- 5. Physics State ---
        let speed = 0;
        let steeringAngle = 0;
        let verticalVelocity = 0; // For falling
        let isFalling = false;
        
        // Settings
        const MAX_SPEED = 0.8;
        const ACCEL = 0.015;
        const FRICTION = 0.98;
        const TURN_SPEED = 0.03;
        const GRAVITY = 0.02;

        // --- 6. Game Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // --- A. Truck Movement Logic ---
            if (!isFalling) {
                // Input
                if (keys.ArrowUp) speed += ACCEL;
                else if (keys.ArrowDown) speed -= ACCEL;
                else speed *= FRICTION;

                speed = Math.max(Math.min(speed, MAX_SPEED), -MAX_SPEED/2);

                if (Math.abs(speed) > 0.01) {
                    if (keys.ArrowLeft) steeringAngle += TURN_SPEED * Math.sign(speed);
                    if (keys.ArrowRight) steeringAngle -= TURN_SPEED * Math.sign(speed);
                }

                // Apply velocity
                const dx = Math.sin(steeringAngle) * speed;
                const dz = Math.cos(steeringAngle) * speed;
                truck.position.x += dx;
                truck.position.z += dz;
                truck.rotation.y = steeringAngle;

                // --- B. Cliff Logic ---
                const halfMap = mapSize / 2;
                if (Math.abs(truck.position.x) > halfMap || Math.abs(truck.position.z) > halfMap) {
                    isFalling = true; // Uh oh
                }

                // --- C. Rock Collision ---
                // Simple Circle Collision
                const truckRadius = 2.0; 
                let hitRock = false;
                
                rocks.forEach(rock => {
                    const dist = truck.position.distanceTo(rock.position);
                    const minDist = truckRadius + rock.userData.radius;
                    if (dist < minDist) {
                        // Bounce back
                        speed = -speed * 0.6;
                        // Push truck out of rock slightly to prevent sticking
                        const pushDir = new THREE.Vector3().subVectors(truck.position, rock.position).normalize();
                        truck.position.add(pushDir.multiplyScalar(0.2));
                        hitRock = true;
                    }
                });

                // --- D. Pothole Logic ---
                // If over a pothole, dip the truck and wobble
                let inPothole = false;
                potholes.forEach(hole => {
                    const dist = truck.position.distanceTo(hole.position);
                    if (dist < hole.userData.radius) {
                        inPothole = true;
                    }
                });

                if (inPothole) {
                    // Slow down
                    speed *= 0.95;
                    // Visual Dip
                    truck.position.y = THREE.MathUtils.lerp(truck.position.y, -0.3, 0.2);
                    // Visual Wobble
                    truck.rotation.z = Math.sin(Date.now() * 0.02) * 0.1;
                    truck.rotation.x = Math.cos(Date.now() * 0.02) * 0.1;
                } else {
                    // Return to normal height
                    truck.position.y = THREE.MathUtils.lerp(truck.position.y, 0, 0.1);
                    // Return to upright
                    truck.rotation.z = THREE.MathUtils.lerp(truck.rotation.z, 0, 0.1);
                    truck.rotation.x = THREE.MathUtils.lerp(truck.rotation.x, 0, 0.1);
                }

            } else {
                // Falling Logic
                verticalVelocity -= GRAVITY;
                truck.position.y += verticalVelocity;
                truck.rotation.x += 0.05; // Tumble
                truck.position.x += Math.sin(steeringAngle) * speed; // Continue momentum
                truck.position.z += Math.cos(steeringAngle) * speed;
                
                // Reset game if fallen too far
                if (truck.position.y < -50) {
                    isFalling = false;
                    truck.position.set(0,0,0);
                    verticalVelocity = 0;
                    speed = 0;
                    truck.rotation.set(0,0,0);
                    steeringAngle = 0;
                }
            }

            // --- E. Trailer Logic ---
            // Hitch Physics
            const hitchOffset = new THREE.Vector3(0, 0, -2.1).applyAxisAngle(new THREE.Vector3(0, 1, 0), truck.rotation.y);
            const hitchPos = new THREE.Vector3().copy(truck.position).add(hitchOffset);

            // If truck is falling, drag trailer down; otherwise stay on ground
            if (isFalling) {
                trailer.position.y = hitchPos.y; 
                trailer.rotation.x = truck.rotation.x; // Copy tumble
            } else {
                trailer.position.y = 0; // Stay on ground
                trailer.rotation.x = 0;
            }

            const dxT = hitchPos.x - trailer.position.x;
            const dzT = hitchPos.z - trailer.position.z;
            trailer.rotation.y = Math.atan2(dxT, dzT);

            const trailerDist = 5.0;
            trailer.position.x = hitchPos.x - Math.sin(trailer.rotation.y) * trailerDist;
            trailer.position.z = hitchPos.z - Math.cos(trailer.rotation.y) * trailerDist;

            // --- F. Camera ---
            // Camera follows truck, but stops if truck falls too deep (dramatic effect)
            if (truck.position.y > -20) {
                const relativeCam = new THREE.Vector3(0, 12, -20);
                const camOffset = relativeCam.applyMatrix4(truck.matrixWorld);
                // Adjust Y to not go underground
                camOffset.y = Math.max(camOffset.y, 5); 
                camera.position.lerp(camOffset, 0.1);
                camera.lookAt(truck.position);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Cargo Trailer Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000000;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="info">
        Use ARROW KEYS to Drive<br>
        UP: Gas | DOWN: Brake/Reverse | LEFT/RIGHT: Turn
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, -20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(50, 50, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- 3. The Ground ---
        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest Green
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid helper for reference
        const gridHelper = new THREE.GridHelper(200, 50);
        scene.add(gridHelper);

        // --- 4. Game Objects Class Structure ---

        // Simple input handler
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        // -- The Truck --
        function createTruck() {
            const group = new THREE.Group();

            // Chassis
            const chassisGeo = new THREE.BoxGeometry(2, 1, 4);
            const chassisMat = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
            const chassis = new THREE.Mesh(chassisGeo, chassisMat);
            chassis.position.y = 1;
            chassis.castShadow = true;
            group.add(chassis);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(2, 1.5, 1.5);
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 2, 1);
            cabin.castShadow = true;
            group.add(cabin);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const positions = [
                [-1.1, 0.6, 1.5], [1.1, 0.6, 1.5], // Front
                [-1.1, 0.6, -1.5], [1.1, 0.6, -1.5] // Back
            ];

            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.castShadow = true;
                group.add(wheel);
            });

            // Hitch Point (Where the trailer connects)
            const hitchGeo = new THREE.SphereGeometry(0.2);
            const hitchMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const hitch = new THREE.Mesh(hitchGeo, hitchMat);
            hitch.position.set(0, 1, -2.1);
            group.add(hitch);

            return group;
        }

        // -- The Trailer --
        function createTrailer() {
            const group = new THREE.Group();

            // Bed
            const bedGeo = new THREE.BoxGeometry(2.2, 0.5, 5);
            const bedMat = new THREE.MeshStandardMaterial({ color: 0x556B2F }); // Olive Green
            const bed = new THREE.Mesh(bedGeo, bedMat);
            bed.position.y = 1;
            bed.castShadow = true;
            group.add(bed);

            // Cargo (A crate)
            const crateGeo = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            const crateMat = new THREE.MeshStandardMaterial({ color: 0xD2691E }); // Chocolate
            const crate = new THREE.Mesh(crateGeo, crateMat);
            crate.position.set(0, 2.15, 0);
            crate.castShadow = true;
            group.add(crate);

            // Wheels (Trailer needs wheels further back)
            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const positions = [
                [-1.2, 0.6, -1], [1.2, 0.6, -1]
            ];

            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.castShadow = true;
                group.add(wheel);
            });

            // Tongue (The bar that connects to the truck)
            const tongueGeo = new THREE.BoxGeometry(0.2, 0.2, 2);
            const tongueMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const tongue = new THREE.Mesh(tongueGeo, tongueMat);
            tongue.position.set(0, 1, 3); // Stick out the front
            group.add(tongue);

            return group;
        }

        const truck = createTruck();
        scene.add(truck);

        const trailer = createTrailer();
        scene.add(trailer);

        // --- 5. Game Physics Variables ---
        
        let speed = 0;
        let steeringAngle = 0;
        const maxSpeed = 0.8;
        const acceleration = 0.01;
        const friction = 0.98;
        const turnSpeed = 0.03;

        // Trailer Physics State
        // The trailer position is calculated based on the truck's hitch position
        let trailerAngle = 0; 
        const trailerLength = 6.0; // Distance from trailer center to hitch point

        // --- 6. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // -- Input Logic --
            if (keys.ArrowUp) {
                speed += acceleration;
            } else if (keys.ArrowDown) {
                speed -= acceleration;
            } else {
                speed *= friction; // Slow down if no key pressed
            }

            // Cap speed
            if (speed > maxSpeed) speed = maxSpeed;
            if (speed < -maxSpeed / 2) speed = -maxSpeed / 2;

            // Steering (only steer if moving)
            if (Math.abs(speed) > 0.01) {
                if (keys.ArrowLeft) steeringAngle += turnSpeed * Math.sign(speed);
                if (keys.ArrowRight) steeringAngle -= turnSpeed * Math.sign(speed);
            }
            
            // Move Truck
            truck.rotation.y = steeringAngle;
            truck.position.x += Math.sin(truck.rotation.y) * speed;
            truck.position.z += Math.cos(truck.rotation.y) * speed;

            // -- Trailer Logic (The Maths) --
            // 1. Calculate where the hitch is currently (Back of truck)
            // The hitch is offset -2.1 units locally from truck center
            const hitchOffset = new THREE.Vector3(0, 0, -2.1); 
            hitchOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), truck.rotation.y);
            const hitchPos = new THREE.Vector3().copy(truck.position).add(hitchOffset);

            // 2. Calculate the target angle for the trailer to face the hitch
            // This is basic "follow" logic. The trailer wants to point at the hitch.
            const dx = hitchPos.x - trailer.position.x;
            const dz = hitchPos.z - trailer.position.z;
            const targetAngle = Math.atan2(dx, dz);

            // 3. Move the trailer towards the hitch, keeping fixed distance (constraint)
            // We set the trailer rotation to face the hitch
            trailer.rotation.y = targetAngle;

            // We calculate where the trailer SHOULD be if it's 'trailerLength' away from hitch
            // Ideally, we move the trailer so its front tongue (offset) matches the hitch
            // But a simpler visual trick for a game is:
            // Place trailer at hitch position, then move it BACKWARDS by the tongue length
            
            // Trailer center position calculation:
            // trailer.pos = hitchPos - (forwardVector * trailerDistance)
            const trailerDistance = 5.0; // Distance from hitch to trailer center
            trailer.position.x = hitchPos.x - Math.sin(trailer.rotation.y) * trailerDistance;
            trailer.position.z = hitchPos.z - Math.cos(trailer.rotation.y) * trailerDistance;


            // -- Camera Follow --
            // Smoothly interpolate camera position behind the truck
            const relativeCameraOffset = new THREE.Vector3(0, 10, -15);
            const cameraOffset = relativeCameraOffset.applyMatrix4(truck.matrixWorld);
            
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(truck.position);

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

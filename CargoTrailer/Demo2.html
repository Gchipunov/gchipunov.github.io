<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebGL Cargo Trailer Game - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000000;
            pointer-events: none;
            user-select: none;
        }

        /* --- Touch Controls Styles --- */
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* Let clicks pass through empty space */
        }

        .control-group {
            display: flex;
            gap: 15px;
            pointer-events: auto; /* Re-enable clicks for buttons */
        }

        .btn {
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            cursor: pointer;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <div id="info">
        Desktop: Arrow Keys | Mobile: Touch Buttons<br>
        Drive carefully!
    </div>

    <div id="controls">
        <div class="control-group">
            <div id="btnLeft" class="btn">←</div>
            <div id="btnRight" class="btn">→</div>
        </div>
        
        <div class="control-group">
            <div id="btnDown" class="btn">↓</div>
            <div id="btnUp" class="btn">↑</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, -20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- 2. Lighting ---
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(50, 50, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // --- 3. The Ground ---
        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); 
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(200, 50);
        scene.add(gridHelper);

        // --- 4. Game Objects Class Structure ---

        // Input State
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

        // Keyboard Listeners
        document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });

        // --- NEW: Touch Control Logic ---
        function attachTouchControl(elementId, keyName) {
            const el = document.getElementById(elementId);
            
            // Touch Events (Mobile)
            el.addEventListener('touchstart', (e) => { 
                e.preventDefault(); // Prevent scrolling/zooming
                keys[keyName] = true; 
            }, { passive: false });
            
            el.addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                keys[keyName] = false; 
            }, { passive: false });

            // Mouse Events (For testing on desktop)
            el.addEventListener('mousedown', (e) => { keys[keyName] = true; });
            el.addEventListener('mouseup', (e) => { keys[keyName] = false; });
            el.addEventListener('mouseleave', (e) => { keys[keyName] = false; });
        }

        attachTouchControl('btnUp', 'ArrowUp');
        attachTouchControl('btnDown', 'ArrowDown');
        attachTouchControl('btnLeft', 'ArrowLeft');
        attachTouchControl('btnRight', 'ArrowRight');

        // -- The Truck --
        function createTruck() {
            const group = new THREE.Group();

            const chassisGeo = new THREE.BoxGeometry(2, 1, 4);
            const chassisMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const chassis = new THREE.Mesh(chassisGeo, chassisMat);
            chassis.position.y = 1;
            chassis.castShadow = true;
            group.add(chassis);

            const cabinGeo = new THREE.BoxGeometry(2, 1.5, 1.5);
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 2, 1);
            cabin.castShadow = true;
            group.add(cabin);

            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const positions = [[-1.1, 0.6, 1.5], [1.1, 0.6, 1.5], [-1.1, 0.6, -1.5], [1.1, 0.6, -1.5]];
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.castShadow = true;
                group.add(wheel);
            });

            const hitchGeo = new THREE.SphereGeometry(0.2);
            const hitchMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const hitch = new THREE.Mesh(hitchGeo, hitchMat);
            hitch.position.set(0, 1, -2.1);
            group.add(hitch);

            return group;
        }

        // -- The Trailer --
        function createTrailer() {
            const group = new THREE.Group();

            const bedGeo = new THREE.BoxGeometry(2.2, 0.5, 5);
            const bedMat = new THREE.MeshStandardMaterial({ color: 0x556B2F });
            const bed = new THREE.Mesh(bedGeo, bedMat);
            bed.position.y = 1;
            bed.castShadow = true;
            group.add(bed);

            const crateGeo = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            const crateMat = new THREE.MeshStandardMaterial({ color: 0xD2691E });
            const crate = new THREE.Mesh(crateGeo, crateMat);
            crate.position.set(0, 2.15, 0);
            crate.castShadow = true;
            group.add(crate);

            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const positions = [[-1.2, 0.6, -1], [1.2, 0.6, -1]];
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                wheel.castShadow = true;
                group.add(wheel);
            });

            const tongueGeo = new THREE.BoxGeometry(0.2, 0.2, 2);
            const tongueMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const tongue = new THREE.Mesh(tongueGeo, tongueMat);
            tongue.position.set(0, 1, 3);
            group.add(tongue);

            return group;
        }

        const truck = createTruck();
        scene.add(truck);

        const trailer = createTrailer();
        scene.add(trailer);

        // --- 5. Game Physics Variables ---
        let speed = 0;
        let steeringAngle = 0;
        const maxSpeed = 0.8;
        const acceleration = 0.01;
        const friction = 0.98;
        const turnSpeed = 0.03;

        // --- 6. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // -- Input Logic --
            if (keys.ArrowUp) {
                speed += acceleration;
            } else if (keys.ArrowDown) {
                speed -= acceleration;
            } else {
                speed *= friction;
            }

            if (speed > maxSpeed) speed = maxSpeed;
            if (speed < -maxSpeed / 2) speed = -maxSpeed / 2;

            if (Math.abs(speed) > 0.01) {
                if (keys.ArrowLeft) steeringAngle += turnSpeed * Math.sign(speed);
                if (keys.ArrowRight) steeringAngle -= turnSpeed * Math.sign(speed);
            }
            
            // Move Truck
            truck.rotation.y = steeringAngle;
            truck.position.x += Math.sin(truck.rotation.y) * speed;
            truck.position.z += Math.cos(truck.rotation.y) * speed;

            // -- Trailer Logic --
            const hitchOffset = new THREE.Vector3(0, 0, -2.1); 
            hitchOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), truck.rotation.y);
            const hitchPos = new THREE.Vector3().copy(truck.position).add(hitchOffset);

            const dx = hitchPos.x - trailer.position.x;
            const dz = hitchPos.z - trailer.position.z;
            const targetAngle = Math.atan2(dx, dz);

            trailer.rotation.y = targetAngle;

            const trailerDistance = 5.0; 
            trailer.position.x = hitchPos.x - Math.sin(trailer.rotation.y) * trailerDistance;
            trailer.position.z = hitchPos.z - Math.cos(trailer.rotation.y) * trailerDistance;

            // -- Camera Follow --
            const relativeCameraOffset = new THREE.Vector3(0, 10, -15);
            const cameraOffset = relativeCameraOffset.applyMatrix4(truck.matrixWorld);
            
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(truck.position);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

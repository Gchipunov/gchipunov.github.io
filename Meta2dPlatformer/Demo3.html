<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL SAT Platformer - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #instructions {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h3>WebGL 2D Platformer (SAT Physics)</h3>
        <p>Use <b>Arrow Keys</b> or <b>WASD</b> to move and jump.</p>
        <p>Platforms Rotated: 15&deg;, 25&deg;, 45&deg;</p>
    </div>
    <canvas id="glcanvas"></canvas>

<script>
/** * MATH UTILITIES (Matrix & Vector) */
const Mat3 = {
    // WebGL uses Column-Major format [m00, m10, m20, m01, m11, m21, m02, m12, m22]
    identity: () => [
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
    ],
    
    projection: (width, height) => [
        2 / width, 0, 0,
        0, -2 / height, 0,
        -1, 1, 1
    ],

    translation: (tx, ty) => [
        1, 0, 0,
        0, 1, 0,
        tx, ty, 1
    ],

    rotation: (angleInRadians) => {
        const c = Math.cos(angleInRadians);
        const s = Math.sin(angleInRadians);
        return [
            c, s, 0,
            -s, c, 0,
            0, 0, 1
        ];
    },

    scaling: (sx, sy) => [
        sx, 0, 0,
        0, sy, 0,
        0, 0, 1
    ],

    // Fixed Multiplication for Column-Major WebGL
    multiply: (a, b) => {
        const b00 = b[0*3+0], b01 = b[0*3+1], b02 = b[0*3+2];
        const b10 = b[1*3+0], b11 = b[1*3+1], b12 = b[1*3+2];
        const b20 = b[2*3+0], b21 = b[2*3+1], b22 = b[2*3+2];
        const a00 = a[0*3+0], a01 = a[0*3+1], a02 = a[0*3+2];
        const a10 = a[1*3+0], a11 = a[1*3+1], a12 = a[1*3+2];
        const a20 = a[2*3+0], a21 = a[2*3+1], a22 = a[2*3+2];
        return [
            b00 * a00 + b01 * a10 + b02 * a20,
            b00 * a01 + b01 * a11 + b02 * a21,
            b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20,
            b10 * a01 + b11 * a11 + b12 * a21,
            b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20,
            b20 * a01 + b21 * a11 + b22 * a21,
            b20 * a02 + b21 * a12 + b22 * a22,
        ];
    }
};

const Vec2 = {
    add: (v1, v2) => ({x: v1.x + v2.x, y: v1.y + v2.y}),
    sub: (v1, v2) => ({x: v1.x - v2.x, y: v1.y - v2.y}),
    dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
    scale: (v, s) => ({x: v.x * s, y: v.y * s}),
    normalize: (v) => {
        const len = Math.sqrt(v.x*v.x + v.y*v.y);
        return len > 0 ? {x: v.x/len, y: v.y/len} : {x:0, y:0};
    }
};

/** WEBGL SETUP */
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) { alert("WebGL not supported"); }

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

const vsSource = `
    attribute vec2 a_position;
    uniform mat3 u_matrix;
    void main() {
        // Multiply matrix by the position vector
        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
    }
`;

const fsSource = `
    precision mediump float;
    uniform vec4 u_color;
    void main() {
        gl_FragColor = u_color;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
gl.linkProgram(program);
gl.useProgram(program);

const positionLoc = gl.getAttribLocation(program, "a_position");
const matrixLoc = gl.getUniformLocation(program, "u_matrix");
const colorLoc = gl.getUniformLocation(program, "u_color");

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -0.5, -0.5,
     0.5, -0.5,
    -0.5,  0.5,
    -0.5,  0.5,
     0.5, -0.5,
     0.5,  0.5,
]), gl.STATIC_DRAW);

gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

function drawRect(x, y, w, h, rotation, color) {
    let matrix = Mat3.projection(gl.canvas.width, gl.canvas.height);
    matrix = Mat3.multiply(matrix, Mat3.translation(x, y));
    matrix = Mat3.multiply(matrix, Mat3.rotation(rotation));
    matrix = Mat3.multiply(matrix, Mat3.scaling(w, h));

    gl.uniformMatrix3fv(matrixLoc, false, matrix);
    gl.uniform4fv(colorLoc, color);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/** PHYSICS CLASSES */
class Box {
    constructor(x, y, w, h, angle = 0, isStatic = true) {
        this.pos = {x, y};
        this.w = w;
        this.h = h;
        this.angle = angle;
        this.isStatic = isStatic;
        this.color = isStatic ? [0.6, 0.6, 0.6, 1] : [1, 0.3, 0.3, 1];
        this.vel = {x: 0, y: 0};
        this.grounded = false;
    }

    getCorners() {
        const c = Math.cos(this.angle), s = Math.sin(this.angle);
        const hw = this.w / 2, hh = this.h / 2;
        const locals = [{x: -hw, y: -hh}, {x: hw, y: -hh}, {x: hw, y: hh}, {x: -hw, y: hh}];
        return locals.map(p => ({
            x: this.pos.x + (p.x * c - p.y * s),
            y: this.pos.y + (p.x * s + p.y * c)
        }));
    }

    getAxes() {
        const c = Math.cos(this.angle), s = Math.sin(this.angle);
        return [{x: c, y: s}, {x: -s, y: c}];
    }
}

// SAT Implementation
function checkCollision(b1, b2) {
    const corners1 = b1.getCorners(), corners2 = b2.getCorners();
    const axes = [...b1.getAxes(), ...b2.getAxes()];
    let minOverlap = Infinity, smallestAxis = null;

    for (let axis of axes) {
        const p1 = project(corners1, axis), p2 = project(corners2, axis);
        const overlapAmt = getOverlap(p1, p2);
        if (overlapAmt <= 0) return false;
        if (overlapAmt < minOverlap) {
            minOverlap = overlapAmt;
            smallestAxis = axis;
        }
    }

    const centerDir = Vec2.sub(b1.pos, b2.pos);
    if (Vec2.dot(centerDir, smallestAxis) < 0) smallestAxis = Vec2.scale(smallestAxis, -1);
    return { overlap: minOverlap, axis: smallestAxis };
}

function project(corners, axis) {
    let min = Infinity, max = -Infinity;
    for (let p of corners) {
        const dot = p.x * axis.x + p.y * axis.y;
        min = Math.min(min, dot);
        max = Math.max(max, dot);
    }
    return {min, max};
}

function getOverlap(p1, p2) {
    return Math.min(p1.max, p2.max) - Math.max(p1.min, p2.min);
}

/** GAME LOOP */
const rad = deg => deg * Math.PI / 180;
const player = new Box(100, 100, 30, 30, 0, false);
const platforms = [
    new Box(window.innerWidth/2, window.innerHeight - 50, window.innerWidth - 100, 40, 0),
    new Box(300, 450, 200, 20, rad(15)),
    new Box(600, 350, 200, 20, rad(-25)),
    new Box(200, 250, 200, 20, rad(45))
];

const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

function update() {
    player.vel.y += 0.5; // Gravity
    if (keys['ArrowLeft'] || keys['KeyA']) player.vel.x -= 0.5;
    if (keys['ArrowRight'] || keys['KeyD']) player.vel.x += 0.5;
    
    player.vel.x *= 0.9; // Friction
    player.pos.x += player.vel.x;
    player.pos.y += player.vel.y;

    player.grounded = false;
    for (let plat of platforms) {
        const col = checkCollision(player, plat);
        if (col) {
            player.pos.x += col.axis.x * col.overlap;
            player.pos.y += col.axis.y * col.overlap;
            const dot = player.vel.x * col.axis.x + player.vel.y * col.axis.y;
            if (dot < 0) {
                player.vel.x -= col.axis.x * dot;
                player.vel.y -= col.axis.y * dot;
            }
            if (col.axis.y < -0.5) player.grounded = true;
        }
    }

    if (player.grounded && (keys['ArrowUp'] || keys['KeyW'] || keys['Space'])) {
        player.vel.y = -12;
    }
    
    if (player.pos.y > canvas.height + 100) player.pos = {x: 100, y: 100};
}

function draw() {
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    platforms.forEach(p => drawRect(p.pos.x, p.pos.y, p.w, p.h, p.angle, p.color));
    drawRect(player.pos.x, player.pos.y, player.w, player.h, player.angle, player.color);
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>

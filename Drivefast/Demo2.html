<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Reckless City Driver</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:sans-serif; }
        canvas { display:block; }
        
        /* Mobile Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
            pointer-events: none;
        }
        .btn {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            user-select: none;
            pointer-events: all;
            backdrop-filter: blur(5px);
            border: 3px solid rgba(255,255,255,0.5);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }
        .btn:active { background: rgba(255,255,255,0.6); }
        
        #leftRight { display:flex; gap:20px; }
        
        /* Recklessness Meter */
        #recklessMeter {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 30px;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            overflow: hidden;
            border: 3px solid #fff;
            z-index: 10;
        }
        #recklessFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff8800, #ff0000);
            transition: width 0.3s ease;
        }
        #recklessText {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            color: white;
            font-weight: bold;
            text-align: center;
            line-height: 30px;
            text-shadow: 1px 1px 3px black;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
</head>
<body>

    <!-- Recklessness Meter -->
    <div id="recklessMeter">
        <div id="recklessFill"></div>
        <div id="recklessText">RECKLESSNESS: 0%</div>
    </div>

    <!-- Mobile Controls -->
    <div id="controls">
        <div id="leftRight">
            <div class="btn" id="leftBtn">←</div>
            <div class="btn" id="rightBtn">→</div>
        </div>
        <div>
            <div class="btn" id="accelBtn">▲</div>
            <div class="btn" id="brakeBtn">▼</div>
        </div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 100, 50);
        scene.add(sun);

        // Road
        const road = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 1000),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        road.rotation.x = -Math.PI / 2;
        road.position.y = -0.01;
        scene.add(road);

        // Lane lines
        for (let x of [-4, 0, 4]) {
            const line = new THREE.Mesh(
                new THREE.PlaneGeometry(0.4, 1000),
                new THREE.MeshBasicMaterial({ color: x === 0 ? 0xffff00 : 0xffffff })
            );
            line.rotation.x = -Math.PI / 2;
            line.position.x = x;
            line.position.y = 0.01;
            scene.add(line);
        }

        // Buildings
        for (let i = -20; i < 30; i++) {
            const h = Math.random() * 15 + 8;
            const building = new THREE.Mesh(
                new THREE.BoxGeometry(8, h, 8),
                new THREE.MeshLambertMaterial({ color: 0x666666 + Math.random() * 0x222222 })
            );
            building.position.y = h / 2;
            building.position.z = i * 25;
            building.position.x = Math.random() > 0.5 ? -15 : 15;
            scene.add(building);
        }

        // Player car (red)
        const playerCar = new THREE.Group();
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.8, 4),
            new THREE.MeshLambertMaterial({ color: 0xff0000 })
        );
        const roof = new THREE.Mesh(
            new THREE.BoxGeometry(1.2, 0.6, 2),
            new THREE.MeshLambertMaterial({ color: 0xcc0000 })
        );
        roof.position.y = 0.7;
        playerCar.add(body);
        playerCar.add(roof);
        playerCar.position.y = 0.5;
        scene.add(playerCar);

        // AI Traffic
        const traffic = [];
        for (let i = 0; i < 12; i++) {
            const car = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 4),
                new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
            );
            car.position.y = 0.5;
            car.position.z = -50 - i * 40;
            car.position.x = [-4, 0, 4][Math.floor(Math.random() * 3)];
            car.userData.speed = Math.random() * 3 + 4;
            scene.add(car);
            traffic.push(car);
        }

        // Oncoming cars (risky right turns)
        const oncoming = [];
        for (let i = 0; i < 5; i++) {
            const car = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 4),
                new THREE.MeshLambertMaterial({ color: 0x00ff88 })
            );
            car.position.y = 0.5;
            car.position.z = -300 - i * 60;
            car.position.x = 4;
            car.userData.speed = -(Math.random() * 3 + 5);
            scene.add(car);
            oncoming.push(car);
        }

        // Game state
        let playerSpeed = 0;
        const maxSpeed = 8;
        let steering = 0;
        let recklessness = 0;
        const recklessnessFill = document.getElementById('recklessFill');
        const recklessnessText = document.getElementById('recklessText');

        // Mobile button controls
        const accelBtn = document.getElementById('accelBtn');
        const brakeBtn = document.getElementById('brakeBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        const accel = { pressed: false };
        const brake = { pressed: false };
        const left = { pressed: false };
        const right = { pressed: false };

        accelBtn.addEventListener('touchstart', e => { e.preventDefault(); accel.pressed = true; });
        accelBtn.addEventListener('touchend', e => { e.preventDefault(); accel.pressed = false; });
        brakeBtn.addEventListener('touchstart', e => { e.preventDefault(); brake.pressed = true; });
        brakeBtn.addEventListener('touchend', e => { e.preventDefault(); brake.pressed = false; });
        leftBtn.addEventListener('touchstart', e => { e.preventDefault(); left.pressed = true; });
        leftBtn.addEventListener('touchend', e => { e.preventDefault(); left.pressed = false; });
        rightBtn.addEventListener('touchstart', e => { e.preventDefault(); right.pressed = true; });
        rightBtn.addEventListener('touchend', e => { e.preventDefault(); right.pressed = false; });

        // Keyboard fallback
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp' || e.key === 'w') accel.pressed = true;
            if (e.key === 'ArrowDown' || e.key === 's') brake.pressed = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') left.pressed = true;
            if (e.key === 'ArrowRight' || e.key === 'd') right.pressed = true;
        });
        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowUp' || e.key === 'w') accel.pressed = false;
            if (e.key === 'ArrowDown' || e.key === 's') brake.pressed = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') left.pressed = false;
            if (e.key === 'ArrowRight' || e.key === 'd') right.pressed = false;
        });

        // Two-finger free camera
        let isTwoFinger = false;
        let prevAngleX = 0, prevAngleY = 0;
        let camAngleX = 0, camAngleY = 0.3;

        renderer.domElement.addEventListener('touchstart', e => {
            if (e.touches.length === 2) {
                isTwoFinger = true;
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                prevAngleX = (t1.clientX + t2.clientX) / 2;
                prevAngleY = (t1.clientY + t2.clientY) / 2;
                e.preventDefault();
            }
        });

        renderer.domElement.addEventListener('touchmove', e => {
            if (isTwoFinger && e.touches.length === 2) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const midX = (t1.clientX + t2.clientX) / 2;
                const midY = (t1.clientY + t2.clientY) / 2;

                const dx = midX - prevAngleX;
                const dy = midY - prevAngleY;

                camAngleX += dx * 0.005;
                camAngleY += dy * 0.005;
                camAngleY = Math.max(0.1, Math.min(1.2, camAngleY));

                prevAngleX = midX;
                prevAngleY = midY;
                e.preventDefault();
            }
        });

        renderer.domElement.addEventListener('touchend', () => {
            isTwoFinger = false;
        });

        // Update recklessness
        function addRecklessness(amount) {
            recklessness = Math.min(100, recklessness + amount);
            recklessnessFill.style.width = recklessness + '%';
            recklessnessText.textContent = `RECKLESSNESS: ${Math.round(recklessness)}%`;

            if (recklessness >= 100) {
                recklessnessText.textContent = "COPS CALLED! YOU LOSE!";
                recklessnessFill.style.background = "#ff0000";
                playerSpeed *= 0.3;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Input handling
            if (accel.pressed) {
                playerSpeed = Math.min(playerSpeed + 0.15, maxSpeed);
            } else if (brake.pressed) {
                playerSpeed = Math.max(playerSpeed - 0.2, -maxSpeed * 0.5);
            } else {
                playerSpeed *= 0.98;
            }

            steering = (right.pressed ? 1 : 0) - (left.pressed ? 1 : 0);
            playerCar.position.x += steering * 0.15 * (playerSpeed > 0 ? 1 : -1);
            playerCar.position.x = Math.max(-8, Math.min(8, playerCar.position.x));

            playerCar.position.z -= playerSpeed;

            // Recklessness from swerving + speed
            if (Math.abs(steering) > 0.5 && Math.abs(playerSpeed) > 4) {
                addRecklessness(0.1);
            }
            if (Math.abs(playerSpeed) > 7) addRecklessness(0.05);

            // Traffic
            traffic.forEach(car => {
                car.position.z -= car.userData.speed + playerSpeed * 0.8;
                if (car.position.z < playerCar.position.z - 50) {
                    car.position.z += 600;
                    car.position.x = [-4, 0, 4][Math.floor(Math.random() * 3)];
                }
            });

            oncoming.forEach(car => {
                car.position.z -= car.userData.speed + playerSpeed * 0.8;
                if (car.position.z > playerCar.position.z + 100) {
                    car.position.z -= 800;
                }
            });

            // Collision
            const checkCollision = (a, b) => {
                return Math.abs(a.position.z - b.position.z) < 5 &&
                       Math.abs(a.position.x - b.position.x) < 2.5;
            };

            [...traffic, ...oncoming].forEach(car => {
                if (checkCollision(playerCar, car)) {
                    addRecklessness(25);
                    playerSpeed *= 0.4;
                }
            });

            // Camera (third person + free look)
            const camDistance = 12;
            const camHeight = 6;
            camera.position.x = playerCar.position.x + Math.sin(camAngleX) * camDistance;
            camera.position.y = playerCar.position.y + camHeight + Math.sin(camAngleY) * 8;
            camera.position.z = playerCar.position.z + Math.cos(camAngleX) * camDistance + Math.cos(camAngleY) * 10;
            camera.lookAt(playerCar.position.x, playerCar.position.y + 2, playerCar.position.z - 10);

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
